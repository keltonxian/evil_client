GAME_REV_STR="$Rev: 3215 $"
GAME_VERSION=string.gsub(GAME_REV_STR, '[ ]*$[a-zA-Z:]*[ ]*', '');

F_IMAGE      = 'image/';
F_PIC        = 'pic/';
F_FONT       = 'font/';
F_PARTICLE   = 'particle/';
F_MUSIC      = 'music/';
F_DOCX       = 'docx/';
F_ANIM       = 'anim/';
F_LANG       = nil;
F_RES        = '/'; -- see util.lua , will insert search path

FNT_CARD    = 'font_card.fnt';
FNT_CARD_2  = 'font_card2.fnt';
FNT_TIME    = 'font_time.fnt';
FNT_1       = 'font_num_1.fnt';


-- version control
LOCAL_TEST         = false;
RELOAD_MODE        = false;
SIMPLE_FIGHT       = true;
DRAG_MODE          = false;
DEBUG_INFO         = true;
SHOP_PAGE          = false;
SHOW_ALL           = false;
USE_FRAME          = false;
USE_FLASH          = true;

USE_ANIM           = true;
USE_TIP_TUTOR      = false;
alog = function(...)
	--print(string.format(...));
	--print(...);
end

-- do cmd local, then send to server
--LOCAL_CMD = false;
LOCAL_CMD = true;
g_ui = true;

-- true : use testing card
-- false : use standard card
g_init_test = true;

require ("logic")
require ("lang_zh")
require ("lang_local")
-- /////////////////////// CONSTANT START ///////////////////////////
-- define at game_initialize
CPID               = 0;
CHANNEL_VER        = 0;
VER_APPSTORE       = 1;
VER_APAY_deprecated= 2;
VER_ANYSDK         = 3;
VER_APAY           = 4;
VER_ANYSDK_NO_LOGIN= 5;
VER_LJSDK          = 6;
VER_UCSDK          = 7;

DEVICE_UNKNOWN     = 0;
DEVICE_IOS         = 1;
DEVICE_ANDROID     = 2;

PLATFORM_UNKNOWN   = 0;
PLATFORM_IPHONE    = 1;
PLATFORM_IPAD      = 2;
PLATFORM_MAC       = 3;
PLATFORM_ANDROID   = 4;
PLATFORM_WINDOWS   = 5;


-- anchor point
ANCHOR_NULL        = 99; -- the value is useless, just define for not scale
ANCHOR_LEFT        = 0;
ANCHOR_RIGHT       = 1;
ANCHOR_UP          = 1;
ANCHOR_DOWN        = 0;
ANCHOR_CENTER      = 0.5;

ANCHOR_LEFT_UP		= ccp(ANCHOR_LEFT, ANCHOR_UP);
ANCHOR_LEFT_DOWN	= ccp(ANCHOR_LEFT, ANCHOR_DOWN);
ANCHOR_LEFT_CENTER	= ccp(ANCHOR_LEFT, ANCHOR_CENTER);
ANCHOR_RIGHT_UP  	= ccp(ANCHOR_RIGHT, ANCHOR_UP);
ANCHOR_RIGHT_DOWN	= ccp(ANCHOR_RIGHT, ANCHOR_DOWN);
ANCHOR_RIGHT_CENTER	= ccp(ANCHOR_RIGHT, ANCHOR_CENTER);
ANCHOR_CENTER_CENTER= ccp(ANCHOR_CENTER, ANCHOR_CENTER);
ANCHOR_CENTER_UP    = ccp(ANCHOR_CENTER, ANCHOR_UP);
ANCHOR_CENTER_DOWN  = ccp(ANCHOR_CENTER, ANCHOR_DOWN);

FULL_WIDTH = nil;
FULL_HEIGHT = nil;
HALF_WIDTH = nil;
HALF_HEIGHT = nil;

ANIM_SCALE_CENTER = nil;

STYPE_VER_1  = 1; -- normal size
STYPE_VER_2  = 2; -- use small size card frame

HAND_GAP = 85;

-- zorder start
ZORDER_CARD_ATTACH      = -130;
ZORDER_MENU      = 1;
ZORDER_CARD      = 15;
ZORDER_COUNT_DECK  = 20;
ZORDER_CARD_TOUCH  = 25;
ZORDER_SHOWING     = 30;
ZORDER_EFFECT      = 40;
ZORDER_CARD_BG          = -100;
ZORDER_CARD_IMAGE       = -120;
ZORDER_CARD_HL          = -125;
ZORDER_CARD_ATTACH      = -130;

ZORDER_LAYER_LOADING    = 50;
ZORDER_LAYER_DEBUG      = 0;
ZORDER_LAYER_DRAGSTORY  = -1;
ZORDER_LAYER_TUTORIAL   = -1;
ZORDER_LAYER_DRAGTUTOR  = -1;
ZORDER_LAYER_TOUCH      = -3;
ZORDER_LAYER_TIP        = -5;
ZORDER_LAYER_MSG        = -10;
ZORDER_LAYER_TEXT       = -10;
ZORDER_LAYER_NOTICE     = -25;
ZORDER_LAYER_STORY      = -30;
ZORDER_LAYER_GATEPOP    = -30;
ZORDER_LAYER_FIGHT      = -35;
ZORDER_LAYER_PRANK_TIP  = -35;
ZORDER_LAYER_HORSELAMP  = -35;
ZORDER_LAYER_VIDEO      = -35;
ZORDER_LAYER_MISPOP     = -35;
ZORDER_LAYER_POPCLIST   = -35;
ZORDER_LAYER_PICKICON   = -35;
ZORDER_LAYER_ROOM       = -35;	
ZORDER_LAYER_FINDFRD    = -35;
ZORDER_LAYER_CMATCH     = -35;
ZORDER_LAYER_CODE       = -35;
ZORDER_LAYER_LOCK       = -35;
ZORDER_LAYER_CCHANNEL   = -35;
ZORDER_LAYER_CGUILD     = -35;
ZORDER_LAYER_MATCHDATA  = -35;
ZORDER_LAYER_QUICK      = -35;
ZORDER_LAYER_PAY        = -40;
ZORDER_LAYER_PAY_AD     = -40;
ZORDER_LAYER_INFO       = -40;
ZORDER_LAYER_SHOPPOP    = -40;
ZORDER_LAYER_FORUM      = -40;
ZORDER_LAYER_APPSTOREPAY= -40;
ZORDER_LAYER_SERVICE    = -40;
ZORDER_LAYER_SOLO       = -40;
ZORDER_LAYER_SOLO_PLUS  = -40;
ZORDER_LAYER_GATE       = -40;
ZORDER_LAYER_LOTTERY    = -40;
ZORDER_LAYER_FRIEND     = -40;
ZORDER_LAYER_LMATCH     = -40;
ZORDER_LAYER_LROOM      = -40;
ZORDER_LAYER_MISSION    = -40;
ZORDER_LAYER_TOWER      = -40;
ZORDER_LAYER_CPOS       = -40;
ZORDER_LAYER_APPROVE    = -50;
ZORDER_LAYER_AGUILD     = -50;
ZORDER_LAYER_AINVEST    = -50;
ZORDER_LAYER_CHATPOP    = -50;
ZORDER_LAYER_CHERO      = -60;
ZORDER_LAYER_DECKPOP    = -60;
ZORDER_LAYER_CSERVER    = -60;
ZORDER_LAYER_PICK       = -60;
ZORDER_LAYER_MORE       = -60;
ZORDER_LAYER_INFOBAR    = -60;
ZORDER_LAYER_BOTTOMBAR  = -60;
ZORDER_LAYER_RESULT     = -80;
ZORDER_LAYER_CONTROL    = -90;
ZORDER_LAYER_CHAT       = -90;
ZORDER_LAYER_MENU       = -100;
ZORDER_LAYER_GRAVE      = -120;	
ZORDER_LAYER_ANIM       = -150;
ZORDER_LAYER_ACTION     = -180;	   -- max card, attack/ability/cast button
ZORDER_LAYER_PREVIEW    = -180;
ZORDER_LAYER_BOOK       = -180;
ZORDER_LAYER_SHOP       = -260;
ZORDER_LAYER_TESTC      = -260;
ZORDER_LAYER_TESTLUA    = -260;
ZORDER_LAYER_REGISTER   = -260;
ZORDER_LAYER_GRADE      = -260;
ZORDER_LAYER_PRANK_C    = -260; -- 竞技场
ZORDER_LAYER_PRANK_R    = -260; -- 排行榜
ZORDER_LAYER_MAIL_BOX   = -260;
ZORDER_LAYER_CARD       = -260;	
ZORDER_LAYER_TABLE      = -400;
ZORDER_LAYER_ROLE       = -400;
ZORDER_LAYER_DECK       = -400;
ZORDER_LAYER_RANK       = -400;
ZORDER_LAYER_PRANK      = -400; -- power rank
ZORDER_LAYER_MAIL       = -400;
ZORDER_LAYER_GM         = -400;
ZORDER_LAYER_OPTION     = -400;
ZORDER_LAYER_PRELOAD    = -400;	
ZORDER_LAYER_LOGIN      = -400;
ZORDER_LAYER_MAP        = -400;
ZORDER_LAYER_LGUILD     = -400;
ZORDER_LAYER_GUILD      = -400;
ZORDER_LAYER_WELFARE    = -400;
ZORDER_LAYER_LMEMBER    = -400;
ZORDER_LAYER_LAPPLY     = -400;
ZORDER_LAYER_LSTOCK     = -400;
ZORDER_LAYER_INVEST     = -400;
ZORDER_LAYER_LDEPOSIT   = -400;
ZORDER_LAYER_NET        = -500;
-- zorder end

CARD_ARRAY_LIST    = 400;

-- tag start
TAG_SPRITE_LABEL     = 100;
TAG_BTN_NEXT_EFF_1   = 120;
TAG_BTN_NEXT_EFF_2   = 121;
TAG_SPRITE_SLEEP     = 450;
TAG_SPRITE_TIMER     = 460;
TAG_VIRTUAL_ACTION   = 600;
TAG_VIRTUAL_PARTICLE = 700;
TAG_STATUS_EFF       = 710;
TAG_STATUS_SPRITE    = 720;
TAG_NAME             = 798;
TAG_DESC             = 799;
TAG_HP               = 800;
TAG_COST             = 801;
TAG_POWER            = 802;
TAG_HIGHLIGHT        = 999;
TAG_CELL_BG          = 500;
TAG_CELL_LABEL       = 502;
TAG_CELL_CARD_SPRITE = 510;
TAG_LAYER_COLOR      = 520;
TAG_MISSION_FINGER   = 310;
TAG_MSG_OTHER_LOGIN  = 499;
--TAG_LAYER_TUTOR      = 777;
-- tag end

-- scene stage start
STAGE_LOGIN       = 1;
STAGE_PVP         = 2;
STAGE_MAP         = 3;
STAGE_ROLE        = 4;
STAGE_DECK        = 5;
STAGE_SHOP        = 6;
STAGE_TESTLUA     = 7;
STAGE_TESTC       = 8;
STAGE_PVE         = 9;
STAGE_PRELOAD     = 10;
--STAGE_INFO        = 11;
STAGE_REPLAY      = 12;
STAGE_RANK        = 13;
STAGE_GM          = 14;
STAGE_OPTION      = 15;
STAGE_LGUILD      = 16;
STAGE_GUILD       = 17;
STAGE_WELFARE     = 18;
STAGE_LMEMBER     = 19;
STAGE_LAPPLY      = 20;
STAGE_LSTOCK      = 21;
STAGE_INVEST      = 22;
STAGE_LDEPOSIT    = 23;
STAGE_PRANK       = 14;
STAGE_MAIL        = 15;
STAGE_PVG         = 16;
-- scene stage end

GAME_SOLO         = 1;
GAME_QUICK        = 2;
GAME_ROOM         = 3;
GAME_CHALLENGE    = 4;
GAME_MATCH        = 5;
GAME_RANK         = 6;
GAME_GATE         = 7;
GAME_SOLO_GOLD    = 8;
GAME_VS_GOLD      = 9;
GAME_VS_CRYSTAL   = 10;
GAME_SOLO_FREE    = 11;
GAME_VS_FREE      = 12;
GAME_TOWER        = 13;
GAME_SOLO_PLUS    = 14;

-- side
SIDE_GUEST         = 99; -- CONSTANT
-- will be set at each time game starts..
-- set in data_handler.init_side
SIDE_UP            = 0;
SIDE_DOWN          = 0;
-- card is in which kind of table
-- will be set at each time game starts..
-- set in data_handler.init_side
DOWN_HERO     = 0;
DOWN_HAND     = 0;
DOWN_ALLY     = 0;
DOWN_SUPPORT  = 0;
DOWN_GRAVE    = 0;
DOWN_DECK     = 0;
DOWN_RES      = 0;
UP_HERO       = 0;
UP_HAND       = 0;
UP_ALLY       = 0;
UP_SUPPORT    = 0;
UP_GRAVE      = 0;
UP_DECK       = 0;
UP_RES        = 0;

-- attack_type
TYPE_NONE          = 1;
TYPE_ATTACK        = 2;
TYPE_ABILITY       = 3;
TYPE_BOTH          = 4;

-- card_highlight type
HL_ATTACK    = 1;
HL_ABILITY   = 2;
HL_BOTH      = 3;
HL_TBOTH     = 4;
HL_TARGET    = 11;
HL_SAC       = 12;

CARD_FRONT      = 1;
CARD_COVER      = 2;
CARD_GRAVE      = 3;
CARD_ALLY       = 4;
CARD_SUPPORT    = 5;
CARD_HERO       = 6;
CARD_ATTACH     = 7;
CARD_VIRTUAL    = 8;

-- action kind, @see in function check_kind(...)
AKIND_NONE         = 0;
AKIND_ATTACK       = 1;
AKIND_ABILITY      = 2;
AKIND_BOTH         = 3; -- both attack and ability
AKIND_SAC          = 4;
AKIND_TALLY        = 5; -- hand to ally
AKIND_TSUPPORT     = 6; -- hand to support
AKIND_TGRAVE       = 7; -- target is in grave

DURATION_NUM_EFF = 1.0;

-- step_constant
STEP_NONE          = 0
STEP_CHOOSE        = 1  -- choose a card to do action, such as attack or ability
STEP_TARGET        = 2  -- choose target card to attack or ability

-- should be same as server
ST_NULL            = 0;
ST_LOGIN           = 5;
ST_ROOM            = 10;
ST_GAME            = 15;

-- GUILD POS
GUILD_POS_NONE     = 0;
GUILD_POS_MASTER   = 1;
GUILD_POS_SENIOR   = 2;
GUILD_POS_MEMBER   = 3;
GUILD_POS_APPLY    = 9;

-- SEX
SEX_MALE      = 0;
SEX_FEMALE    = 1;

-- ladder
LADDER_RATING   = 0;
LADDER_LEVEL    = 1;
LADDER_GUILD    = 2;
LADDER_COLLECT  = 3;
LADDER_GOLD     = 4;

-- chat channel
C_ALL      = 1;   -- 全部
C_WORLD    = 2;   -- 世界
C_ROOM     = 3;   -- 房间
C_GUILD    = 4;   -- 公会
C_PRIVATE  = 5;   -- 私聊
C_LOG      = 6;  -- 日志

-- MATCH STATUS DEFINE
-- keep these same as sever --
MATCH_STATUS_READY          = 0;
MATCH_STATUS_ROUND_START    = 1;
MATCH_STATUS_ROUND_END      = 2;
MATCH_STATUS_FINISHED       = 3;
MATCH_STATUS_DELETE         = 9;
------------------------------

-- ui size start
CARD_SIZE = { width = 311, height = 481 };
CARD_SIZE_2 = { width = 80, height = 112 };
PIC_SIZE = { width = 297, height = 270 };
SCREEN_SIZE_REF = { width = 640, height = 960 };
-- ui size end

-- tutorial start
TUTOR_STORY          = 1;
TUTOR_FIRST_SAC      = 2;
TUTOR_WAIT_NEXT_SAC  = 3;
TUTOR_WAIT_NEXT      = 301;
TUTOR_SECOND_SAC     = 4;
TUTOR_HIGHLIGHT_CARD = 5;
TUTOR_SOMMON_CARD    = 501;
TUTOR_WYLD_SKILL     = 6;
TUTOR_NO_TARGET_ATK  = 601;
TUTOR_REST           = 7;
TUTOR_ATTACK         = 8;
TUTOR_INTRO          = 9;
TUTOR_AREA           = 901;
TUTOR_AREA_RES       = 902;
TUTOR_AREA_HAND      = 903;
TUTOR_AREA_HERO      = 904;
TUTOR_AREA_DECK      = 905;
TUTOR_AREA_SPACE     = 906;
TUTOR_TURN_SAC       = 907;
TUTOR_PVP_CAN_ATTACK = 10;
TUTOR_PVP_ATTACK     = 11;
TUTOR_PAY_AD         = 12;
TUTOR_PAY            = 13;
TUTOR_DECK           = 14;

TUTOR_RES            = 1200;
TUTOR_TAP_CARD       = 1201;
TUTOR_COST           = 1300;
TUTOR_DESC           = 1400;
TUTOR_HERO_POWER     = 1500;
TUTOR_HERO_HP        = 1501;
TUTOR_ALLY_ATTACK    = 1600;
TUTOR_ALLY_HP        = 1601;
TUTOR_WEAPON_ATK     = 1700;
TUTOR_WEAPON_DUR     = 1701;
TUTOR_ARMOR_DEF      = 1800;
TUTOR_ARMOR_DUR      = 1801;
TUTOR_SAC            = 1900;
TUTOR_PLAY           = 2000;
TUTOR_HL             = 2100;
TUTOR_SAC_TAP        = 2200;
TUTOR_USE            = 2300;
TUTOR_HL_ALLY        = 2400;
TUTOR_TAP_ATTACK     = 2500;
TUTOR_HL_ATTARGET    = 2600;
TUTOR_TAP_ATTARGET   = 2700;
TUTOR_HL_HERO        = 2800;
TUTOR_TAP_ABHERO     = 2900;
TUTOR_NEED_RES       = 3000;
TUTOR_NEXT           = 3100;
TUTOR_TAP_SKIP       = 3200;
TUTOR_SOLO           = 3300;


TUTOR_TEST           = 9999;
-- > 100 means not mark at g_tutor, should always trigger
-- see util.set_trigger and util.check_trigger
-- tutorial end -- max is 30;
-- /////////////////////// CONSTANT END ///////////////////////////

-- /////////////////////// VAR START ///////////////////////////
g_lang = nil;
g_scale = nil;
-- @see in disable_touch, enable_touch
g_touchable     = 0;
g_constant = {};
g_list_shop = {};
g_tutor = 0;
g_tutor_change = nil;
g_mission_tip = 1;
-- about game --
-- @see step_constant
g_step = STEP_NONE;
g_ui_table = {};
g_all_card_list = {};
g_sprite_cache = {}; -- table card
g_pic_cache = {}; -- grave
g_last_phase = 0; -- only be used for pop_phase
-- @see in init_net_play
g_net_play_cache = {};
g_stop_play_cmd = false;
-- revceive net_game cmd_size
g_net_cmdsize = 0;
-- only for net_game
g_game_info = nil;
-- only for net_play
g_game_play_list = nil;
-- @see in check_cmd_finish()
g_net_win_data = nil;
g_cache_cmd_list = {};
g_src_index = 0;
g_action_type = TYPE_NONE;
-- about game --
g_chat_list = {
	[C_ALL] = {},
	[C_WORLD] = {},
	[C_ROOM] = {},
	[C_GUILD] = {},
	[C_PRIVATE] = {},
	[C_LOG] = {},
};

g_sensitive_list = {};

g_euser = {
	-- info
	username = '', -- 账号名
	userid = 0, -- for anysdk
	password = '', -- for anysdk save pw
	eid = 0,
	level = 0,   -- 等级
	rating = 0,  -- 邪恶值
	gold = 0,    -- 金币
	crystal = 0, -- 水晶
	game_count = 0, -- 比赛场数
	game_win = 0,   -- 胜利场数
	game_lose = 0,  -- 失败场数
	game_draw = 0,  -- 平局场数
	game_run = 0,   -- 逃跑场数
	icon = '',      -- 头像
	alias = '',     -- 昵称
	gid = 0,        -- 公会id
	gpos = GUILD_POS_NONE,  -- 公会职位
	gname = '',     -- 公会名称
	exp = 0,        -- 经验值
	exp_next = 0,   -- 下次升级所需经验
	exp_this = 0,   -- 当前等级起始exp -- not use anymore
	sex = SEX_MALE, -- 性别
	signature = '', -- 个性签名
	st = ST_NULL,   -- 游戏状态
	collection = 0,
	collection_rate = 0,

	-- TODO 
	----------------  check usage below
	last_login = 0,
	hero_id = 0,
	game_level = 1, -- 1 means newbie, 5-high
	all_str = nil;  -- all cards (lcard)
	deck_str = nil; -- deck cards (ldeck)
	slot_str = nil; -- slot cards (lcard - ldeck)
	merge_str = nil; -- piece required in merge (lmerge)

	-- reserve1, reserve2 for future use
	reserve1 = 0,
	reserve2 = 0,

	side = 0,
	room_data = nil,

	guild_data = nil,

	has_guild = function(self)
		if self.gid > 0 and self.gpos >= GUILD_POS_MASTER and 
							self.gpos <= GUILD_POS_MEMBER then
			return true;
		end
		return false;
	end,
};

list_icon_num = {
	-- hero icon
	1, 2, 5, 6, 8, 11, 15, 16,
	-- other icon
	21, 22, 23, 24, 25, 26, 27,
};
-- /////////////////////// VAR END ///////////////////////////

-- /////////////////////// UTIL START ///////////////////////////
util = {};

util.bit = nil;
util.c4b_text = cc.c4b(68, 37, 16, 255);
util.c4b_white = cc.c4b(255, 255, 255, 255);
util.c4b_black = cc.c4b(0, 0, 0, 255);
util.c4b_red = cc.c4b(255, 0, 0, 255);
util.c4b_gold = cc.c4b(255, 228, 21, 255);
util.c4b_crystal = cc.c4b(236, 99, 131, 255);
util.c4b_name = cc.c4b(28, 247, 90, 255);
util.c4b_info = cc.c4b(175, 188, 177, 255);
util.c_white = cc.c3b(255, 255, 255);
util.c_gray = cc.c3b(200, 200, 255);
util.c_black = cc.c3b(0, 0, 0);
util.c_red = cc.c3b(255, 0, 0);
util.c_yellow = cc.c3b(255, 255, 0);
util.c_name = cc.c3b(28, 247, 90);
util.c_gold = cc.c3b(255, 228, 21);
util.c_crystal = cc.c3b(236, 99, 131);
util.f_default = 'Arial';

function util.space_(str)
	local flag = false;
	repeat 
		local spos, epos = string.find(str, ' ');
		if nil == spos or nil == epos then
			flag = true;
			break;
		end
		local str1 = string.sub(str, 1, spos-1);
		local str2 = string.sub(str, epos+1);
		str = str1 .. '_' .. str2;
	until true == flag;
	return str;
end

-- delim e.g " " or "[ ]" or "[%.]" or "[%. ]"
function csplit(str, delim, count)
	--print('DEBUG csplit str, delim: ', str, delim);
	local result = {};
	if nil == str then
		return result;
	end
	count = count or 500; -- max 500 token
	local token;

	repeat 
		local s_pos, e_pos = string.find(str, delim);
		if s_pos==nil or e_pos == nil then
			break;
		end
		-- print('s_pos = ', s_pos, ' e_pos = ', e_pos);
		token = string.sub(str, 1, s_pos-1);
		if string.len(token) > 0 then
			result[ #result + 1] = token;
		end
		str = string.sub(str, e_pos+1); -- missing len means up to full len
		-- print('Result i : ', result[#result], '  str=', str);
		count = count - 1;
	until count <= 0;

	if string.len(str) > 0 then
		result[ #result + 1] = str ;
	end
	
	return result;
end

function util.check_file(filename)
	local file_utils = cc.FileUtils:getInstance();
	local is_exist = file_utils:isFileExist(filename);
	if true == is_exist then
		return true;
	end
	print("check_file : file not exist: ", filename);
	return false;

	--[[
	foldername = '';
	-- 1. check the download folder
	local file_utils = cc.FileUtils:getInstance();
	local write_path = file_utils:getWritablePath();
	local fname = foldername .. filename;
	local fullpath = write_path .. 'res/' .. fname;
	local is_exist = file_utils:isFileExist(fullpath);
	if true ~= is_exist then
		fullpath = write_path .. 'res/' .. filename;
		is_exist = file_utils:isFileExist(fullpath);
	end
	if true == is_exist then
		return true;
	end
	local application = cc.Application:getInstance();
	local platform = application:getTargetPlatform();
	if platform == cc.PLATFORM_OS_ANDROID then
		fullpath = fname;
		is_exist = file_utils:isFileExist(fullpath);
		if false == is_exist and foldername == F_IMAGE then
			fullpath = F_LANG .. filename;
			is_exist = file_utils:isFileExist(fullpath);
		end
	else
		fullpath = file_utils:fullPathForFilename(fname);
		is_exist = file_utils:isFileExist(fullpath);
		if false == is_exist and foldername == F_IMAGE then
			fname = F_LANG .. filename;
			fullpath = file_utils:fullPathForFilename(fname);
			is_exist = file_utils:isFileExist(fullpath);
		end
	end
	if true == is_exist then
		return true;
	end
	print("check file : file not exist: ", fullpath);
	return false;
	]]--
end

function util.get_fullpath(foldername, filename, default)
	foldername = '';
	-- 1. check the download folder
	local file_utils = cc.FileUtils:getInstance();
	--[[
	local is_has = file_utils:isFileExist(filename);
	if true == is_has then
		return filename;
	end
	]]--
	local write_path = file_utils:getWritablePath();
	local fname = foldername .. filename;
	local fullpath = write_path .. 'res/' .. fname;
	local is_exist = file_utils:isFileExist(fullpath);
	if true ~= is_exist then
		fullpath = write_path .. 'res/' .. filename;
		is_exist = file_utils:isFileExist(fullpath);
	end
	--print('fullpath, is_exist: ', fullpath, is_exist);
	if true == is_exist then
		return fullpath, true;
	end
	-- 2. check local folder
	--local unknown = 'image/unknown.png';
	local unknown = 'unknown.png';
	if nil ~= default then
		unknown = foldername .. default;
	end
	local application = cc.Application:getInstance();
	local platform = application:getTargetPlatform();
	if platform == cc.PLATFORM_OS_ANDROID then
		fullpath = fname;
		is_exist = file_utils:isFileExist(fullpath);
		if false == is_exist and foldername == F_IMAGE then
			fullpath = F_LANG .. filename;
			is_exist = file_utils:isFileExist(fullpath);
		end
		if false == is_exist then
			fullpath = unknown;
		end
	else
		fullpath = file_utils:fullPathForFilename(fname);
		is_exist = file_utils:isFileExist(fullpath);
		if false == is_exist and foldername == F_IMAGE then
			fname = F_LANG .. filename;
			fullpath = file_utils:fullPathForFilename(fname);
			is_exist = file_utils:isFileExist(fullpath);
		end
		if false == is_exist then
			fullpath = file_utils:fullPathForFilename(unknown);
		end
	end
	--print('fullpath: ', fullpath);
	if false == is_exist then
		print("file not exist: ", foldername, filename);
	end
	return fullpath, is_exist;
end

function util.get_path(filename, default)
	-- 1. check the download folder
	local file_utils = cc.FileUtils:getInstance();
	if true == util.check_file(filename) then
		return filename, true;
	end
	-- 2. check local folder
	--local unknown = 'image/unknown.png';
	local unknown = default or 'unknown.png';
	if nil ~= default then
		unknown = default;
	end
	local is_exist = file_utils:isFileExist(unknown);
	--print('fullpath: ', fullpath);
	if false == is_exist then
		print("get_path : file not exist: ", filename);
	end
	return unknown, is_exist;
end

function open_file(foldername, filename)
	local str = nil;
	local flag = util.check_file(filename);
	if false == flag then
		print('ERROR open file fail : ', foldername, filename);
		return str;
	end
	local fullpath = util.get_fullpath(foldername, filename);
	local file_utils = cc.FileUtils:getInstance();
	str = file_utils:getStringFromFile(fullpath);
	--[[
	local application = cc.Application:getInstance();
	local platform = application:getTargetPlatform();
	if platform == cc.PLATFORM_OS_ANDROID then
		-- deprecated
		--local cstring = CCString:createWithContentsOfFile(fullpath);
		--str = cstring:getCString();
	else
		local file = io.open(fullpath);
		if nil == file then
			print('BUG open file ios file not exists: ', fullpath);
			return str;
		end
		str = file:read("*all");
		io.close(file);
	end
	]]--
	return str;
end

-- should fisrt check download resoure, then check local resource.
-- if only use require, it will always check local resource first.
-- if only use dofile, android cannot load local lua file, because it must
--    unzip the apk first.
function util.include_lua(foldername, filename)
	-- 1. check the download folder
	local file_utils = cc.FileUtils:getInstance();
	local write_path = file_utils:getWritablePath();
	--[[
	local fname = foldername .. filename .. '.lua';
	local fullpath = write_path.. 'res/' .. fname;
	local is_exist = file_utils:isFileExist(fullpath);
	if true == is_exist then
		print('dofile ====>>> ', fullpath);
		dofile ( fullpath );
		return;
	end
	]]--
	-- do not need check , if file not exist , let it crash
	fullpath = foldername .. filename;
	print('require ====>>> ', fullpath);
	require (fullpath);
	return;
end

function util.get_language()
	local application = cc.Application:getInstance();
	local language = application:getCurrentLanguage();
	local l_str;
	if cc.LANGUAGE_ENGLISH == language then
		l_str = 'English';
	else
		language = cc.LANGUAGE_CHINESE;
		l_str = 'chinese';
	end
	print('DEBUG util system language,type: ', l_str, language);
	return language, l_str;
end

function util.save_rms(key, value, data_type) -- {
	local user = cc.UserDefault:getInstance();
	if 'bool' == data_type then
		-- nil == false
		--value = value or false;
		user:setBoolForKey(key, value);
	elseif 'double' == data_type then
		value = value or 0;
		user:setDoubleForKey(key, value);
	elseif 'float' == data_type then
		value = value or 0;
		user:setFloatForKey(key, value);
	elseif 'integer' == data_type then
		value = value or 0;
		user:setIntegerForKey(key, value);
	--elseif 'string' == data_type then
	else
		value = value or '???';
		user:setStringForKey(key, value);
	end
	local flag = user:flush();
	if false == flag then
		print('DEBUG util save rms false key:', key);
	end
end -- util.save_rms }

function util.load_rms(key, data_type) -- {
	local user = cc.UserDefault:getInstance();
	local value;
	if 'bool' == data_type then
		value = user:getBoolForKey(key);
	elseif 'double' == data_type then
		value = user:getDoubleForKey(key);
	elseif 'float' == data_type then
		value = user:getFloatForKey(key);
	elseif 'integer' == data_type then
		value = user:getIntegerForKey(key);
	--elseif 'string' == data_type then
	else
		value = user:getStringForKey(key);
	end
	return value;
end -- util.load_rms }

function util.remove_rms(key) -- {
	local user = cc.UserDefault:getInstance();
	user:setStringForKey(key, nil);
	local flag = user:flush();
	if false == flag then
		print('DEBUG util remove rms false key:', key);
	end
end -- util.load_rms }

function util.load_volume()
	local audio = cc.SimpleAudioEngine:getInstance();
	local music_volume = util.load_rms('music_volume', 'string');
	music_volume = tonumber(music_volume);
	if nil ~= music_volume then
		util.set_music_volume(music_volume);
	end
	local effect_volume = util.load_rms('effect_volume', 'string');
	effect_volume = tonumber(effect_volume);
	if nil ~= effect_volume then
		util.set_effect_volume(effect_volume);
	end
end

function util.preload_music(fullpath)
	local audio = cc.SimpleAudioEngine:getInstance();
	audio:preloadMusic(fullpath);
end

function util.play_music(fullpath)
	local audio = cc.SimpleAudioEngine:getInstance();
	audio:playMusic(fullpath, true);
    util.load_volume();
end

function util.set_music_volume(value)
	local audio = cc.SimpleAudioEngine:getInstance();
	audio:setMusicVolume(value);
end

function util.stop_bgmusic()
	local audio = cc.SimpleAudioEngine:getInstance();
	audio:stopMusic();
end

function util.resume_bgmusic()
	local audio = cc.SimpleAudioEngine:getInstance();
	audio:resumeMusic();
end

function util.preload_effect(fullpath)
	local audio = cc.SimpleAudioEngine:getInstance();
	audio:preloadEffect(fullpath);
end

function util.play_effect(fullpath)
	local audio = cc.SimpleAudioEngine:getInstance();
	audio:playEffect(fullpath, false);
end

function util.set_effect_volume(value)
	local audio = cc.SimpleAudioEngine:getInstance();
	audio:setEffectsVolume(value);
end

function util.stop_effect(sound_id)
	local audio = cc.SimpleAudioEngine:getInstance();
	audio:stopEffect(sound_id);
end

function util.free_ram()
	local cache = cc.Director:getInstance():getTextureCache();
	cache:removeUnusedTextures();
	cache = cc.SpriteFrameCache:getInstance();
	cache:removeUnusedSpriteFrames();
end

function util.set_scheduler(callback, time_interval, is_paused)
	kdebug("-- TODO util.set_scheduler");
	--[[
	if nil == callback then
		return;
	end
	local scheduler = CCDirector:sharedDirector():getScheduler();
	local ret = scheduler:scheduleScriptFunc(callback, time_interval, is_paused);
	return ret;
	]]--
end

function util.remove_scheduler(scheduler_id)
	kdebug("-- TODO util.remove_scheduler");
	--[[
	local scheduler = CCDirector:sharedDirector():getScheduler();
	scheduler:unscheduleScriptEntry(scheduler_id);
	]]--
end

function util.load_server()
	-- server_list see in version.lua
	local list = {};
	for i = 1, #(server_list or {}) do
		local info = server_list[i];
		local flag = tonumber(info.flag);
		if flag > 0 or true == DEBUG_MODE then
			table.insert(list, info);
		end
	end
	return list;
end

function util.get_server_name(list, ip)
	list = list or {};
	for i = 1, #list do
		local info = list[i];
		local ipaddr = info.ip;
		--print('ipaddr, ip: ', ipaddr, ip);
		if ipaddr == ip then
			local name = info.name;
			local state = info.state;
			local str = string.format("%s [ %s ]", name, state);
			return str;
		end
	end
	return t_lang("UNKNOW_SERVER");
end

function util.get_server_id(list, ip)
	list = list or {};
	for i = 1, #list do
		local info = list[i];
		local ipaddr = info.ip;
		if ipaddr == ip then
			return info.sid;
		end
	end
	return '0';
end

-- register a onTouch callback handler for a layer
-- u may use callback=nil if there is no handler
-- touch
-- event: "began", "moved", "ended", "cancelled"
function util.layer_register(layer, priority, callback, multi, swallow)
	if callback == nil then
		-- no need to register script handler and no need to set enable true
		return;
	end
	local listener = cc.EventListenerTouchOneByOne:create();
	listener:setSwallowTouches(swallow);
	listener:registerScriptHandler(
		function(touch, event)
			local location = touch:getLocation();
			return callback('began', location.x, location.y);
		end, 
		cc.Handler.EVENT_TOUCH_BEGAN
	);
	listener:registerScriptHandler(
		function(touch, event)
			local location = touch:getLocation();
			return callback('moved', location.x, location.y);
		end, 
		cc.Handler.EVENT_TOUCH_MOVED
	);
	listener:registerScriptHandler(
		function(touch, event)
			local location = touch:getLocation();
			return callback('ended', location.x, location.y);
		end, 
		cc.Handler.EVENT_TOUCH_ENDED
	);
	--listener:registerScriptHandler(callback, cc.Handler.EVENT_TOUCH_BEGAN);
	--listener:registerScriptHandler(callback, cc.Handler.EVENT_TOUCH_MOVED);
	--listener:registerScriptHandler(callback, cc.Handler.EVENT_TOUCH_ENDED);
	local eventDispatcher = layer:getEventDispatcher();
	eventDispatcher:addEventListenerWithSceneGraphPriority(listener, layer);
	--layer:setTouchMode(cc.TOUCHES_ALL_AT_ONCE);
	--layer:setTouchMode(cc.TOUCHES_ONE_BY_ONE);
end

-- @see in LuaEngine handleNodeEvent
--kCCNodeOnEnter: "enter"
--kCCNodeOnExit:  "exit";
--kCCNodeOnEnterTransitionDidFinish: "enterTransitionFinish"
--kCCNodeOnExitTransitionDidStart:   "exitTransitionStart"
--kCCNodeOnCleanup:                  "cleanup"
function util.node_register(node, handler)
	if nil == node or nil == handler then
		return;
	end
	node:registerScriptHandler(handler);
end

-- event: "backClicked", "menuClicked"
function util.keypad_register(layer, handler)
	if nil == layer or nil == handler then
		return;
	end
	layer:setKeypadEnabled(true);
	layer:registerScriptKeypadHandler(handler);
end

-- include three function
--function util.layer_register(layer, priority, callback, multi, swallow)
--function util.node_register(node, handler)
--registerScriptKeypadHandler
-- all of them will unregister in destructor, no need to call them manually
function util.reg_handler(layer, priority, handler, swallow, multi, no_keypad)
	multi = multi or false;
	util.layer_register(layer, priority, handler, multi, swallow)
	util.node_register(layer, handler);
	if true == no_keypad then return; end
	util.keypad_register(layer, handler)
end

function util.check_sprite_frame(filename)
	if nil == filename then
		return false;
	end
	local cache = cc.SpriteFrameCache:getInstance();
	local frame = cache:getSpriteFrame(filename);
	if nil ~= frame then
		return true;
	end
	return false;
end

function util.create_sprite_frame(filename)
	if false == util.check_sprite_frame(filename) then
		return nil;
	end
	local sprite = cc.Sprite:createWithSpriteFrameName(filename);
	return sprite;
end

function util.add_sprite_frame(layer, filename, pos, anchorpoint, zorder)
	anchorpoint = anchorpoint or ANCHOR_CENTER_CENTER;
	local cache = cc.SpriteFrameCache:getInstance();
	local sprite_frame = cache:spriteFrameByName(filename);
	if nil == sprite_frame then
		return nil;
	end
	local sprite = cc.Sprite:createWithSpriteFrame(sprite_frame);
	sprite:setAnchorPoint(anchorpoint);
	sprite:setPosition(pos);
	if nil ~= zorder then
		layer:addChild(sprite, zorder);
	else
		layer:addChild(sprite);
	end
	return sprite;
end

function util.add_frames(path)
	local cache = cc.SpriteFrameCache:getInstance();
	cache:addSpriteFrames(path);
end

function util.create_sprite(filename)
	local cache = cc.Director:getInstance():getTextureCache();
	local texture = cache:addImage(filename);
	local sprite = cc.Sprite:createWithTexture(texture);
	return sprite;
end

function util.add_sprite(layer, filename, pos, anchorpoint, zorder)
	anchorpoint = anchorpoint or ANCHOR_CENTER_CENTER;
	local sprite = util.create_sprite(filename);
	sprite:setAnchorPoint(anchorpoint);
	if nil ~= pos then
		sprite:setPosition(pos);
	end
	if nil ~= zorder then
		layer:addChild(sprite, zorder);
	else
		layer:addChild(sprite);
	end
	return sprite;
end

function util.add_mask_sprite(layer, fname1, fname2, pos, anchorpoint, zorder)
	local src = util.create_sprite(fname1);
	local mask = util.create_sprite(fname2);
	
	local sprite = util.add_mask_sprite_2(layer,src,mask,pos,anchorpoint,zorder);
	return sprite;
end

function util.add_mask_sprite_2(layer, src, mask, pos, anchorpoint, zorder)
	local src_size = src:getContentSize();
	local mask_size = mask:getContentSize();

	local rt = cc.RenderTexture:create(src_size.width, src_size.height, cc.TEXTURE2_D_PIXEL_FORMAT_RGB_A8888);

	local ratiow = src_size.width / mask_size.width;
	local ratioh = src_size.height / mask_size.height;
	mask:setScaleX(ratiow);
	mask:setScaleY(ratioh);
	mask:setPosition(cc.p(src_size.width / 2, src_size.height / 2));
	src:setPosition(cc.p(src_size.width / 2, src_size.height / 2));

	mask:setBlendFunc(gl.ONE, gl.ZERO);
	src:setBlendFunc(gl.DST_ALPHA, gl.ZERO);

	rt:begin();
	mask:visit();
	src:visit();
	rt:endToLua();

	local sprite = cc.Sprite:createWithTexture(rt:getSprite():getTexture());
	sprite:setFlipY(true);

	sprite:setAnchorPoint(anchorpoint or ANCHOR_CENTER_CENTER);
	if nil ~= pos then
		sprite:setPosition(pos);
	end
	if nil ~= zorder then
		layer:addChild(sprite, zorder);
	else
		layer:addChild(sprite);
	end
	return sprite;
end

function util.create_scale9sprite(filename, fullrect, insetrect, realsize)
	local sprite = cc.Scale9Sprite:create(filename, fullrect, insetrect);
	sprite:setContentSize(realsize);
	return sprite;
end

function util.create_scale9frame(filename, fullrect, insetrect, realsize)
	local sprite = cc.Scale9Sprite:create(filename, fullrect, insetrect);
	sprite:setContentSize(realsize);
	return sprite;
end

function util.add_scale9sprite(layer, filename, pos, anchorpoint, fullrect, insetrect, realsize, zorder)
	anchorpoint = anchorpoint or ANCHOR_CENTER_CENTER;
	local sprite = util.create_scale9sprite(filename,fullrect,insetrect,realsize);
	sprite:setAnchorPoint(anchorpoint);
	if nil ~= pos then
		sprite:setPosition(pos);
	end
	if nil ~= zorder then
		layer:addChild(sprite, zorder);
	else
		layer:addChild(sprite);
	end
	return sprite;
end

function util.add_particle(layer, fullpath, pos, zorder)
	local emitter, batch;
	emitter = cc.ParticleSystemQuad:create(fullpath);
	emitter:setAutoRemoveOnFinish(true);
	batch = cc.ParticleBatchNode:createWithTexture(emitter:getTexture());
	batch:setPosition(pos.x, pos.y);
	batch:addChild(emitter);
	if nil ~= zorder then
		layer:addChild(batch, zorder);
	else
		layer:addChild(batch);
	end

	local info = { emitter = emitter, batch = batch };
	return info;
end

function util.add_editbox(layer, fullpath, fullrect, insetrect, realsize, anchorpoint, pos, font, f_size, f_color, input_mode, return_type, input_flag, handler, max_length, place_holder, place_holder_color, zorder)
	local sprite = util.create_scale9sprite(fullpath,fullrect,insetrect,realsize);
	local editbox = cc.EditBox:create(realsize, sprite);
	editbox:setAnchorPoint(anchorpoint);
	editbox:setPosition(pos);
	editbox:setFontName(font);
	if nil ~= f_size then
		editbox:setFontSize(f_size);
	end
	if nil ~= input_flag then
		editbox:setInputFlag(input_flag);
	end
	editbox:setFontColor(f_color);
	editbox:setPlaceHolder(place_holder or '');
	editbox:setPlaceholderFontColor(place_holder_color or util.c_white);
	editbox:setMaxLength(max_length);
	editbox:setInputMode(input_mode);
	editbox:setReturnType(return_type);
	editbox:registerScriptEditBoxHandler(handler);
	if nil ~= layer.getTouchPriority then
		local priority = layer:getTouchPriority();
		editbox:setTouchPriority(priority - 2);
	end
	layer:addChild(editbox, (zorder or -1));

	return editbox;
end -- util.add_editbox }

function util.add_editbox_blank(layer, realsize, anchorpoint, pos, font, f_size, f_color, input_mode, return_type, input_flag, handler, max_length, place_holder, place_holder_color, zorder)
	local fullrect = cc.rect(0, 0, 64, 64);
	local insetrect = cc.rect(2, 2, 60, 60);
	local path = util.get_path('blank.png');

	return util.add_editbox(layer, path, fullrect, insetrect, realsize, anchorpoint, pos, font, f_size, f_color, input_mode, return_type, input_flag, handler, max_length, place_holder, place_holder_color, zorder)
end -- util.add_editbox_blank }

function util.create_item_sprite(unselect_s, select_s, pos, anchorpoint, callback) 
	anchorpoint = anchorpoint or ANCHOR_LEFT_DOWN;
	local item = cc.MenuItemSprite:create(unselect_s, select_s);
	item:setAnchorPoint(anchorpoint);
	item:setPosition(pos);
	if nil ~= callback then
		item:registerScriptTapHandler(callback);
	end
	return item;
end

function util.create_item_label(label, pos, anchorpoint, callback) 
	anchorpoint = anchorpoint or ANCHOR_LEFT_DOWN;
	local item = cc.MenuItemLabel:create(label);
	item:setAnchorPoint(anchorpoint);
	item:setPosition(pos);
	if nil ~= callback then
		item:registerScriptTapHandler(callback);
	end
	return item;
end

function util.change_item_image(item, path1, path2)
	local sprite, tc, texture;
	tc = cc.Director:getInstance():getTextureCache();
	sprite = item:getNormalImage();
	texture = tc:addImage(path1);
	if nil ~= texture then 
		sprite:setTexture(texture);
	end
	sprite = item:getSelectedImage();
	texture = tc:addImage(path2);
	if nil ~= texture then 
		sprite:setTexture(texture);
	end
end

function util.add_item_label_image(item, path1, path2)
	local unselectsprite = item:getNormalImage();
	local selectsprite = item:getSelectedImage();
	local s1, s2;

	local size = unselectsprite:getContentSize();
	local scale = unselectsprite:getScale();
	local pos = cc.p(scale * size.width / 2, scale * size.height / 2);
	s1 = util.add_sprite(unselectsprite, path1, pos, ANCHOR_CENTER_CENTER, 1);

	size = selectsprite:getContentSize();
	scale = selectsprite:getScale();
	pos = cc.p(scale * size.width / 2, scale * size.height / 2);
	s2 = util.add_sprite(selectsprite, path2, pos, ANCHOR_CENTER_CENTER, 1);
	return s1, s2;
end

function util.create_item_image(fname1, fname2, pos, anchorpoint, callback)
	local unselectsprite = util.create_sprite(fname1);
	local selectsprite = util.create_sprite(fname2 or fname1);
	if fname1 == fname2 then
		selectsprite:setScale(1.1);
	end

	return util.create_item_sprite(unselectsprite, selectsprite, pos, anchorpoint, callback);
end

function util.create_item_image_frame(fname1, fname2, pos, anchorpoint, callback)
	local unselectsprite = util.create_sprite_frame(fname1);
	local selectsprite = util.create_sprite_frame(fname2 or fname1);
	if fname1 == fname2 then
		selectsprite:setScale(1.1);
	end

	return util.create_item_sprite(unselectsprite, selectsprite, pos, anchorpoint, callback);
end

function util.create_toggle_sprite(unselect_s, select_s, pos, anchorpoint,callback)
	local toggle;
	local item1, item2;

	item1 = CCMenuItemSprite:create(unselect_s, unselect_s);
	toggle = CCMenuItemToggle:create(item1);

	item2 = CCMenuItemSprite:create(select_s, select_s);
	toggle:addSubItem(item2);

	anchorpoint = anchorpoint or ANCHOR_LEFT_DOWN;
	toggle:setAnchorPoint(anchorpoint);
	toggle:setPosition(pos);
	if nil ~= callback then
		toggle:registerScriptTapHandler(callback);
	end
	return toggle;
end

function util.create_toggle_image(fname1, fname2, pos, anchorpoint, callback)
	local unselectsprite = util.create_sprite(fname1);
	local selectsprite = util.create_sprite(fname2);
	--selectsprite:setScale(1.1);

	return util.create_toggle_sprite(unselectsprite, selectsprite, pos, anchorpoint, callback);
end

function util.add_menu(layer, list_item, zorder, priority) -- {
	list_item = list_item or {};
	if 0 == #list_item then
		return;
	end
	zorder = zorder or ZORDER_MENU;

	local menu = cc.Menu:create();
	for i = 1, #list_item do
		local item = list_item[i];
		menu:addChild(item);
	end
	menu:setAnchorPoint(ANCHOR_LEFT_DOWN);
	menu:setPosition(0, 0);

	layer:addChild(menu, zorder); -- hard code, always on top of layer
	if nil == priority and nil ~= layer.getTouchPriority then
		priority = layer:getTouchPriority();
	end
	if nil ~= priority then
		-- always before the layer (touchable)
		menu:setTouchPriority(priority - 2);
	end

	return menu; -- return btn is for reference only, do not use
end -- util.add_menu_multi }

-- cc.TEXT_ALIGNMENT_LEFT
-- cc.TEXT_ALIGNMENT_CENTER
-- cc.TEXT_ALIGNMENT_RIGHT
-- cc.VERTICAL_TEXT_ALIGNMENT_TOP
-- cc.VERTICAL_TEXT_ALIGNMENT_CENTER
-- cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM
function util.add_labelsys(layer, text, font, size, pos, color, anchorpoint, zorder, dimensions, halignment, valignment)
	local label;
	if nil == dimensions then
		label = cc.Label:createWithSystemFont(text, font, size);
	else
		label = cc.Label:createWithSystemFont(text, font, size, dimensions, halignment, valignment);
	end
	label:setAnchorPoint(anchorpoint);
	label:setPosition(pos);
	label:setColor(color);

	if nil ~= zorder then
		layer:addChild(label, zorder);
	else
		layer:addChild(label);
	end

	return label;
end

function util.add_labelconfig(layer, text, font, size, pos, color, anchorpoint, zorder, dimensions, halignment, valignment)
	font = font or util.get_path("zpixel2_ex.ttf");

	-- distanceFieldEnabled should be true if to use glow
	-- if outlineSize > 0 then distanceFieldEnabled will be false
	local ttfConfig = { 
		fontFilePath = font, 
		fontSize = size,
		glyphs = cc.GLYPHCOLLECTION_DYNAMIC,
		customGlyphs = nil,
		distanceFieldEnabled = false,
		outlineSize = 0,
	};
	local label = cc.Label:create();
	label:setTTFConfig(ttfConfig);
	label:setString(text);
	label:setAnchorPoint(anchorpoint);
	label:setPosition(pos);
	label:setTextColor(color);
	if nil ~= dimensions then
		label:setDimensions(dimensions.width, dimensions.height);
	end
	if nil ~= halignment and nil ~= valignment then
		label:setAlignment(halignment, valignment);
	end
	-- e.g --> outline
	-- local outline_color = cc.c4b(0, 0, 255, 255)
	-- local outline_size = 1;
	-- label:enableOutline(outline_color, outline_size);
	-- e.g --> glow
	-- label:enableGlow(cc.c4b(255, 255, 0, 255));

	if nil ~= zorder then
		layer:addChild(label, zorder);
	else
		layer:addChild(label);
	end

	return label;
end

function util.add_labeloutline(layer, text, font, size, pos, color, outline_color, outline_size, anchorpoint, zorder, dimensions, halignment, valignment)
	local label = util.add_labelconfig(layer, text, font, size, pos, color, anchorpoint, zorder, dimensions, halignment, valignment);
	label:enableOutline(outline_color, outline_size);
	return label;
end

function util.add_labelglow(layer, text, font, size, pos, color, glow_color, anchorpoint, zorder, dimensions, halignment, valignment)
	local label = util.add_labelconfig(layer, text, font, size, pos, color, anchorpoint, zorder, dimensions, halignment, valignment);
	label:enableGlow(glow_color);
	return label;
end

function util.add_labelshadow(layer, text, font, size, pos, color, shadow_color, anchorpoint, zorder, dimensions, halignment, valignment)
	local label = util.add_labelconfig(layer, text, font, size, pos, color, anchorpoint, zorder, dimensions, halignment, valignment);
	label:enableShadow(shadow_color);
	return label;
end

function util.add_labeloutline(layer, text, font, size, pos, color, outline_color, outline_size, anchorpoint, zorder, dimensions, halignment, valignment)
	local label = util.add_labelconfig(layer, text, font, size, pos, color, anchorpoint, zorder, dimensions, halignment, valignment);
	label:enableOutline(outline_color, outline_size);
	return label;
end

function util.add_labelttf(layer, text, font, size, pos, color, anchorpoint, zorder, dimensions, halignment, valignment)
	--print('text: ', text);
	--return util.add_labelsys(layer, text, 'Helvetica', size, pos, color, anchorpoint, zorder, dimensions, halignment, valignment);
	font = font or util.get_path("zpixel2_ex.ttf");
	local label;
	if nil == dimensions then
		label = cc.Label:createWithTTF(text, font, size);
	else
		label = cc.Label:createWithTTF(text, font, size, dimensions, halignment, valignment);
	end
	label:setAnchorPoint(anchorpoint);
	label:setPosition(pos);
	--label:setColor(color); -- c3b
	--label:setTextColor(cc.c4b(color.r, color.g, color.b, 255));
	label:setTextColor(color); -- c4b

	if nil ~= zorder then
		layer:addChild(label, zorder);
	else
		layer:addChild(label);
	end

	return label;
end

function util.add_labelbmf(layer, text, font_path, pos, anchorpoint, zorder, halignment, max_line_width, image_offset)
	halignment = halignment or cc.TEXT_ALIGNMENT_LEFT;
	max_line_width = max_line_width or 0;
	image_offset = image_offset or cc.p(0, 0);
	local label = cc.Label:createWithBMFont(font_path, text, halignment, max_line_width, image_offset);
	label:setAnchorPoint(anchorpoint);
	label:setPosition(pos);

	if nil ~= zorder then
		layer:addChild(label, zorder);
	else
		layer:addChild(label);
	end

	return label;
end

function util.add_label(layer, text, size, pos, color, anchorpoint, zorder, dimensions, halignment, valignment)
	local label;
	label = util.add_labelsys(layer, text, "Arial", size, pos, color, anchorpoint, zorder, dimensions, halignment, valignment);
	return label;
end

function util.add_text_to_sprite(parent, text, size, color, pos, anchorpoint,scale)
	local label = parent:getChildByTag(TAG_SPRITE_LABEL);
	if nil ~= label then
		label:removeFromParentAndCleanup(true);
		label = nil;
	end
	local psize = parent:getContentSize();
	local pscale = parent:getScale();
	local width = psize.width * pscale;
	local height = psize.height * pscale;
	pos = pos or ccp(width / 2, height / 2);
	anchorpoint = anchorpoint or ANCHOR_CENTER_CENTER;
	local label = util.add_label(parent, text, size, pos, color, anchorpoint, 1, cc.size(width, height), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
	label:setTag(TAG_SPRITE_LABEL);
	return label;
end

function util.add_text_outline_to_sprite(parent, text, size, color, outline_color, outline_size, pos, anchorpoint, scale)
	local label = parent:getChildByTag(TAG_SPRITE_LABEL);
	if nil ~= label then
		label:removeFromParentAndCleanup(true);
		label = nil;
	end
	local psize = parent:getContentSize();
	local sx = parent:getScaleX();
	local sy = parent:getScaleY();
	--local pscale = sx<sy and sx or sy;
	--local width = psize.width * pscale;
	--local height = psize.height * pscale;
	local width = psize.width * sx;
	local height = psize.height * sy;
	pos = pos or ccp(width / 2, height / 2);
	anchorpoint = anchorpoint or ANCHOR_CENTER_CENTER;
	local label = util.add_labeloutline(parent, text, nil, size, pos, color, outline_color, outline_size, anchorpoint, 1, cc.size(width, height), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
	label:setTag(TAG_SPRITE_LABEL);
	return label;
end

--[[
	tableview_handler = function(...)  -- { start
		local self = layer_xxx;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }
]]--
-- direction
-- cc.SCROLLVIEW_DIRECTION_NONE
-- cc.SCROLLVIEW_DIRECTION_HORIZONTAL
-- cc.SCROLLVIEW_DIRECTION_VERTICAL
-- cc.SCROLLVIEW_DIRECTION_BOTH
-- fillorder
-- cc.TABLEVIEW_FILL_TOPDOWN
-- cc.TABLEVIEW_FILL_BOTTOMUP
function util.add_tableview(layer, size, direction, handler, pos, fillorder, zorder)
	local tableview = cc.TableView:create(size);
	tableview:setDirection(direction);
	tableview:setPosition(pos);
	tableview:setVerticalFillOrder(fillorder);
	tableview:setDelegate();
	tableview:registerScriptHandler(
		function(view)
			return handler("numberOfCellsInTableView", view);
			--TableViewTestLayer.numberOfCellsInTableView
			-- return num;
		end,
		cc.NUMBER_OF_CELLS_IN_TABLEVIEW
	);  
	tableview:registerScriptHandler(
		function(view)
			return handler("scrollViewDidScroll", view);
			--TableViewTestLayer.scrollViewDidScroll
		end,
		cc.SCROLLVIEW_SCRIPT_SCROLL
	);
	tableview:registerScriptHandler(
		function(view)
			return handler("scrollViewDidZoom", view);
			--TableViewTestLayer.scrollViewDidZoom
		end,
		cc.SCROLLVIEW_SCRIPT_ZOOM
	);
	tableview:registerScriptHandler(
		function(view, cell)
			return handler("tableCellTouched", view, cell);
			--TableViewTestLayer.tableCellTouched
		end,
		cc.TABLECELL_TOUCHED
	);
	tableview:registerScriptHandler(
		function(view, idx)
			return handler("cellSizeForTable", view, idx);
			--TableViewTestLayer.cellSizeForTable
			-- return len
		end,
		cc.TABLECELL_SIZE_FOR_INDEX
	);
	tableview:registerScriptHandler(
		function(view, idx)
			return handler("tableCellAtIndex", view, idx);
			--TableViewTestLayer.tableCellAtIndex
		end,
		cc.TABLECELL_SIZE_AT_INDEX
	);
	tableview:registerScriptHandler(
		function(view, cell)
			return handler("tableCellHighlight", view, cell);
		end,
		cc.TABLECELL_HIGH_LIGHT
	);
	tableview:registerScriptHandler(
		function(view, cell)
			return handler("tableCellUnhighlight", view, cell);
		end,
		cc.TABLECELL_UNHIGH_LIGHT
	);
	if nil == zorder then
		layer:addChild(tableview);
	else
		layer:addChild(tableview, zorder);
	end
	tableview:reloadData();
	return tableview;
end

function util.add_tableview_scrollbar(layer, pos, size, anchorpoint, zorder)
	local fullpath = util.get_fullpath(F_IMAGE, 'scroll_bar.png');
	local fullrect = cc.rect(0, 0, 32, 64);
	local insetrect = cc.rect(15, 27, 2, 10);
	local realsize = cc.size(32, size.height);
	local bar = util.add_scale9sprite(layer, fullpath, pos, anchorpoint, fullrect, insetrect, realsize, zorder); 

	fullpath = util.get_fullpath(F_IMAGE, 'scroll_bar_tap.png');
	pos = ccp(bar:getContentSize().width/2, 0);
	local tap = util.add_sprite(bar, fullpath, pos, ANCHOR_CENTER_CENTER, 50);

	bar:setVisible(false);
	return bar, tap;
end

function util.handle_tableview_scrollbar(tableview, bar, tap)
	local theight = tableview:getContentSize().height;
	local offset = tableview:getContentOffset();
	local bheight = bar:getContentSize().height;
	if theight < bheight then
		if true == bar:isVisible() then bar:setVisible(false); end
		return;
	else
		if false == bar:isVisible() then bar:setVisible(true); end
	end
	local ff = (-offset.y) / (theight - bheight);
	if ff < 0 then
		ff = 0;
	end
	if ff > 1 then
		ff = 1;
	end
	local newy = ff * bheight;
	tap:setPositionY(newy);
	bar:stopAllActions();
	local array = {};
	table.insert(array, cc.DelayTime:create(1));
	table.insert(array, cc.Hide:create());
	bar:runAction(cc.Sequence:create(array));
end

function util.add_arrows(parent, tpos, tsize, cwidth, list_len, offset)
	local left_arrow, right_arrow;
	local function btn_action(btn)
		local c = btn:getColor();
		local array = {};
		local action = cc.TintTo:create(0.5, 150, 150, 40);
		table.insert(array, action);
		action = cc.TintTo:create(0.5, c.r, c.g, c.b);
		table.insert(array, action);
		action = cc.Sequence:create(array);
		action = cc.RepeatForever:create(action);
		btn:runAction(action);
	end

	local items = {};
	local item, path, pos;
	--fullpath = util.get_fullpath(F_IMAGE, 'l_arrow_1.png');
	path = util.get_path('btn_3.png');
	pos = cc.p(tpos.x, tpos.y); -- image size: 24x26
	item = util.create_item_image(path, path, pos, ANCHOR_LEFT_DOWN, nil);
	pos.y = pos.y + tsize.height/2;
	item:setPosition(pos);
	item:setAnchorPoint(ANCHOR_RIGHT_CENTER);
	left_arrow = item;
	table.insert(items, item);

	--fullpath = util.get_fullpath(F_IMAGE, 'r_arrow_1.png');
	path = util.get_path('btn_4.png');
	pos = cc.p(tpos.x+tsize.width, tpos.y); -- image size: 24x26
	item = util.create_item_image(path, path, pos, ANCHOR_LEFT_DOWN, nil);
	pos.y = pos.y + tsize.height/2;
	item:setPosition(pos);
	item:setAnchorPoint(ANCHOR_LEFT_CENTER);
	right_arrow = item;
	table.insert(items, item);

	util.add_menu(parent, items, 60);

	btn_action(left_arrow);
	btn_action(right_arrow);
	
	util.handle_arrows(left_arrow, right_arrow, list_len, cwidth, tsize.width, offset or cc.p(0, 0));

	return left_arrow, right_arrow;
end

function util.handle_arrows(clarrow, crarrow, list_len, cell_width, tableview_width, offset)
	if nil == clarrow or nil == crarrow then
		return;
	end
	if 0 == list_len then
		clarrow:setVisible(false);
		crarrow:setVisible(false);
		return;
	end
	local offsetx = math.floor(offset.x);
	local offsety = math.floor(offset.y);
	local offsetend = math.floor(cell_width * list_len - tableview_width);
	if 0 <= offsetx then
		if true == clarrow:isVisible() then
			clarrow:setVisible(false);
		end
		if 0 == offsetend then
			crarrow:setVisible(false);
		elseif false == crarrow:isVisible() then
			crarrow:setVisible(true);
		end
	elseif -offsetend >= offsetx then
		if false == clarrow:isVisible() then
			clarrow:setVisible(true);
		end
		if true == crarrow:isVisible() then
			crarrow:setVisible(false);
		end
	else
		if false == clarrow:isVisible() then
			clarrow:setVisible(true);
		end
		if false == crarrow:isVisible() then
			crarrow:setVisible(true);
		end
	end
end

function util.add_layer_color(layer, color, zorder)
	zorder = zorder or 0;
	local layer_color = cc.LayerColor:create(color);
	layer_color:setTag(TAG_LAYER_COLOR);
	layer:addChild(layer_color);
end

function util.add_progress_radial(layer, sprite, pos, zorder, range, t_end, reverse)
	local progress = cc.ProgressTimer:create(sprite);
	progress:setPosition(pos);
	progress:setType(cc.PROGRESS_TIMER_TYPE_RADIAL);
	progress:setPercentage(range);
	layer:addChild(progress, zorder);
	
	if nil ~= reverse then
		progress:setReverseProgress(reverse);
	end
	local progress_to = cc.ProgressTo:create(t_end, 100);
	progress:runAction( cc.RepeatForever:create(progress_to) );
end

function util.add_progress_bar(layer, sprite, pos, bar_type, midpoint, rate, percentage, zorder)
	local progress = cc.ProgressTimer:create(sprite);
	progress:setPosition(pos);
	progress:setType(bar_type or cc.PROGRESS_TIMER_TYPE_BAR); -- 水平
	progress:setMidpoint(midpoint or ccp(0, 0));  -- 进度条开始的中间位置
	-- 设置进度条的长度和高度开始变化的大小
	progress:setBarChangeRate(rate or ccp(1, 0)); 
	progress:setPercentage(percentage or 0);
	if nil ~= zorder then
		layer:addChild(progress, zorder);
	else
		layer:addChild(progress);
	end

	return progress;
end

function util.open_url(url)
	local platform = cc.Application:getInstance():getTargetPlatform();
	if platform == cc.PLATFORM_OS_IPHONE or platform == cc.PLATFORM_OS_IPAD then
		g_scene:add_layer(ZORDER_LAYER_FORUM, layer_forum:create());
		local args = { 
			url = url, handler = layer_forum.callback,
		};
		local luaoc = require "luaoc";
		local class_name = "ForumView";
		local ok, ret = luaoc.callStaticMethod(class_name, "openURL", args);
		--[[
		if ok then
		end
		]]--
	elseif platform == cc.PLATFORM_OS_ANDROID then
		g_scene:add_layer(ZORDER_LAYER_FORUM, layer_forum:create());
		local args = { 
			url, layer_forum.callback,
		};
		local sigs = "(Ljava/lang/String;I)V";
		local luaj = require "luaj";
		local class_name = "org/cocos2dx/lua/AppActivity";
		local ok, ret = luaj.callStaticMethod(class_name, "openURL", args, sigs);
		--[[
		if ok then
		end
		]]--
	else
		return;
	end
end

function util.text_to_pasteboard(text)
	local platform = cc.Application:getInstance():getTargetPlatform();
	if platform == cc.PLATFORM_OS_IPHONE or platform == cc.PLATFORM_OS_IPAD then
		local args = { 
			text = text,
		};
		local luaoc = require "luaoc";
		local class_name = "SysTool";
		local ok = luaoc.callStaticMethod(class_name, "textToPasteboard", args);
		--[[
		if ok then
		end
		]]--
	elseif platform == cc.PLATFORM_OS_ANDROID then
		local args = { 
			text,
		};
		local sigs = "(Ljava/lang/String;)V";
		local luaj = require "luaj";
		local class_name = "org/cocos2dx/lua/AppActivity";
		local ok = luaj.callStaticMethod(class_name,"textToPasteboard",args,sigs);
	else
		return;
	end
end

function util.add_slider_image(layer, path1, path2, path3, max, min, pos, anchorpoint, callback, zorder)
	if nil == callback then
		return nil;
	end
	anchorpoint = anchorpoint or ANCHOR_CENTER_CENTER;
	local slider = cc.ControlSlider:create(path1, path2, path3);
	slider:setPosition(pos);
	slider:setAnchorPoint(anchorpoint);
	slider:setMinimumValue(min);
	slider:setMaximumValue(max);
	slider:registerControlEventHandler(callback, cc.CONTROL_EVENTTYPE_VALUE_CHANGED);

	if nil ~= zorder then
		layer:addChild(slider, zorder);
	else
		layer:addChild(slider);
	end
	return slider;
end

function util.show_horselamp(msg, count)
	msg = msg or '???';
	local lamp = layer_horselamp;
	lamp.list = lamp.list or {};
	table.insert(lamp.list, { msg = msg, count = count });
	if nil == lamp.layer then
		g_scene:add_layer(ZORDER_LAYER_HORSELAMP, lamp:create());
	end
end

-- return true: has done, false: not done yet
function util.check_tutor(tutor_step)
	if tutor_step > 100 then
		return false;
	end
	local index = util.bit_lshift(1, tutor_step);
	local mark = util.bit_and(g_tutor, index);
	if mark > 0 then
		return true;
	end
	return false;
end

function util.upload_tutor()
	if true == USE_TIP_TUTOR then
		return;
	end
	if nil == g_tutor_change then
		return;
	end
	local cmd = 'scourse ' .. g_tutor;
	net_send(cmd, true);
end

function util.set_tutor(tutor_step, is_done, is_upload)
	print('tutuor_step: ', tutor_step);
	if tutor_step > 100 then
		return;
	end
	local index = util.bit_lshift(1, tutor_step);
	local mark = g_tutor;
	if true == is_done then
		mark = util.bit_or(g_tutor, index);
	else
		index = util.bit_not(index);
		mark = util.bit_and(g_tutor, index);
	end
	g_tutor = mark;
	g_tutor_change = true;
	--local cmd = string.format("scourse %d", mark);
	if true == is_upload then
		util.upload_tutor()
	end
	return;
end

function reset_tutor()
	net_send('scourse 0');
end

function reset_svg_tutor()
	for i=TUTOR_FIRST_SAC, 31 do
		util.set_tutor(i, false, true)
	end
end

function util.add_tutorial(pos, size, tutor_step, callback, not_set)
	--[[ no need to check again, already did in trigger_tutor
	if true == util.check_tutor(tutor_step) then
		return false;
	end
	]]--
	if true ~= not_set then
		util.set_tutor(tutor_step, true, false);
	end
	local tip = tutor_tip(tutor_step);
	--[[
	local director = cc.Director:getInstance();
	local scene = director:getRunningScene();
	local layer_tutor = scene:getChildByTag(TAG_LAYER_TUTOR);
	if nil == layer_tutor then
	]]--
	if nil == layer_tutorial.layer then
		local layer, name = layer_tutorial:create(pos, size, tip, callback);
		--layer:setTag(TAG_LAYER_TUTOR);
		g_scene:add_layer(ZORDER_LAYER_TUTORIAL, layer, name);
	else
		-- see in layer_tutorial to_close
		layer_tutorial:set_view(pos, size, tip, callback);
		return true, true;
		--return true, pos, size, tip, callback;
	end
	return true;
end

function util.trigger_tutor(ts, is_force) -- tutor_step
	if true ~= g_scene:is_online() then
		return false;	
	end
	if ts < 1000 and true ~= is_force and true == util.check_tutor(ts) then
		return false;
	end
	if ts == TUTOR_SOLO then
		return tutor_solo();
	elseif ts == TUTOR_RES then
		return tutor_res();
	elseif ts == TUTOR_TAP_SKIP then
		return tutor_tap_skip();
	elseif ts == TUTOR_HERO_POWER then
		return tutor_hero_power();
	elseif ts == TUTOR_ALLY_ATTACK then
		return tutor_ally_attack();
	elseif ts == TUTOR_WEAPON_ATK then
		return tutor_weapon_atk();
	elseif ts == TUTOR_ARMOR_DEF then
		return tutor_armor_def();
	elseif ts == TUTOR_COST then
		return tutor_cost();
	elseif ts == TUTOR_SAC then
		return tutor_sac();
	elseif ts == TUTOR_SAC_TAP then
		return tutor_sac_tap();
	elseif ts == TUTOR_PLAY then
		return tutor_play();
	elseif ts == TUTOR_HL then
		return tutor_hl();
	elseif ts == TUTOR_USE then
		return tutor_use();
	elseif ts == TUTOR_HL_ALLY then
		return tutor_hl_ally();
	elseif ts == TUTOR_TAP_ATTACK then
		return tutor_tap_attack();
	elseif ts == TUTOR_HL_ATTARGET then
		return tutor_hl_attarget();
	elseif ts == TUTOR_TAP_ATTARGET then
		return tutor_tap_attarget();
	elseif ts == TUTOR_HL_HERO then
		return tutor_hl_hero();
	elseif ts == TUTOR_TAP_ABHERO then
		return tutor_tap_abhero();
	elseif ts == TUTOR_NEXT then
		return tutor_next();
	elseif ts == TUTOR_STORY then
		return tutor_local();
	elseif ts == TUTOR_FIRST_SAC then
		return tutor_first_sac();
	elseif ts == TUTOR_WAIT_NEXT_SAC then
		return tutor_wait_next_sac();
	elseif ts == TUTOR_WAIT_NEXT then
		return tutor_wait_next();
	elseif ts == TUTOR_SECOND_SAC then
		return tutor_second_sac();
	elseif ts == TUTOR_HIGHLIGHT_CARD then
		return tutor_highlight_card();
	elseif ts == TUTOR_SOMMON_CARD then
		return tutor_summon_card();
	elseif ts == TUTOR_WYLD_SKILL then
		return tutor_wyld_skill();
	elseif ts == TUTOR_NO_TARGET_ATK then
		return tutor_no_target_atk();
	elseif ts == TUTOR_REST then
		return tutor_rest();
	elseif ts == TUTOR_ATTACK then
		return tutor_attack();
	elseif ts == TUTOR_INTRO then
		return tutor_intro();
	elseif ts == TUTOR_AREA then
		return tutor_area();
	elseif ts == TUTOR_AREA_RES then
		return tutor_area_res();
	elseif ts == TUTOR_AREA_HAND then
		return tutor_area_hand();
	elseif ts == TUTOR_AREA_HERO then
		return tutor_area_hero();
	elseif ts == TUTOR_AREA_DECK then
		return tutor_area_deck();
	elseif ts == TUTOR_AREA_SPACE then
		return tutor_area_space();
	elseif ts == TUTOR_TURN_SAC then
		return tutor_turn_sac();
	elseif ts == TUTOR_PVP_CAN_ATTACK then
		return tutor_pvp_can_attack();
	elseif ts == TUTOR_PVP_ATTACK then
		return tutor_pvp_attack();
	elseif ts == TUTOR_PAY_AD then
		return tutor_pay_ad();
	elseif ts == TUTOR_PAY then
		return tutor_pay();
	elseif ts == TUTOR_DECK then
		return tutor_deck();
	end
	return false;
end

function util.play_frame(layer, effname, pos, anchorpoint, frame_time, zorder, is_repeat)
	local filename, fullpath;
	local cache, sprite, animation, len;
	cache = cc.SpriteFrameCache:getInstance();
	filename = effname .. '.plist';
	fullpath = util.get_fullpath(F_ANIM, filename);
	cache:addSpriteFrames(fullpath);
	filename = effname .. '_1.png';
	sprite = cc.Sprite:createWithSpriteFrameName(filename);
	sprite:setPosition(pos);
	sprite:setAnchorPoint(anchorpoint or ANCHOR_LEFT_DOWN);
	layer:addChild(sprite, zorder or 0);
	animation = cc.Animation:create();
	len = 0;
	filename = effname .. '_' .. 1 .. '.png';
	local frame = cache:spriteFrameByName(filename);
	repeat
		len = len + 1;
		animation:addSpriteFrame(frame);
		filename = effname .. '_' .. len .. '.png';
		frame = cache:spriteFrameByName(filename);
	until nil == frame;
	animation:setDelayPerUnit(frame_time or 0.5);
	if true == is_repeat then
		sprite:runAction(cc.RepeatForever:create(cc.Animate:create(animation)));
	else
		sprite:runAction(cc.Animate:create(animation));
	end
	return sprite;
end

function util.get_bit()
	if nil ~= util.bit then
		return util.bit;
	end
	util.bit = { data32 = {} };
	for i = 1, 32 do
		util.bit.data32[i] = 2 ^ (32 - i);
	end
	return util.bit;
end

function util.d2b(arg)
	local bit = util.get_bit();
	local tr = {};
	for i = 1, 32 do
		if arg >= bit.data32[i] then
			tr[i] = 1;
			arg = arg - bit.data32[i];
		else
			tr[i] = 0;
		end
	end
	return tr;
end

function util.b2d(arg)
	local nr = 0;
	for i = 1, 32 do
		if arg[i] == 1 then
			nr = nr + 2 ^ (32 - i);
		end
	end
	return nr;
end

function util.bit_and(a, b)
	local op1 = util.d2b(a);
	local op2 = util.d2b(b);
	local r = {};
	for i = 1, 32 do
		if op1[i] == 1 and op2[i] == 1 then
			r[i] = 1;
		else
			r[i] = 0;
		end
	end
	return util.b2d(r);
end

function util.bit_or(a, b)
	local op1 = util.d2b(a);
	local op2 = util.d2b(b);
	local r = {};
	for i = 1, 32 do
		if op1[i] == 1 or op2[i] == 1 then
			r[i] = 1;
		else
			r[i] = 0;
		end
	end
	return util.b2d(r);
end

function util.bit_lshift(a, n)
	local op1 = util.d2b(a);
	local r = util.d2b(0);
	if n < 32 and n > 0 then
		for i = 1, n do
			for j = 1, 31 do
				op1[j] = op1[j + 1];
			end
			op1[32] = 0;
		end
		r = op1;
	end
	return util.b2d(r);
end

function util.bit_rshift(a, n)
	local op1 = util.d2b(a);
	local r = util.d2b(0);
	if n < 32 and n > 0 then
		for i = 1, n do
			for j = 31, 1, -1 do
				op1[j + 1] = op1[j];
			end
			op1[1] = 0;
		end
	r = op1;
	end
	return util.b2d(r);
end

function util.bit_not(a)
	local op1 = util.d2b(a);
	local r = {};
	for i = 1, 32 do
		if op1[i] == 1 then
			r[i] = 0;
		else
			r[i] = 1;
		end
	end
	return util.b2d(r);
end

function util.bit_xor(a, b)
	local op1 = util.d2b(a);
	local op2 = util.d2b(b);
	local r = {};
	for i = 1, 32 do
		if op1[i] == op2[i] then
			r[i] = 0;
		else
			r[i] = 1;
		end
	end
	return util.b2d(r);
end

function util.clear_loaded_info(filename)
	if nil == filename then return; end
	if package.loaded[filename] then
		package.loaded[filename] = nil;
	end
end

function util.relaunch_game()
	util.clear_loaded_info("version");
	util.clear_loaded_info("game");
	util.clear_loaded_info("lang_local");
	util.clear_loaded_info("logic");
	util.clear_loaded_info("lang_zh");
	main();
end

function util.string_cut_by_size(str, limit_size)
	local count = 0;
	local output = '';
	local byte_count = 0;
	for i = 1, string.len(str) do
		local cur_byte = string.byte(str, i);
		if byte_count == 0 then
			if cur_byte > 0 and cur_byte <= 127 then
				byte_count = 1;
			elseif cur_byte >= 192 and cur_byte < 223 then
				byte_count = 2;
			elseif cur_byte >= 224 and cur_byte < 239 then
				byte_count = 3;
			elseif cur_byte >= 240 and cur_byte < 247 then
				byte_count = 4;
			else
				byte_count = 1;
			end
			local char = string.sub(str, i, i+byte_count-1);
			output = output .. char;
			count = count + 1;
			if nil ~= limit_size then
				if count > limit_size then
					break;
				end
			end
		end
		byte_count = byte_count - 1;
	end
	return output, count;
end

function util.get_json_str(tbl)
	local str = "{";
	for k, v in pairs(tbl) do
		if #str > 1 then
			str = str .. ",";
		end
		str = str .. "\"" .. k .. "\"";
		str = str .. ":";
		str = str .. "\"" .. v .. "\"";
	end
	str = str .. "}";
	return str;
end

function util.load_sensitive_data()
	g_sensitive_list = {};
	local str = open_file('', 'sensitive_name.fl');
	local list_line = csplit(str, "[\r\n]", 3000);
	local list = {};
	for i = 1, #list_line do
		local line = list_line[i];
		line = string.gsub(line, "\n", "")
		line = string.gsub(line, "\r", "")
		local column = csplit(line, "+");
		list[#list+1] = column;
	end
	g_sensitive_list = list;
end

function util.check_has_sensitive_data(info)
	if nil == info or #info <= 0 then
		return false;
	end
	
	local sen_list;
	local count = 0;
	for i = 1, #g_sensitive_list do
		sen_list = g_sensitive_list[i];
		count = 0;
		for j = 1, #sen_list do
			if nil == string.find(info, sen_list[j]) then
				break;
			end
--			print('cmp str:', info, sen_list[j]);
			count = count + 1;
		end
--		print('cmp count:', count, #sen_list);
		if count == #sen_list then
			return true;
		end
	end
	return false;
end

function util.replace_sensitive_data(info)
	if nil == info or #info <= 0 then
		return info;
	end

	local sen_list;
	local pos_list;
	local spos, epos;
	for i = 1, #g_sensitive_list do
		sen_list = g_sensitive_list[i];
		pos_list = {};
		for j = 1, #sen_list do
			spos, epos = string.find(info, sen_list[j]);
			if nil == spos then
				break;
			end
			pos_list[#pos_list+1] = { spos = spos, epos = epos };
		end
		if #pos_list == #sen_list then
			for k = 1, #sen_list do
				info = string.gsub(info, sen_list[k], '***');
			end
		end
	end
	return info;
end
-- /////////////////////// UTIL END   ///////////////////////////

-- /////////////////////// RICH LABEL START   ///////////////////////////
rich_label = { chinese_size = 3 };
function rich_label.new(parent, pos, text, font, font_size, row_width, row_space, zorder)
	local node = cc.Node:create();
	node:setPosition(pos);
	node:setContentSize(cc.size(1, 1));
	parent:addChild(node, zorder or 0);
	local text_tab = rich_label.init_data(text, font, font_size, row_width);
	local ptab, copy_var = rich_label.tab_add_text(text_tab);

	local oc_width = 0;
	local oc_row = 1;
	local oc_height = 0;
	local btn = 0;
	local use_width = 0;
	local use_height = 0;
	for k, v in pairs(copy_var) do
		local params = {};
		rich_label.tab_add_data_to(params, v);
		--print('prow, orow: ', params.row, oc_row);
		if params.row == oc_row then
			oc_width = oc_width + use_width;
		else
			oc_row = params.row;
			oc_width = 0;
			oc_height = oc_height + use_height + row_space;
		end
		local max_size = params.size;
		local byte_size = math.floor((max_size+2)/rich_label.chinese_size);
		params.width = byte_size * params.breadth;
		params.height = max_size;
		params.x = oc_width;
		params.y = -(oc_height);
		params.node = node;
		btn, use_width, use_height = rich_label.tab_create_button(params);
	end
	return node, oc_width, oc_height + font_size;
end

function rich_label.init_data(text, font, font_size, row_width)
	local tab = rich_label.parse_string(text, {font = font, size = font_size});
	local var = { tab = tab, width = row_width };
	return var;
end

function rich_label.parse_string(text, param)
	local tab_head = {};
	for w in string.gfind(text, "%b[]") do
		if "/" ~= string.sub(w, 2, 2) then
			table.insert(tab_head, w);
		end
	end
	local total_tab = {};
	for k, ns in pairs(tab_head) do
		local tab = {};
		local str = nil;
		string.gsub(ns, string.sub(ns, 2, #ns-1), 
			function(w)
				local n = string.find(w, "=");
				if n then
					local tem_tab = rich_label.str_split(w, " ");
					for k, pstr in pairs(tem_tab) do
						local tem_tab1 = rich_label.str_split(pstr, "=");
						local pname = tem_tab1[1];
						if 1 == k then str = pname; end
						local js = tem_tab1[2];
						local p = string.find(js, "[^%d.]");
						if not p then js = tonumber(js); end
						if "color" == pname then
							tab[pname] = rich_label.get_text_color(js);
						else
							tab[pname] = js;
						end
					end
				end
			end
		)
		if str then
			local b_find, e_find = string.find(text, "%[%/" .. str .. "%]");
			--print('b_find, e_find: ', b_find, e_find);
			if nil ~= b_find and nil ~= e_find then
				local e_number = b_find - 1;
				local gs = string.sub(text, #ns+1, e_number);
				if string.find(gs, "%[") then
					tab["text"] = gs;
				else
					string.gsub(text, gs, 
						function(w)
							tab["text"] = w;
						end
					)
				end
				text = string.sub(text, e_find+1, #text)
				if param then
					if not tab.number then param.number = k; end
					rich_label.tab_add_data_to(tab, param);
				end
				table.insert(total_tab, tab);
			end
		end
	end
	-- TODO
	--if 0 == table.nums(tab_head) then
	local tab_head_nums = 0;
	for k, v in pairs(tab_head) do
		tab_head_nums = tab_head_nums + 1;
	end
	if 0 == tab_head_nums then
		local ptab = {};
		ptab.text = text;
		if param then
			param.number = 1;
			rich_label.tab_add_data_to(ptab, param);
		end
		table.insert(total_tab, ptab);
	end
	return total_tab;
end

function rich_label.str_split(str, flag)
	local tab = {};
	while true do
		local n = string.find(str, flag);
		if n then
			local first = string.sub(str, 1, n-1);
			str = string.sub(str, n+1, #str); 
			table.insert(tab, first);
		else
			table.insert(tab, str);
			break;
		end
	end
	return tab;
end

function rich_label.get_text_color(text)
	if 6 == string.len(text) then
		local tmp = {};
		for i = 0,5 do
			local str = string.sub(text,i+1,i+1);
			if(str >= '0' and str <= '9') then
				tmp[6-i] = str - '0';
			elseif(str == 'A' or str == 'a') then
				tmp[6-i] = 10;
			elseif(str == 'B' or str == 'b') then
				tmp[6-i] = 11;
			elseif(str == 'C' or str == 'c') then
				tmp[6-i] = 12;
			elseif(str == 'D' or str == 'd') then
				tmp[6-i] = 13;
			elseif(str == 'E' or str == 'e') then
				tmp[6-i] = 14;
			elseif(str == 'F' or str == 'f') then
				tmp[6-i] = 15;
			else
				print("Wrong color value.");
				tmp[6-i] = 0;
			end
		end
		local r = tmp[6] * 16 + tmp[5];
		local g = tmp[4] * 16 + tmp[3];
		local b = tmp[2] * 16 + tmp[1];
		return cc.c3b(r,g,b);
	end
	return cc.c3b(255,255,255);
end

function rich_label.tab_add_data_to(tab, src)
	for k, v in pairs(src) do
		tab[k] = v;
	end
end

function rich_label.tab_add_text(var)
	local all_tab = {};
	local copy_var = {};
	local use_len = 0;
	local str = "";
	local current = 1;
	for ktb, tab in ipairs(var.tab) do
		local txt_tab, member = rich_label.tab_cut_text(tab.text);
		local num = math.floor((var.width)/math.ceil((tab.size+2)/rich_label.chinese_size));
		if 0 < use_len then
			local remain = num - use_len;
			local txt_len = rich_label.account_text_len(tab.text, tab.size);
			if txt_len <= remain then
				all_tab[current] = all_tab[current] .. tab.text;
				rich_label.add_data_to_render_tab(copy_var, tab, tab.text, (use_len + 1), current);
				use_len = use_len + txt_len;
				txt_tab = {};
			else
				local c_tag = 0;
				local mstr = "";
				local s_index = use_len + 1;
				for k, element in pairs(txt_tab) do
					local s_len = rich_label.account_text_len(element, tab.size);
					if (use_len + s_len) <= num then
						use_len = use_len + s_len;
						c_tag = k;
						mstr = mstr .. element;
					else
						if string.len(mstr) > 0 then
							all_tab[current] = all_tab[current] .. mstr;
							rich_label.add_data_to_render_tab(copy_var, tab, mstr, s_index, current);
						end
						current = current + 1;
						use_len = 0;
						str = "";
						break;
					end
				end
				for i = 1, c_tag do
					table.remove(txt_tab, 1);
				end
			end
		end
		local max_row = math.ceil(member/num);
		for k, element in pairs(txt_tab) do
			local s_len = rich_label.account_text_len(element, tab.size);
			if (use_len + s_len) <= num then
				use_len = use_len + s_len;
				str = str .. element;
			else
				all_tab[current] = str;
				rich_label.add_data_to_render_tab(copy_var, tab, str, 1, current);
				current = current + 1;
				use_len = s_len;
				str = element;
			end
			if k == #txt_tab then
				if use_len <= num then
					all_tab[current] = str;
					rich_label.add_data_to_render_tab(copy_var, tab, str,1,current);
				end
			end
		end
	end
	return all_tab, copy_var;
end

function rich_label.tab_cut_text(str)
	local list = {};
	local len = string.len(str);
	local i = 1;
	while i <= len do
		local c = string.byte(str, i);
		local shift = 1;
		if c > 0 and c <= 127 then
			shift = 1;
		elseif (c >= 192 and c <= 223) then
			shift = 2;
		elseif (c >= 224 and c <= 239) then
			shift = 3;
		elseif (c >= 240 and c <= 247) then
			shift = 4;
		end
		local char = string.sub(str, i, i+shift-1);
		i = i + shift;
		table.insert(list, char);
	end
	return list, len;
end

function rich_label.str_format_to_number(number, num)
	local s = "%." .. num .. "f"
	return tonumber(string.format(s, number))
end

function rich_label.account_text_len(str, tsize)
	local list = rich_label.tab_cut_text(str);
	local a_len = 0;
	for k, v in pairs(list) do
		local a = string.len(v);
		-- TODO need optimize
		local font = "Arial";
		local label = cc.Label:createWithSystemFont(v, font, tsize);
		a = tsize/label:getContentSize().width;
		local b = rich_label.str_format_to_number(rich_label.chinese_size / a, 4);
		a_len = a_len + b;
		-- now is let it auto relase
	end
	return a_len;
end

function rich_label.add_data_to_render_tab(copy_var, tab, text, index, current)
	local tag = #copy_var + 1;
	copy_var[tag] = {};
	rich_label.tab_add_data_to(copy_var[tag], tab);
	copy_var[tag].text = text;
	copy_var[tag].index = index;
	copy_var[tag].row = current;
	copy_var[tag].breadth = rich_label.account_text_len(text, tab.size);
	copy_var[tag].tag = tag;
end

function rich_label.tab_create_button(params)
	local node = params.node;
	local text = params.text;
	local size = params.size;
	local color = params.color or util.c_white;
	local font = params.font;
	local x = params.x;
	local y = params.y;
	--print('==== rich_label text: ', text, font, size, node, color);
	local label = util.add_labelsys(node, text, font, size, cc.p(x, y), color, ANCHOR_LEFT_DOWN);
	local lsize = label:getContentSize();
	if params.image then
		rich_label.image_manage(btn, params, use_Width)
	end
	return label, lsize.width, lsize.height;
end

function rich_label.image_manage(object, params, use_width)
	local node = params.node;
	local fname = params.image;
	local fullpath, is_exist = util.get_fullpath(F_IMAGE, fname);
	if true ~= is_exist then return; end
	local x = params.x;
	local y = params.y;
	util.add_sprite(node, fullpath, cc.p(x, y), ANCHOR_LEFT_DOWN);
end
-- /////////////////////// RICH LABEL END   ///////////////////////////

-- /////////////////////// COMMON START   ///////////////////////////
function is_ver(cver)
	if cver == CHANNEL_VER then
		return true;
	end
	return false;
end

function is_anysdk_show_pay()
	if true ~= (is_ver(VER_ANYSDK) or is_ver(VER_ANYSDK_NO_LOGIN)) then
		return false;
	end
	local agent = AgentManager:getInstance();
	local cid = tonumber(agent:getChannelId() or "0");

	return true;
	--show_msg("cid: " .. cid);
	-- 000008 木蚂蚁
	-- 000003 当乐
	-- 000004 N多
	-- 000066 小米 木蚂蚁
	-- 000020 可可
	-- 000286 金立
	-- 000002 机锋
	-- 000054 华为
	-- 000078 酷派
	-- 000108 4399
	-- 110000 百度游戏
	-- 000116 豌豆荚
	-- 000014 魅族
	-- 000550 腾讯
--	if cid == 8 or cid == 3 or cid == 4 or cid == 66 or cid == 20 or cid == 286 or cid == 2 or cid == 54 or cid == 78 or cid == 108 or cid == 110000 or cid == 116 or cid == 14 or cid == 550 then
--		return true;
--	end
--	return false;
end

function is_anysdk_oppo()
	if true ~= (is_ver(VER_ANYSDK) or is_ver(VER_ANYSDK_NO_LOGIN)) then
		return false;
	end
	local agent = AgentManager:getInstance();
	local cid = tonumber(agent:getChannelId() or "0");
	if cid == 20 then
		return true;
	end
	return false;
end

function t_lang(key)
	if nil == g_lang or nil == key then
		return '';
	end
	local text = g_lang[key] or '';
	return text;
end

function callback_remove_sprite(...)
	local args = { ... };
	local sprite = args[1];
	sprite:removeFromParentAndCleanup(false);
end

function wfix(width)
	width = width * g_scale.x;
	return width;
end

function hfix(height)
	height = height * g_scale.y;
	return height;
end

function get_time()
	local str = os.date("%X");
	return str;
end

function get_icon_path(index)
	index = index or '0';
	local filename = 'picon_1_' .. index .. '.png';
	--local fullpath = util.get_fullpath(F_IMAGE, filename, 'picon_1_0.png');
	local path = util.get_path(filename, 'picon_1_0.png');
	return path;
end

function c_get_slot_str(deck_str, all_str)
	local deck_len = string.len(deck_str or '');
	local all_len = string.len(all_str or '');
	local str = '';
	if deck_len ~= all_len then
		kerror("c_get_slot_str len[%d],deck[%d]", deck_len, all_len);
		return str;
	end
	for i = 1, deck_len do
		local ds = string.sub(deck_str, i, i); -- 
		local dn = tonumber(ds) or 0;

		local as = string.sub(all_str, i, i); 
		local an = tonumber(as) or 0;

		local n = an - dn;
		if n < 0 then
			n = 0;
		end
		str = str .. n;
	end
	return str;
end

function c_str_array(str)
	local list = {};
	local len = string.len(str or '');
	for i = 1, len do
		local s = string.sub(str, i, i); -- get one character
		local n = tonumber(s) or 0;
		if n > 0 then
			local rc = g_card_list[i];
			if nil == rc then
				rc = hero_list[i];
			end
			if nil ~= rc then
				-- in layer_deck 
				-- when using g_euser.deck_array
				-- will clone the cards again in order to avoid mixup the card
				local card = clone(rc);	
				table.insert(list, { card = card, count = n });
				--list[#list+1] = { card = card, count = n };
			end
		end
	end
	return list;
end

function c_str_array_2(str)
	local list = {};
	local len = string.len(str or '');
	for i = 1, len do
		local s = string.sub(str, i, i); -- get one character
		local n = tonumber(s) or 0;
		if n > 0 then
			local rc = g_card_list[i];
			if nil == rc then
				rc = hero_list[i];
			end
			if nil ~= rc then
				table.insert(list, { cid = i, count = n });
			end
		end
	end
	return list;
end

function c2_str_array(str)
	local list = {};
	local len = string.len(str or '');
	local index = 1;
	for i = 1, len, 2 do
		local s = string.sub(str, i, i+1); -- get two character
		local n = tonumber(s) or 0;
		if n > 0 then
			local rc = g_card_list[index];
			if nil == rc then
				rc = hero_list[index];
			end
			if nil ~= rc then
				-- in g_layer_deck 
				-- when using g_euser.deck_array
				-- will clone the cards again in order to avoid mixup the card
				--local card = clone(rc); -- just get the id is enough	
				table.insert(list, { cid = index, count = n });
				--list[#list+1] = { card = card, count = n };
			end
		end
		index = index + 1;
	end
	return list;
end

function get_guild_name(gname)
	if nil == gname or "_no_guild" == gname then
		return t_lang("NO_GUILD");
	end
	return gname;
end

function get_power()
	return math.floor(g_euser.power or 0);
end

function enable_btn(btn, is_enable)
	if nil == btn then return; end
    if true == is_enable then
		btn:setEnabled(true);
		btn:setColor(cc.c3b(255, 255, 255));
	else  
		btn:setEnabled(false);
		btn:setColor(cc.c3b(100, 100, 100));
	end   
end

-- calculate the horizontal gap width between 2 cards, 
-- given a table of table_width,  card_width can be init globally
-- ltype is ui_table.ltype
function calculate_gap(total_card, card_width, table_width, ltype)
	if g_euser.side == SIDE_DOWN and ltype == DOWN_HAND then
		table_width = table_width+HAND_GAP*2;
	end
	local gap;
	local base;
	-- ?? why not table_width / total_card ?
	base = total_card - 1;
	if (base <= 0) then
		base = 1;  -- magic, never division-by-zero
	end

	-- beware: gap may be negative!
	gap = (table_width - card_width) / base;
	if gap > card_width then
		gap = card_width;
	end
	return math.abs(gap); -- note: this is not pixel, so decimal is OK
end

-- just used for init_ui_table and refresh_table_list
function get_card_pos_rotation(ui_table, gap, index, total_card)
	local pos;
	local rotation = 0;
	if ui_table.ltype == DOWN_HAND then
		local half_height = ui_table.height / 4;
		local m_index = total_card / 2 + 1;
		local offsety = half_height / (m_index - 1);
		local tx = ui_table.x;
		local half_width = ui_table.width / 2;
		local y;
		if g_euser.side == SIDE_DOWN then
			tx = tx - HAND_GAP;
			half_width = half_width + HAND_GAP; -- HAND_GAP*2/2
			y = ui_table.y;
			rotation = 0;
		else
			y = ui_table.y - math.abs(m_index - index) * offsety * 0.5 
			local r_gap = 40 / m_index;
			rotation = (index - m_index) * r_gap;
		end
		pos = cc.p( tx + half_width + gap * ( index - m_index ), y);
	elseif ui_table.ltype == UP_HAND then
		local half_height = ui_table.height / 4;
		local m_index = total_card / 2 + 1;
		local offsety = half_height / (m_index - 1);
		local tx = ui_table.x;
		local half_width = ui_table.width / 2;
		pos = ccp( tx + half_width + gap * ( index - m_index ), 
			       ui_table.y + math.abs(m_index - index) * offsety * 0.5 
				 );
		local r_gap = 40 / m_index;
		rotation = 180 - (index - m_index) * r_gap;
	elseif ui_table.ltype == UP_DECK then
		rotation = 30;
		pos = ccp( ui_table.x + gap * ( index - 1 ), ui_table.y );
	elseif ui_table.ltype == DOWN_DECK then
		rotation = -30;
		pos = ccp( ui_table.x + gap * ( index - 1 ), ui_table.y );
	else
		pos = ccp( ui_table.x + gap * ( index - 1 ), ui_table.y );
	end
	return pos, rotation;
end

function add_ui_card(layer, card_list, pos, rotation, card, sprite, alist, index)
	if card==nil then
		kerror("add_ui_card card(info)=nil");
	end

	local t = card_list.ltype;
	local ctype = CARD_FRONT;
	if card.id > 1000 then
		ctype = CARD_VIRTUAL;
	elseif t==UP_DECK or t==DOWN_DECK then
		if (g_euser.side == SIDE_DOWN and t==DOWN_DECK) and is_view_top() then
--			print('card index:', cindex(card));
			ctype = CARD_FRONT;
		else
			ctype = CARD_COVER;
		end
	elseif t==DOWN_HAND or t==UP_HAND then
		if (g_euser.side == SIDE_UP and t==UP_HAND) or true == SHOW_ALL or is_view_oppo() then
			ctype = CARD_FRONT;
		elseif g_euser.side == SIDE_DOWN and t==DOWN_HAND then
			ctype = CARD_FRONT;
		elseif true == data_handler.show_all_card then
			ctype = CARD_FRONT;
		else
			ctype = CARD_COVER;
		end
	elseif t==UP_GRAVE or t==DOWN_GRAVE then
		ctype = CARD_GRAVE;
	elseif t==UP_HERO or t==DOWN_HERO then
		ctype = CARD_HERO;
	elseif card.ctype == ATTACH then
		ctype = CARD_ATTACH;
	end

	local scale = card_list.cscale;
	local stype = STYPE_VER_2;
	local info;
	info = object_card:new(layer, card, sprite, alist, pos, rotation,scale,stype);
	if nil == index or index > #card_list + 1 then
		index = #card_list + 1;
	elseif index < 1 then
		index = 1;
	end
	table.insert(card_list, index, info);

	local t = card_list.ltype;
	local list_offset = index_offset(index);
	if t == UP_DECK or t == DOWN_DECK then
		--local list_length = #g_logic_table[SIDE_UP][T_DECK];
		--info.status = CARD_COVER;
		--if t == DOWN_DECK then
		--print('card.name: ', card.name, info.status, CARD_FRONT, CARD_COVER);
		--end
		if list_offset > 4 then
			if nil ~= sprite then
				info:remove_sprite();
			end
			return info;	
		end
	end
	if t == UP_GRAVE then
		return info;
		--[[
		local list_length = #g_logic_table[SIDE_UP][T_GRAVE];
		if list_offset < list_length then
			return info;	
		end
		]]--
	end
	if t == DOWN_GRAVE then
		return info;
		--[[
		local list_length = #g_logic_table[SIDE_DOWN][T_GRAVE];
		if list_offset < list_length then
			return info;	
		end
		]]--
	end
	if nil ~= sprite then
		--[[
		local tt = index_table_num(cindex(info.card));
		if tt == T_DECK and info.status ~= CARD_COVER then
				info:remove_sprite();
		else
			return info, sprite;
		end
		]]--
		return info, sprite;
	end
	local new_sprite = info:set_sprite(ctype);

	return info, new_sprite;
end

-- this is for cc.CallFunc
function refresh_layer_card()
	layer_card:refresh_layer();
end

function clean_sprite_cache()
	for c, s in pairs(g_sprite_cache) do
		-- check the value kind, do check clean only if it is sprite
		-- card.pos == nil means this card will never use again, can remove it
		--if tolua.type(s) == 'cc.Sprite' and nil == c.pos then
		if nil ~= s.removeFromParentAndCleanup and nil == c.pos then
			print('DEBUG refresh_and_remove: ', c.name);
			--TODO always bug here
			s:removeFromParentAndCleanup(true);
			-- TODO
			-- should remove key and value  from table after remove sprite
			g_sprite_cache[c] = nil;
		end
	end
	
	for c, s in pairs(g_pic_cache) do
		if nil ~= s.removeFromParentAndCleanup and nil == c.pos then
			s:removeFromParentAndCleanup(true);
			g_pic_cache[c] = nil;
		end
	end
end

function remove_from_cmd_list()
	g_cache_cmd_list = g_cache_cmd_list or {};
	if 0 == #g_cache_cmd_list then
		return;
	end
	table.remove(g_cache_cmd_list, 1);
end

function pop_cmd_list()
	g_cache_cmd_list = g_cache_cmd_list or {};
	if 1 > #g_cache_cmd_list then
		return nil;
	end
	local list = g_cache_cmd_list[1];
	return list;
end

function push_cmd_list(cmd, list_callback, index)
	g_cache_cmd_list = g_cache_cmd_list or {};
	local before = #g_cache_cmd_list;
	g_cache_cmd_list[#g_cache_cmd_list + 1] = {
		cmd = cmd,
		list_callback = list_callback,
		index = index,
	};

	if 1 == #g_cache_cmd_list then
		local list = pop_cmd_list();
		if nil ~= list then
			cmd_to_eff(list);
		end
	end
end

function cmd_to_eff(list)
	local cmd = list.cmd;
	local list_callback = list.list_callback;
	local index = list.index;
	local eff_list, err;
	eff_list, err = cmd_game_to_logic(cmd, true);
	local input_list = split_string(cmd);
	layer_card:visible_btn_by_cmd(input_list[1], false);
	if 'n' == input_list[1] then
		local timeout = nil;
		layer_card:handle_next_timeout(input_list[2]);
		layer_table:change_side(g_current_side);
	end
	play_to_anim(eff_list, list_callback, index, err);
end

function check_cmd_finish()
	g_cache_cmd_list = g_cache_cmd_list or {};
	if 0 < #g_cache_cmd_list then
		return false;
	end
	if nil == g_net_win_data then
		return false;
	end
	callback_net_win();
	return true;
end

function callback_anim()
	--layer_action:remove();
	--enable_touch();
	---------
	-- assume that all net_play cmd will save to g_cache_cmd_list first
	remove_from_cmd_list();
	local is_finish = check_cmd_finish();
	if true == is_finish then
		return;
	end
	local list = pop_cmd_list();
	if nil ~= list then
		cmd_to_eff(list);
		return;
	end
	--------

	if false == g_scene:is_online() and true ~= LOCAL_TEST and g_euser.side ~= g_current_side then
		do_ai();
	end

	if true == g_is_in_tutor then
		if nil ~= story_next then
			local cb = story_next;
			story_next = nil;
			cb();
		end
	end
end

-- get eff_list from logic.lua , pass to anim.lua
function play_to_anim(eff_list, callback_list, index, err)
	kdebug("==play_to_anim==");
	if nil == eff_list then
		kerror("play_to_anim eff_list is nil");
		layer_card:refresh_card_list();
		refresh_layer_card();
		if nil ~= err then
			g_scene:add_layer(ZORDER_LAYER_MSG, layer_msg:create(err));
		end
		return false;
	end
	layer_card:hide_all_btn();
	remove_hl();

	print('---------------------------------');
	print_eff_list(eff_list);
	print('---------------------------------');
	
	layer_card:clean_for_touch_end();
	layer_action:remove();

	callback_list = callback_list or {};
	table.insert(callback_list, callback_anim);
	if true == USE_ANIM then
		--anim.main(g_current_side, g_euser.side, g_ui_table, layer_card.layer, eff_list, callback_list, index);
		anim.main(eff_list, callback_list, index);
	else
		for i = 1, #callback_list do
			local cb = callback_list[i];
			cb();
		end
	end
	return true;
end

function cmd_game_to_logic(str, is_save)
	--[[ TODO
	if true == is_save then
		push_playcmd_list(str);
	end
	]]--
	local eff_list = nil; 
	local err = nil;
	print('DEBUG cmd_game_to_logic play_cmd: ', str);
	eff_list, g_current_side, g_phase, err = play_cmd(str, g_logic_table, g_current_side, g_phase);
	if nil == eff_list then
		local bc = g_net_play_cache[#g_net_play_cache];
		local input_list = csplit(bc, ' ');
		bc = str_cut_num(input_list[1], bc);
		if str == bc then
			table.remove(g_net_play_cache, #g_net_play_cache);
		else
			do_greconn();
		end
	end
	return eff_list, err;
end

function play_game_cmd(cmd, index)
	local is_online = g_scene:is_online();
	local is_save = false;
	if true ~= LOCAL_TEST and false == is_online then
		is_save = true;
	end
	layer_card:hide_all_btn();
	layer_card:remove_tip_help();
	-- PVP
	if true ~= g_is_in_tutor and true == is_online then
		if true == LOCAL_CMD then
			local lcmd = cmd;
			if 'f' == cmd then
				lcmd = 'n';
			end
			local_play(lcmd);
			net_send(cmd, true);
		else
			net_send(cmd);
		end
		return false;
	end

	-- PVE
	local eff_list = nil;
	local err = nil;
	local input_list = csplit(cmd, ' ');
	local cmdtype = input_list[1];
	if 'local_ai' == cmdtype then
		eff_list, g_current_side, g_phase = ai(g_logic_table, g_current_side, g_phase);
	else
		push_cmd_list(cmd, { refresh_layer_card }, nil);
		return;
	end
	return play_to_anim(eff_list, { refresh_layer_card }, index, err);
end

function is_target_grave(index, logic_table, current_side)
	local ab_indexs = list_ability_target(index, logic_table, current_side, {},1);
	for i = 1, #ab_indexs do
		local ci = ab_indexs[i];
		local itable = index_table_num(ci);
		local iside = index_side(ci);
		if itable == T_GRAVE then
			return true, iside;
		end
	end
end

-- RET 0 == do nothing  1 == can attack   2 == can ability
--     3 == both        4 == sac          5 == table ally   6 == table support
--     7 == grave
function check_kind(card, logic_table, current_side, phase)
	if nil == card then
		return AKIND_NONE;
	end
	local side_num = index_side(cindex(card));
	if side_num ~= current_side then
		return AKIND_NONE;
	end
	local index = cindex(card);
	local tb = index_table_num(index);
	-- return -1: can be sacrifice
	-- return 0:  no action available
	-- return 1:  attack
	-- return 2:  ability
	-- return 3:  both  : attack + ability
	local kind = check_action(card, logic_table, current_side);
	local index = cindex(card);
	if -1 == kind then
		return AKIND_SAC;
	elseif 1 == kind then
		return AKIND_ATTACK;
	elseif 2 == kind then
		local num;
		local err;
		num, err = total_target(index, logic_table, current_side);
		if nil ~= err then
			err = 'check_kind ' .. err;
			g_scene:add_layer(ZORDER_LAYER_MSG, layer_msg:create(err));
			return AKIND_NONE;
		end
		if 0 == num then
			if T_HAND == tb then
				if card.ctype == ALLY then
					return AKIND_TALLY;
				elseif card.ctype >= 50 and card.ctype <= 59 then
					return AKIND_TSUPPORT;
				else
					-- e.g. card 142 支援牌
					-- in hand, to use, no target, so point to support
					return AKIND_TSUPPORT;
				end
			end
			return AKIND_ABILITY;
		end
		if 0 < num then
			if 0 == target_num(index, logic_table, current_side) then
				return AKIND_NONE;
			end
			return AKIND_ABILITY;
		end
	elseif 3 == kind then
		local num, err = total_target(index, logic_table, current_side);
		if 0 == target_num(index, logic_table, current_side) and num > 0 then
			return AKIND_ATTACK;
		end
		return AKIND_BOTH;
	end
	return AKIND_NONE;
end

-- given an integer : DOWN_HERO, DOWN_HAND,  UP_HAND etc.
-- get the sub-g_ui_table
-- global: g_ui_table
function get_card_list(ltype) -- start {
	if nil == ltype then
		return {};
	end
	local s = math.floor(ltype / 1000);
	local t = math.floor(ltype % 10);
	local table_side = g_ui_table[s];
	if table_side == nil then
		--print('ERROR get_card_list table side is nil, ltype = ', ltype);
		return {};
	end
	local table_list = table_side[t];
	if table_list == nil then
		kerror("get_card_list table type is nil, ltype[%d]", ltype);
		return {};
	end
	return table_list;
end -- get_card_list }

-- get the ui data of a card  
-- counterpart:  index_card(index, g_logic_table)
-- e.g. g_ui_table[SIDE_UP][T_HAND][3]
function get_ui_card(index) -- {
	--print('DEBUG get_ui_card index: ', index);
	if index <= 0 then
		return nil;
	end
	local side_num = index_side(index);
	local table_side = g_ui_table[side_num];
	if table_side == nil then
		kerror("table_side is nil, side[%d]", side_num);
		return nil;
	end
	
	local table_num = index_table_num(index);
	local target_list = table_side[table_num];
	if target_list == nil then
		kerror("target_list is nil, table[%d]", table_num);
		return nil;
	end
	
	local table_index = index_offset(index);
	local card_info = target_list[table_index];
	if index > 10000 then
		local alist = card_info.attach_list or {};
		local aindex = index - math.floor(index/10)*10;
		card_info = alist[aindex];
	end
	if card_info == nil then
		kdebug("get_card_info is nil, index[%d]table_index[%d]", index, table_index);
		return nil;
	end
	return card_info;
end -- get_card_info }

function target_num(index, logic_table, current_side)
	local num = 0;
	if nil == index then
		return num;
	end
	local ab_list = {};
	local tindexs = list_ability_target(index, logic_table, current_side, ab_list, #ab_list + 1);
	if nil ~= tindexs then
		num = #tindexs;
	end
	return num;
end

-- obj is card_list e.g. g_ui_table[UP_SIDE][T_HAND]
function check_in_card(obj, x, y)
	local card = obj.card;
	local sprite = obj.sprite;
	local frame = obj.frame;
	local posx = frame.x;
	local posy = frame.y;
	local scale = frame.scale;
	local width = sprite:getContentSize().width;
	local height = sprite:getContentSize().height;
	local h_width = width * scale / 2;
	local h_height = height * scale / 2;

	range = range or 0;

	local sprite_l = posx - h_width;
	local sprite_r = posx + h_width;
	local sprite_u = posy + h_height;
	local sprite_d = posy - h_height;

	--print(' x, y, l, r, u, d ', x, y, sprite_l, sprite_r, sprite_u, sprite_d);

	if x > sprite_l and x < sprite_r and y < sprite_u and y > sprite_d then
		return true;
	end

	return false;
end

-- highlight card sprite
function hl_card(index, htype) -- {
	local card = index_card(index, g_logic_table);
	local card_sprite = g_sprite_cache[card];
	if nil == card_sprite or nil == htype then
		return;
	end
	local hl = card_sprite:getChildByTag(TAG_HIGHLIGHT);
	if hl ~= nil then
		card_sprite:removeChildByTag(TAG_HIGHLIGHT, true);
	end

	local path;
	local size = card_sprite:getContentSize();
	local pos = cc.p(size.width/2, size.height/2);
	if card.ctype == HERO then
		path = util.get_path('highlight_h.png');
	else
		path = util.get_path('highlight.png');
	end
	hl = util.add_sprite(card_sprite, path, pos, ANCHOR_CENTER_CENTER, -1);
	hl:setTag(TAG_HIGHLIGHT);
end -- hl_card }

-- kind = 4(resource) 5(ally) 6(support)
function hl_table(layer, kind, ui_table, current_side)
	local data, filename, fullpath, pos, size, list;
	if kind == AKIND_TALLY then
		list = ui_table[current_side][T_ALLY];
		data = gui_get_data('ally_down', GUI_MATCH); -- ally
		pos = cc.p(data.x+data.width/2, data.y+data.height/2);
		size = cc.size(data.width, data.height);
	elseif kind == AKIND_TSUPPORT then
		list = ui_table[current_side][T_SUPPORT];
		data = gui_get_data('sup_down', GUI_MATCH); -- support
		pos = cc.p(data.x+data.width/2, data.y+data.height/2);
		size = cc.size(data.width, data.height);
	elseif kind == AKIND_SAC then
		list = ui_table[current_side][T_RES];
		pos = cc.p(list.x, list.y);
		size = cc.size(list.width, list.height);
	elseif kind == AKIND_TGRAVE then
		list = ui_table[current_side][T_GRAVE];
		pos = cc.p(list.x, list.y-list.height/2);
		size = cc.size(list.width, list.height);
	else
		return;
	end

	remove_hl();

	local fullrect = cc.rect(0, 0, 64, 64);
	local insetrect = cc.rect(4, 3, 56, 58);
	fullpath = util.get_fullpath(F_IMAGE, 'white.png');
	local sprite = util.add_scale9sprite(layer, fullpath, pos, ANCHOR_CENTER_CENTER, fullrect, insetrect, size, ZORDER_CARD - 10); 
	sprite:setTag(TAG_HIGHLIGHT);


	local rect = { x1 = pos.x - size.width/2, x2 = pos.x + size.width/2,
				   y1 = pos.y - size.height/2, y2 = pos.y + size.height/2 };

	local c = sprite:getColor();
	local action, array;
	array = {};
	action = cc.TintTo:create(0.5, 255, 0, 0);
	table.insert(array, action);
	action = cc.TintTo:create(0.5, c.r, c.g, c.b);
	table.insert(array, action);
	action = cc.Sequence:create(array);
	action = cc.RepeatForever:create(action);
	sprite:runAction(action);
end

-- e.g index = 1101
function hl_at_target(index, flag) -- {
	g_src_index = index;

	local self = layer_card;
	
	local attack_target_indexs = list_attack_target(g_src_index, g_logic_table, g_current_side);

	-- order is important!  change_step must before layer_action:close(...)
	-- this two should do before remove action 
	-- because whether to reset g_src_index to 0 is base on the step
	change_step(STEP_TARGET);
	g_action_type = TYPE_ATTACK;

	remove_hl();
	if 'action' == flag then
		layer_action:close( { create_btn_cancel } );  
	end

	-- highlight the selectable targets
	for i = 1, #attack_target_indexs do
		local card_index = attack_target_indexs[i];
		hl_card(card_index, HL_TARGET);
	end
end -- hl_at_target end }

function hl_ab_target(index, flag) -- { start
	g_src_index = index;

	local self = layer_card;
	
	-- check for cast, execute ability directly
	local num;
	local err;
	num, err = total_target(g_src_index, g_logic_table, g_current_side)
	if nil ~= err then
		g_scene:add_layer(ZORDER_LAYER_MSG, layer_msg:create(err));
		return;
	end
	--print('DEBUG hl_ab_target num: ', num);
	if nil == num then
		kerror("callback_ability[%s]", err);
		return;
	end
	local is_special = false;
	local cid = (index_card(g_src_index, g_logic_table)).id;
	if 53 == cid then
		local list = list_ability_target(g_src_index, g_logic_table, g_current_side, {}, 1);
		if #(list or {}) > 0 then
			if nil == layer_action.layer then
				create_btn_cancel();
			end
			is_special = true;
		end
	end
	if true == is_special then
	elseif 'action' == flag then
		--print('--------------id, num: ', g_src_index, num);
		if 0 == num then
			local cmd = 'b ' .. g_src_index;
			play_game_cmd(cmd, index);
			return;
		end
		local just_myself = is_target_just_myself(g_src_index, g_logic_table, g_current_side);
		if true == just_myself then
			local cmd = string.format("b %d %d", g_src_index, g_src_index);
			play_game_cmd(cmd, index);
			return;
		end
		local attach_hero = is_target_attach_hero(g_src_index, g_logic_table, g_current_side);
		if nil ~= attach_hero then
			local cmd = string.format("b %d %d", g_src_index, attach_hero);
			play_game_cmd(cmd, index);
			return;
		end
	end
	
	-- this is global
	self.ability_target_list = {};
	local ability_target_indexs = list_ability_target(g_src_index, g_logic_table, g_current_side, self.ability_target_list, #self.ability_target_list + 1);
	--print('DEBUG hl_ab_target #ab_list: ', #ability_target_indexs);
	
	-- this two should do before remove action 
	-- because whether to reset g_src_index to 0 is base on the step
	change_step(STEP_TARGET);
	g_action_type = TYPE_ABILITY;
	-- new
	remove_hl();

	-- TODO consider 'move' case
	if 'action' == flag then
		local callback_list = { };
		if 1 > #(self.ability_target_list or {}) then
			table.insert(callback_list, create_btn_cancel);
		else
			table.insert(callback_list, create_btn_confirm);
		end
		local is_grave = false;
		for i = 1, #ability_target_indexs do
			local card_index = ability_target_indexs[i];
			local card_table_index = index_table_num(card_index);
			if card_table_index == T_GRAVE then
				is_grave = true;
				break;
			end
		end
		if true == is_grave then
			table.insert(callback_list, callback_open_grave);
			layer_action:close( callback_list );  
			return;
		end
		layer_action:close( callback_list );  
		--[[
		-- special case for Master Smith(158)
		-- Target weapon or armor in your graveyard is retruned to your hand.
		local card = index_card(g_src_index, g_logic_table);
		local src_side = index_side(g_src_index);
		-- TODO src_side == src_side ??
		if nil ~= card and 158 == card.id and src_side == src_side then
			table.insert(callback_list) = show_select_grave;
			--callback_list[#callback_list + 1] = show_select_grave;
		end
		--
		layer_action:close( callback_list );  
		]]--
	end

	for i = 1, #ability_target_indexs do
		--print(string.format("DEBUG ab selectable target [%d][%s]", i, ability_target_indexs[i]));
		local card_index = ability_target_indexs[i];
		hl_card(card_index,  HL_TARGET);
	end

	if true == is_special then
		if 53 == cid then
			local tt = index_table_num(g_src_index);
			if tt == T_HAND then
				self:reset_touch_data();
				show_msg("请选择上场技能的目标");
			end
		end
	end

end -- hl_ab_target end }

function get_both_target_list(self, src_index, is_just_t_b)
	local attack_target_indexs = list_attack_target(src_index, g_logic_table, g_current_side);

	self.ability_target_list = {};
	local ability_target_indexs = {};
	local num;
	local err;
	num, err = total_target(g_src_index, g_logic_table, g_current_side)
	if nil ~= num and num > 0 then
		ability_target_indexs = list_ability_target(g_src_index, g_logic_table, g_current_side, self.ability_target_list, #self.ability_target_list + 1);
	end
	if true == is_just_t_b then
		return attack_target_indexs, ability_target_indexs;
	end

	local lboth = {};
	local lat = {};
	local lab = {};
	for i = 1, #ability_target_indexs do
		local is_both = false;
		local index_ab = ability_target_indexs[i];
		for j = 1, #attack_target_indexs do
			local index_at = attack_target_indexs[j];
			if index_ab == index_at then
				table.insert(lboth, index_ab);
				table.remove(attack_target_indexs, j);
				is_both = true;
				break;
			end
		end
		if false == is_both then
			table.insert(lab, index_ab);
		end
	end
	lat = attack_target_indexs;

	return lat, lab, lboth;
end

function hl_both_target(index) -- {
	g_src_index = index;
	local self = layer_card;

	local lat, lab, lboth;
	lat, lab, lboth = get_both_target_list(self, g_src_index);

	change_step(STEP_TARGET)
	g_action_type = TYPE_BOTH;
	remove_hl()
	create_btn_cancel();

	for i = 1, #lat do
		local index = lat[i];
		hl_card(index, HL_TARGET);
	end
	for i = 1, #lab do
		local index = lab[i];
		hl_card(index,  HL_TARGET);
	end
	for i = 1, #lboth do
		local index = lboth[i];
		hl_card(index,  HL_TBOTH);
	end
end -- hl_both_target end }

function callback_attack(...) -- {
	play_tap_1();
	local arg = {...};
	-- second arg is the CCMenuItem (pressed button)
	local index = arg[2]:getTag(); 

	hl_at_target(index, 'action');

	util.trigger_tutor(TUTOR_HL_ATTARGET);
end -- callback_attack }

function callback_ability(...)  -- start {
	play_tap_1();
	local arg = {...};
	-- second arg is the CCMenuItem (pressed button)
	local index = arg[2]:getTag();   
	---print('DEBUG callback_ability');
	hl_ab_target(index, 'action');
end -- callback_ability end }

--function show_select_grave(select_side)
function open_grave(select_side)
	select_side = select_side or 0;
	if nil == g_src_index then
		--print('ERROR show_select_grave g_src_index is nil');
		if 0 ~= select_side then
			local list = g_ui_table[select_side][T_GRAVE];
			if 0 == #list then
				return;
			end
			g_scene:add_layer(ZORDER_LAYER_GRAVE, layer_grave:create(list));
		end
		return;
	end
	local src_side = index_side(g_src_index);
	if 0 ~= select_side and src_side ~= select_side then
		local list = g_ui_table[select_side][T_GRAVE];
		if 0 == #list then
			return;
		end
		g_scene:add_layer(ZORDER_LAYER_GRAVE, layer_grave:create(list));
		return;
	end
	local num;
	local err;
	num, err = total_target(g_src_index, g_logic_table, g_current_side)
	local ability_target_indexs = list_ability_target(g_src_index, g_logic_table, g_current_side, layer_card.ability_target_list, #layer_card.ability_target_list + 1);
	local is_grave = false;
	local grave_side = 0;
	for i = 1, #ability_target_indexs do
		local card_index = ability_target_indexs[i];
		local card_table_index = index_table_num(card_index);
		if card_table_index == T_GRAVE then
			grave_side = index_side(card_index);
			is_grave = true;
			break;
		end
	end
	if true == is_grave then
		local list = g_ui_table[grave_side][T_GRAVE];
		if 0 == #list then
			return;
		end
		g_scene:add_layer(ZORDER_LAYER_GRAVE, layer_grave:create(list));
		return;
	end
	if 0 ~= select_side then
		local list = g_ui_table[select_side][T_GRAVE];
		if 0 == #list then
			return;
		end
		g_scene:add_layer(ZORDER_LAYER_GRAVE, layer_grave:create(list));
		return;
	end
end

function callback_open_grave()
	open_grave();
end

function do_action_t(self, src_index, target_index)
	local cmd = 't ' .. src_index .. ' ' .. target_index;
	play_game_cmd(cmd, target_index);
	return;
end

function do_action_b(self, src_index, target_index)
	if target_index <= 0 then
		kerror("action_target target_index[%d]", target_index);
		refresh_layer_card();
		return;
	end
	
	self.ability_target_list[#self.ability_target_list + 1] = target_index;
	
	local ability_target_indexs = list_ability_target(src_index, g_logic_table, g_current_side, self.ability_target_list, #self.ability_target_list + 1);

	if 0 == #(ability_target_indexs or {}) then
		self:clean_menu();

		local cmd = 'b ' .. src_index ;
		for i=1, #self.ability_target_list do
			cmd = cmd .. ' ' .. self.ability_target_list[i];
		end
		play_game_cmd(cmd, target_index);

		return;

	end

	-- implicit:  the ability is not yet played, 
	--            let user select more target(s)
	-- if optional target is there, create a done button, 
	--             together with cancel button

	-- is for drag move e.g card 74
	create_btn_cancel();
	
	-- show button done, check optional
	local src_card = index_card(src_index, g_logic_table);
	if src_card ~= nil and src_card.target_list ~= nil 
		and #(src_card.target_list) > #self.ability_target_list then

		local target = src_card.target_list[#self.ability_target_list + 1];
		
		if true == target.optional then
			create_btn_confirm();
		end
	end
	

	-- note: do not use eff_list ~= nil to check whether a play() is done
	layer_action:close( {  } );  
	remove_hl();
	for i = 1, #ability_target_indexs do
		local card_index = ability_target_indexs[i];
		hl_card(card_index, HL_TARGET);
	end
	local num, err = total_target(src_index, g_logic_table, g_current_side);
	if num > 1 then
		local choose_num = #(self.ability_target_list or {});
		show_msg(string.format("还可以选择%d个目标", num-choose_num));
	end
end

function do_action_pick(self, src_index, target_index)
	local cinfo = get_ui_card(target_index);
	if nil == cinfo then
		return false;
	end
	local layer = layer_action:create(cinfo);
	g_scene:add_layer(ZORDER_LAYER_ACTION, layer);
	return true;
end

-- is_action == true means to do realy t or b action but not show the choice
function handle_action_both_target(self, src_index, target_index, is_action)
	local lat, lab, lboth;
	if true == is_action then
		lat, lab = get_both_target_list(self, src_index, true);
		lboth = {};
	else
		lat, lab, lboth = get_both_target_list(self, src_index);
	end

	for i = 1, #lat do
		local index = lat[i];
		if index == target_index then
			do_action_t(self, src_index, target_index);
			return true;
		end
	end
	for i = 1, #lab do
		local index = lab[i];
		if index == target_index then
			do_action_b(self, src_index, target_index);
			return true;
		end
	end
	for i = 1, #lboth do
		local index = lboth[i];
		if index == target_index then
			return do_action_pick(self, src_index, target_index);
		end
	end
	return false;
end

-- drag -> touch_end -> action_target ->
-- if is TYPE_BOTH -> handle_action_both_target ->
-- lat -> do_action_t / lab -> do_action_b / lboth -> do_action_pick
-- do_action_pick -> show 'attack target' and 'ability target'
-- set these two's callback method to callback_target_both
-- and set is_action = true for action_target to avoid 
-- dead loop that go into action_target again
function action_target(self, action_type, src_index, target_index, is_action)
	if action_type == TYPE_BOTH then
		return handle_action_both_target(self, src_index, target_index,is_action);
	
	elseif action_type == TYPE_ATTACK then
		do_action_t(self, src_index, target_index);
		return true;
		
	elseif action_type == TYPE_ABILITY then
		do_action_b(self, src_index, target_index);

		-- here return true , is for drag card action
		-- tell caller that should scale back the src_card and target card
		return true;
	end
	
	kerror("action_target is not legal action_type[%d]", action_type);
	return false;
end

function callback_target(...) -- {
	play_tap_1();
	local self = layer_card;
	local arg = {...};
	local target_card_index = arg[2]:getTag();
	action_target(self, g_action_type, g_src_index, target_card_index);
end -- callback_target }

function callback_target_b(...)
	local self = layer_card;
	local arg = {...};
	local target_card_index = arg[2]:getTag();
	action_target(self, TYPE_ABILITY,g_src_index,target_card_index,true);
end

-- use callback_target_t, callback_target_t directly
function callback_target_both(...) -- {
	local self = layer_card;
	local arg = {...};
	local target_card_index = arg[2]:getTag();
	action_target(self, g_action_type,g_src_index,target_card_index,true);
end -- callback_target }

function callback_target_t(...)
	local self = layer_card;
	local arg = {...};
	local target_card_index = arg[2]:getTag();
	action_target(self, TYPE_ATTACK,g_src_index,target_card_index,true);
end

function action_sac(index)
	local cmd = 's ' .. index;
	play_game_cmd(cmd, index);
end

function callback_sac(...) -- {
	play_tap_1();
	local index = nil;
	local arg = {...};
	index = arg[2]:getTag();   -- second arg is the CCMenuItem (pressed button)
	-- layer : CCMenu : CCMenuItem
	local self = arg[2]:getParent(); -- cc.Layer or CCMenu?  not layer_action
	action_sac(index);
	return;
end -- callback_sac }

function remove_child_by_tag(layer, tag)
	if nil == layer then
		return;
	end
	-- just will have one hl in a time in layer
	local sprite = layer:getChildByTag(tag);
	if sprite ~= nil then
		layer:removeChildByTag(tag, true);
	end
end

function remove_hl()
	for i = 1, #g_all_card_list do
		local card_lists = g_all_card_list[i];
		for j = 1, #card_lists do
			local card_info = card_lists[j];
			if nil ~= g_sprite_cache[card_info.card] then
				local card_sprite = card_info.sprite;
				remove_child_by_tag(card_sprite, TAG_HIGHLIGHT);
			end
		end
	end
	remove_child_by_tag(layer_card.layer, TAG_HIGHLIGHT);
end

function ctype_to_str(ctype)
	if ABILITY == ctype then
		return '技能';
	elseif SUPPORT == ctype then
		return '支援';
	elseif WEAPON == ctype then
		return '武器';
	elseif ARMOR == ctype then
		return '防具';
	elseif ATTACH == ctype then
		return '附加';
	elseif ALLY == ctype then
		return '盟军';
	elseif HERO == ctype then
		return '英雄';
	elseif ARTIFACT == ctype then
		return '神器';
	else
		return '未知';
	end
end

function job_name(job_id)
	job_id = tonumber(job_id) or 0;
	local name = '';
	if 0 == job_id then
		return name;
	end
	local max = 512;
	name = name .. '[';

	local first = true;
	for i=1, 10 do
		if job_id >= max then
			local job_str = job_map[max] or ('_' .. max .. '_');
			if first then
				name = name .. job_str;
				first = false;
			else
				name = name .. ' ' .. job_str;
			end
			job_id = job_id - max;
		end
		max = max / 2;
	end
	name = name .. ']';
	return name;
end

function disable_touch()
	--layer_loading:add_anim_loading();
	g_touchable = g_touchable + 1;
	--print('g_touchable + 1 : ', g_touchable);
end

function force_enable_touch()
	g_touchable = 0;
end

function enable_touch()
	--layer_loading:remove_anim_loading();
	if 0 == g_touchable then
		return;
	end
	g_touchable = g_touchable - 1;
	--print('g_touchable - 1 : ', g_touchable);
end

function is_touchable()
	if 0 == g_touchable then
		return true;
	end
	return false;
end

function reset_touchable()
	g_touchable = 0;
end

function get_card_scale(width, height, size)
	local cwidth = size.width;
	local cheight = size.height;
	local swidth = width / cwidth;
	local sheight = height / cheight;
	local scale;
	if swidth < sheight then
		scale = swidth;
	else
		scale = sheight;
	end
	return scale;
end

-- change game step
function change_step(step)
	g_step = step;
end

-- judge current step is this or not
function is_step(step)
	if g_step == step then
		return true;
	else
		return false;
	end
end

function is_target_just_myself(index, logic_table, current_side)
	if nil == index then
		return false;
	end
	local ab_list = {};
	local tindexs = list_ability_target(index, logic_table, current_side, ab_list, #ab_list + 1);
	if 1 == #(tindexs or {}) then
		local t = tindexs[1];
		if t == index then
			return true;
		end
	end
	return false;
end

function is_target_attach_hero(index, logic_table, current_side)
	if nil == index then
		return nil;
	end
	local src_card = index_card(index, logic_table);	
	if ATTACH ~= src_card.ctype then
		return nil;
	end
	local ab_list = {};
	local tindexs = list_ability_target(index, logic_table, current_side, ab_list, #ab_list + 1);
	if 1 ~= #(tindexs or {}) then
		return nil;
	end
	local tindex = tindexs[1];
	local tar_card = index_card(tindex, logic_table);	
	if HERO ~= tar_card.ctype then
		return nil;
	end
	return tindex;
end

function create_btn_confirm()
	local self = layer_card;
	if nil == self.layer then
		return;
	end
	self:change_btn(self.btn_confirm);
end

function create_btn_cancel()
	local self = layer_card;
	if nil == self.layer then
		return;
	end
	self:change_btn(self.btn_cancel);
end

function pop_turn(myside, current_side)
	local layer = layer_touch.layer;
	local path = util.get_path('pop_up.png');
	local frect = cc.rect(0, 0, 64, 64); -- fullrect
	local irect = cc.rect(30, 30, 4, 4); -- insetrect
	local size = cc.size(wfix(305), hfix(116));--realsize
	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
	local sprite = util.add_scale9sprite(layer, path, pos, ANCHOR_CENTER_CENTER, frect, irect, size, 10); 
	local str;
	if myside == current_side then
		str = '我方回合';
	else
		str = '敌方回合';
	end
	util.add_labeloutline(sprite, str, nil, 30, cc.p(size.width/2, size.height/2), util.c4b_black, util.c4b_white, 2, ANCHOR_CENTER_CENTER, 10, cc.size(size.width-40, size.height-30), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);

	local animation = {};
	local action;
	action = cc.FadeTo:create(1, 200);
	table.insert(animation, action);
	action = cc.CallFunc:create(callback_remove_sprite);
	table.insert(animation, action);

	action = cc.Sequence:create(animation);

	sprite:runAction(action);
end

function pop_gate_count(tip)
	local layer = layer_touch.layer;
	local path = util.get_path('pop_up.png');
	local frect = cc.rect(0, 0, 64, 64); -- fullrect
	local irect = cc.rect(30, 30, 4, 4); -- insetrect
	local size = cc.size(wfix(350), hfix(116));--realsize
	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT/2*3);
	local sprite = util.add_scale9sprite(layer, path, pos, ANCHOR_CENTER_CENTER, frect, irect, size, 10); 
	--util.add_labeloutline(sprite, tip, nil, 22, cc.p(size.width/2, size.height/2), util.c4b_black, util.c4b_white, 2, ANCHOR_CENTER_CENTER, 10, cc.size(size.width-40, size.height-30), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
	util.add_labelttf(sprite, tip, nil, 22, cc.p(size.width/2, size.height/2), util.c4b_white, ANCHOR_CENTER_CENTER, 10, cc.size(size.width-40, size.height-30), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);

	local animation = {};
	local action;
	action = cc.FadeTo:create(1.5, 200);
	table.insert(animation, action);
	action = cc.CallFunc:create(callback_remove_sprite);
	table.insert(animation, action);

	action = cc.Sequence:create(animation);

	sprite:runAction(action);
end

function pop_phase(phase)
	if true == g_is_in_tutor then
		return;
	end
	local layer = layer_touch.layer;
	local path = util.get_path('pop_up.png');
	local frect = cc.rect(0, 0, 64, 64); -- fullrect
	local irect = cc.rect(30, 30, 4, 4); -- insetrect
	local size = cc.size(wfix(305), hfix(116));--realsize
	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT-hfix(140));
	local sprite = util.add_scale9sprite(layer, path, pos, ANCHOR_CENTER_CENTER, frect, irect, size, 10); 
	local str;
	if phase == PHASE_SACRIFICE then
		str = '弃牌阶段';
	else
		str = '出牌阶段';
	end
	util.add_labeloutline(sprite, str, nil, 30, cc.p(size.width/2, size.height/2), util.c4b_black, util.c4b_white, 2, ANCHOR_CENTER_CENTER, 10, cc.size(size.width-40, size.height-30), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);

	local animation = {};
	local action;
	action = cc.FadeTo:create(2, 200);
	table.insert(animation, action);
	action = cc.CallFunc:create(callback_remove_sprite);
	table.insert(animation, action);

	action = cc.Sequence:create(animation);

	sprite:runAction(action);
end

function clone_card_by_id(card_id)
	local card = nil;
	if 1 > card_id then
		return card;
	end
	local rc = g_card_list[card_id];
	if nil == rc then
		rc = hero_list[card_id];
	end
	if nil ~= rc then
		-- in layer_deck 
		-- when using g_euser.deck_array
		-- will clone the cards again in order to avoid mixup the card
		card = clone(rc);	
	end
	return card;
end

-- drop down
function eff_layer_1(layer, callback)
	-- TODO need disable and enable touch 
	local x, y, opos, npos;
	local action, array;
	x = layer:getPositionX();
	y = layer:getPositionY();
	opos = cc.p(x, y);
	npos = cc.p(x, y + HALF_HEIGHT/3);
	layer:setPosition(npos);

	array = {};
	npos = cc.p(x, y - hfix(10));
	action = cc.MoveTo:create(0.3, npos);
	action = cc.EaseOut:create(action, 0.3);
	table.insert(array, action);
	action = cc.JumpTo:create(0.3, opos, hfix(10), 1);
	table.insert(array, action);
	if nil ~= callback then
		action = cc.CallFunc:create(callback);
		table.insert(array, action);
	end
	action = cc.Sequence:create(array);
	layer:runAction(action);
end

-- pull up
function eff_layer_2(layer, callback)
	-- TODO need disable and enable touch 
	local x, y, opos, npos;
	local action, array;
	x = layer:getPositionX();
	y = layer:getPositionY();
	opos = cc.p(x, y);
	npos = cc.p(x, y + HALF_HEIGHT/3);

	array = {};
	action = cc.JumpTo:create(0.3, opos, hfix(-10), 1);
	table.insert(array, action);
	action = cc.MoveTo:create(0.3, npos);
	action = cc.EaseOut:create(action, 0.3);
	table.insert(array, action);
	if nil ~= callback then
		action = cc.CallFunc:create(callback);
		table.insert(array, action);
	end
	action = cc.Sequence:create(array);
	layer:runAction(action);
end

function suit_scale_big_frame(layer, ltype, callback_return)
	local sprite, fullpath, pos, data, table_view_gapy;
	local data = gui_get_data('bg', ltype, ANCHOR_CENTER);
	pos = cc.p(0, 0);
	fullpath = util.get_fullpath(F_IMAGE, data.fname1);
	local fullrect = cc.rect(0, 0, 617, 873);
	local insetrect = cc.rect(300, 600, 17, 20);
	size = cc.size(FULL_WIDTH, data.y + data.height);
	sprite = util.add_scale9sprite(layer, fullpath, pos, ANCHOR_LEFT_DOWN, fullrect, insetrect, size, data.zorder); 
	table_view_gapy = size.height - data.height;

	local data2;
	sprite, data2 = gui_add_sprite(layer, 'right_up', ltype,ANCHOR_CENTER);
	local gapx, gapy;
	gapx = data.x + data.width - data2.x;
	gapy = data.y + data.height - data2.y;
	sprite:setPosition(cc.p(pos.x+size.width-gapx, pos.y+size.height-gapy));

	local items = {};
	local item;

	item, data2 = gui_add_item(items, 'return', ltype, callback_return, ANCHOR_CENTER);
	gapx = data.x + data.width - data2.x;
	gapy = data.y + data.height - data2.y;
	item:setPosition(ccp(pos.x+size.width-gapx, pos.y+size.height-gapy));

	util.add_menu(layer, items, data2.zorder);

	return table_view_gapy;
end

function add_big_frame_title(layer, title, ltype, anchorpoint)
	local data = gui_get_data('title', ltype, anchorpoint);
	local pos = cc.p(data.x, data.y);
	local size = cc.size(data.width, data.height);
	util.add_labeloutline(layer, title, nil, 30, pos, util.c4b_white, util.c4b_black, 2, ANCHOR_LEFT_DOWN, data.zorder, size, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_TOP);
end

function move_tvh(sprite, tvh)
	if nil == sprite then return; end
	local y = sprite:getPositionY();
	sprite:setPositionY(y + tvh);
end

function get_signature(signature)
	if nil == signature or '_no_signature' == signature then
		return '';
	end
	return signature;
end

function use_frames(filename, folder)
	if true == USE_FRAME then
		folder = folder or F_IMAGE;
		local fullpath = util.get_fullpath(folder, filename);
		util.add_frames(fullpath);
	end
end

function exit_game()
	--[[
	if is_ver(VER_UCSDK) then
		UCSdkHandler:destroyFloatButton();
		UCSdkHandler:exitSDK();
		return;
	end
	]]--
	if true ~= v_anysdk_init_flag and (is_ver(VER_ANYSDK) or is_ver(VER_ANYSDK_NO_LOGIN)) then
		local agent = AgentManager:getInstance();
		-- both below is ok
		agent:unloadALLPlugin();
		--AgentManager:endManager();
	end
	local platform = cc.Application:getInstance():getTargetPlatform();
	if platform == cc.PLATFORM_OS_ANDROID then
		local luaj = require "luaj";
		local class_name = "org/cocos2dx/lua/AppActivity";
		local ok, ret = luaj.callStaticMethod(class_name, "exitGame", {}, "()V");
		--[[
		if ok then
		end
		]]--
	end
end

function logout()
	g_scene:close_connect();
	g_scene:login();
	if is_ver(VER_ANYSDK) then
		local agent = AgentManager:getInstance();
		local user_plugin = agent:getUserPlugin();
		if user_plugin ~= nil then
			if user_plugin:isFunctionSupported("logout") then
				user_plugin:callFuncWithParam("logout");
			end
		end
	end
	if is_ver(VER_UCSDK) then
		UCSdkHandler:logout();
	end
	if is_ver(VER_LJSDK) then
		if nil ~= layer_net.layer then
--			LJSdkImpl:setUserListener(layer_net.layer);
			LJSdkImpl:logout("logout");
		end
	end
end

function get_hour_offset(t1, t2)
	local t_offset = math.floor(math.abs(t2 - t1) / 60 / 60);
	return t_offset;
end

function get_guild_title(gpos)
	if gpos == GUILD_POS_MASTER then
		-- '会长';
		return '会长';
	elseif gpos == GUILD_POS_SENIOR then
		-- '副会长';
		return '副会长';
	elseif gpos == GUILD_POS_MEMBER then
		-- '会员';
		return '会员';
	elseif gpos == GUILD_POS_APPLY then
		-- '申请者';
		return '申请者';
	end
	return '';
end

function get_guild_title_path(gpos)
	local fname = nil;
	if gpos == GUILD_POS_MASTER then
		-- '会长';
		fname = 'text_3.png';
	elseif gpos == GUILD_POS_SENIOR then
		-- '副会长';
		fname = 'text_33.png';
	elseif gpos == GUILD_POS_MEMBER then
		-- '会员';
		fname = 'text_4.png';
	elseif gpos == GUILD_POS_APPLY then
		-- '申请者';
		fname = 'text_32.png';
	end
	if nil == fname then
		return nil;
	end
	local path = util.get_fullpath(F_IMAGE, fname);
	return path;
end

function get_match_status(status)
	if 0 == status then
		return '接受申请';
	elseif 1 == status then
		return '回合开始';
	elseif 2 == status then
		return '回合结束';
	elseif 3 == status then
		return '比赛结束';
	elseif 9 == status then
		return '比赛不存在';
	end
	local s = '未知比赛状态 ' .. status;
	return s;
end

function update_attachment_timer(sprite, card)
	if nil == card.vtype or 0 == card.vtype then
		return;
	end
	local timer = card.timer or 0;
	local label = sprite:getChildByTag(TAG_SPRITE_TIMER);
	if nil ~= label and 0 == timer then
		label:removeFromParentAndCleanup(true);
		return;
	end
	if nil == label then
		if timer < 2 then
			return;
		end
		local path = util.get_path(FNT_CARD);
		--[[
		local size = sprite:getContentSize();
		--local pos = cc.p(size.width/2, size.height/2);
		--local ap = ANCHOR_CENTER_CENTER;
		local csize = CARD_SIZE_2;
		local ap = ANCHOR_RIGHT_UP;
		local pos = cc.p((size.width+csize.width)/2,(size.height+csize.height)/2);
		]]--
		local pos = cc.p(0, 0);
		local ap = ANCHOR_CENTER_CENTER;
		label = util.add_labelbmf(sprite, timer, path, pos, ap, 5);
		label:setTag(TAG_SPRITE_TIMER);
	else
		local otimer = label:getString();
		if tonumber(otimer) ~= timer then
			label:setString(timer);
			--print('------------------- set timer');
		end
	end
	return label;
end

function create_virtual_particle(parent, vtype)
	vtype = vtype or 0;
	local pname = nil;
	if 1 == vtype then
		pname = 'v_ablaze_1';
	elseif 4 == vtype then
		pname = 'v_poison_1';
	else
		return;
	end
	local filename = pname .. '.plist';
	local fullpath = util.get_fullpath(F_PARTICLE, filename);   
	local size = parent:getContentSize();
	local pos = cc.p(size.width/2, 20);
	local info  = util.add_particle(parent, fullpath, pos);
	info.batch:setTag(TAG_VIRTUAL_PARTICLE);
	local emitter = info.emitter;
	local p1 = emitter:getPosVar();
	local p2 = cc.p(size.width/4, p1.y);
	emitter:setPosVar(p2);
end

function refresh_card_status(sprite, card, width, height)
	local ci = cindex(card);
	if index_table_num(ci) == T_ALLY then
		--print(' card status ready: ', card.name, card.ready);
		-- read 0 not ready, 
		local ready = card.ready;
		local s = sprite:getChildByTag(TAG_SPRITE_SLEEP);
		if 0 == ready then
			if nil == s then
				s = util.play_frame(sprite, 's_sleep', cc.p(width, height), ANCHOR_RIGHT_UP, 0.3, 30, true);
				s:setTag(TAG_SPRITE_SLEEP);
			end
		else
			if nil ~= s then
				s:removeFromParentAndCleanup(true);
			end
		end
	end
end

function check_hl_in_list(list)
	local info = nil;
	for i = 1, #list do
		local ccc = list[i];
		local s = ccc:get_sprite();
		local h = s:getChildByTag(TAG_HIGHLIGHT);
		if nil ~= h then
			info = ccc;
			break;
		end
	end
	return info;
end

function is_show_tip_btn()
	--[[
	if g_euser.level <= 5 then
		return true;
	end
	return false;
	]]--
	return true;
end

function set_value_for_g_tutor(value)
	g_tutor = tonumber(value) or 0;
	if true == USE_TIP_TUTOR and 0 == g_tutor then
		g_tutor = util.bit_not(0);
	end
end

function pop_invite_fight(eid)
	local cmd = string.format("challenge 0 %d", eid);
	net_send(cmd);
	local s = '等待对方回应';
	g_scene:add_layer(ZORDER_LAYER_FIGHT,layer_fight:create(s, layer_fight.TIP_TYPE_INVITE_FIGHT, {eid=eid}));
end

function pop_answer_fight(eid, alias)
	local s = alias .. '向你挑战';
	g_scene:add_layer(ZORDER_LAYER_FIGHT,layer_fight:create(s, layer_fight.TIP_TYPE_ANSWER_FIGHT, {eid=eid, alias=alias}));
end

function play_tap_1()
	local path = util.get_fullpath(F_MUSIC, 'tap_1.mp3');
	util.play_effect(path);
end

function play_tap_2()
	local path = util.get_fullpath(F_MUSIC, 'tap_2.mp3');
	util.play_effect(path);
end

function play_tap_3()
	local path = util.get_fullpath(F_MUSIC, 'tap_3.mp3');
	util.play_effect(path);
end

function play_turn_card()
	local path = util.get_fullpath(F_MUSIC, 'turn_card.mp3');
	util.play_effect(path);
end

function get_client_version()
	local c1 = math.floor(CLIENT_VERSION/10000);
	local c2 = CLIENT_VERSION%10000;
	local cv = c1 .. '.' .. c2;
	local c3 = cc.UserDefault:getInstance():getIntegerForKey(KEY_PATCH_INDEX);
	local str = t_lang("CLIENT_VER") .. ':' .. cv .. '.' .. GAME_VERSION .. '_' .. LOGIC_VERSION .. '.' .. c3;
	--[[
	if is_ver(VER_ANYSDK) or is_ver(VER_ANYSDK_NO_LOGIN) then
		local f = AgentManager:getInstance():getFrameworkVersion() or '';
		if f ~= '' then
			str = f .. '\n' .. str;
		end
	end
	]]--
	return str;
end

function is_wait_for_battle()
	if nil ~= layer_quick.layer then
		return 1;
	end
	if nil ~= layer_room.layer then
		return 2;
	end
	return 0;
end

function show_mission_list()
	local btn_mission = layer_chat.btn_mission;
	if nil ~= btn_mission
	and nil ~= btn_mission:getChildByTag(TAG_MISSION_FINGER) then
		btn_mission:removeChildByTag(TAG_MISSION_FINGER, true);
		--print("remove btn_mission_finger");
	end
	--print("show mission list");
	local layer, name = layer_mission:create();
	g_scene:add_layer(ZORDER_LAYER_MISSION, layer, name, true);
	net_send('mlist 0', true);
end

function show_notice()
	local layer, name = layer_notice:create();
	g_scene:add_layer(ZORDER_LAYER_NOTICE, layer, name, true);
	net_send('notice 0', true);
end

function show_match()
	local layer, name = layer_lmatch:create();
	g_scene:add_layer(ZORDER_LAYER_LMATCH, layer, name, true);
	net_send('lmatch', true);
end

function show_prank()
	g_scene:prank();
end

function add_custom_item(items, unsprite, sprite, pos, anchorpoint, callback, title, font, fsize)
	local item = util.create_item_sprite(unsprite, sprite, pos, anchorpoint, callback);
	table.insert(items, item);
	if nil == title then
		return item;
	end
	local size = item:getContentSize();
	local label = util.add_labelttf(item, title, nil, fsize, cc.p(size.width/2, size.height/2), cc.c4b(45, 22, 7, 255), ANCHOR_CENTER_CENTER, 10, size, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
	label:setTag(TAG_SPRITE_LABEL);
	return item;
end

function add_item_1(items, title, font, fsize, callback, anchorpoint, pos, size)
	local fname1 = 'button.png';
	local fname2 = 'button_s.png';
	local frect = cc.rect(0, 0, 80, 64); -- fullrect
	local irect = cc.rect(38, 30, 4, 4); -- insetrect
	size = size or cc.size(150, 80); -- realsize
	local path1 = util.get_path(fname1);
	local path2 = util.get_path(fname2);
	local unsprite = util.create_scale9sprite(path1,frect,irect,size);
	local sprite = util.create_scale9sprite(path2,frect,irect,size);
	return add_custom_item(items, unsprite, sprite, pos, anchorpoint, callback, title, font, fsize)
end

function add_toggle_1(items, callback, anchorpoint, pos, size)
	local fname1 = 'checkbox_1.png';
	local fname2 = 'checkbox_1_s.png';
	local path1 = util.get_path('checkbox_1.png');
	local path2 = util.get_path('checkbox_1_s.png');
	local unsprite = util.create_sprite(path1);
	local sprite = util.create_sprite(path2);
	local item = util.create_toggle_sprite(unsprite,sprite,pos,anchorpoint,callback);
	table.insert(items, item);
	return item;
end

function add_item_close(items, pos, anchorpoint, callback)
	local fname1 = 'exit.png';
	local fname2 = 'exit_s.png';
	local path1 = util.get_path(fname1);
	local path2 = util.get_path(fname2);
	local unsprite = util.create_sprite(path1);
	local sprite = util.create_sprite(path2);
	return add_custom_item(items, unsprite, sprite, pos, anchorpoint, callback);
end

function add_title_1(layer, data, title)
	local fsize = 30;
	local color = cc.c4b(data.r, data.g, data.b, 255);
	local scolor = cc.c4b(data.sr, data.sg, data.sb, 255);
	local pos = cc.p(data.width/2, data.height/3*2);
	local label = util.add_labeloutline(layer, title, nil, fsize, pos, color, scolor, 2, ANCHOR_CENTER_CENTER, 10);
	return label;
end

function add_item_back_1(layer, ltype, callback)
	if nil == layer then return; end
	gui_add_sprite(layer, 'bg_back', ltype, ANCHOR_UP);
	local items = {};
	local item, data = gui_add_item(items, 'btn_back', ltype, callback,ANCHOR_UP);
	util.add_menu(layer, items, data.zorder);
	return item;
end

function add_editbox_1(layer, pos, size, tip, zorder, handler, fsize)
	local fullrect = cc.rect(0, 0, 64, 56);
	local insetrect = cc.rect(30, 26, 4, 4);
	local s = cc.size(size.width, size.height);
	local p = cc.p(pos.x, pos.y);
	local path = util.get_path('title_popup.png');
	local sprite = util.add_scale9sprite(layer, path, p, ANCHOR_LEFT_DOWN, fullrect, insetrect, s, zorder); 

	fullrect = cc.rect(0, 0, 64, 54);
	insetrect = cc.rect(30, 25, 4, 4);
	s = cc.size(s.width-36, s.height-19);
	p = cc.p(p.x+18, p.y+9);
	path = util.get_path('text_box.png');
	sprite = util.add_scale9sprite(layer, path, p, ANCHOR_LEFT_DOWN, fullrect, insetrect, s, zorder+1); 

	s = cc.size(s.width-20, size.height);
	p = cc.p(p.x+10, pos.y);
	local editbox = util.add_editbox_blank(layer, s, ANCHOR_LEFT_DOWN, 
		p, util.f_default, (fsize or 22), cc.c3b(243, 176, 80), 
		cc.EDITBOX_INPUT_MODE_SINGLELINE, cc.KEYBOARD_RETURNTYPE_DONE, 
		nil, handler, 10, tip, cc.c3b(243, 176, 80), zorder+2); 
	return editbox;
end

function init_bar_info_for_full_view(layer, cb_back, ltype)
	gui_add_sprite(layer, 'bg_infobar', ltype, ANCHOR_UP);
	gui_add_sprite(layer, 'frame_gold', ltype, ANCHOR_UP);
	gui_add_sprite(layer, 'frame_crystal', ltype, ANCHOR_UP);
	gui_add_sprite(layer, 'icon_gold', ltype, ANCHOR_UP);
	gui_add_sprite(layer, 'icon_crystal', ltype, ANCHOR_UP);

	local str = g_euser.gold;
	gui_add_label(layer,str,18,'num_gold',ltype,ANCHOR_UP);

	str = g_euser.crystal;
	gui_add_label(layer,str,18,'num_crystal',ltype,ANCHOR_UP);

	gui_add_sprite(layer, 'bg_back', ltype, ANCHOR_UP);
	local items = {};
	local item, data = gui_add_item(items,'btn_back',ltype,cb_back,ANCHOR_UP);
	util.add_menu(layer, items, data.zorder);
end

function init_bg_for_full_view(layer, ltype, title)
	gui_add_sprite(layer, 'board', ltype);
	local sprite,data = gui_add_sprite(layer, 'bg', ltype);
	if data.width/data.rwidth > data.height/data.rheight then
		sprite:setScale(data.width/data.rwidth);
	else
		sprite:setScale(data.height/data.rheight);
	end
	gui_add_sprite(layer, 'bg_2', ltype);
	gui_add_sprite(layer, 'f_left_up', ltype, ANCHOR_UP);
	gui_add_sprite(layer, 'f_right_up', ltype, ANCHOR_UP);
	gui_add_sprite(layer, 'bg_title', ltype, ANCHOR_UP);
	gui_add_label_ali(layer, title, 28, 'title', ltype, ANCHOR_UP, cc.TEXT_ALIGNMENT_CENTER);
end

function init_bg_for_view(layer, ltype, title, cb_back)
	local d1 = gui_get_data('bg', ltype, ANCHOR_DOWN);
	local d2 = gui_get_data('bg', ltype, ANCHOR_UP);
	local offsetheight = d2.y-d1.y;
	local sprite, data;
	sprite, data = gui_add_sprite(layer,'bg',ltype,ANCHOR_DOWN,nil,offsetheight);
	local rect = {
		x1 = data.x, x2 = data.x + data.width,
		y1 = data.y, y2 = data.y + data.height,
	};
	gui_add_sprite(layer, 'bg_title', ltype, ANCHOR_UP);
	gui_add_label_ali(layer,title,30,'title',ltype, ANCHOR_UP, cc.TEXT_ALIGNMENT_CENTER);
	local items = {};
	local item;
	item, data = gui_add_item(items, 'btn_back', ltype, cb_back, ANCHOR_UP);
	util.add_menu(layer, items, data.zorder);
	return offsetheight, sprite, rect;
end

function init_bg_for_popview(layer, title, bgsize, cb_close)
	local path = util.get_path('pop_up.png');
	local frect = cc.rect(0, 0, 64, 64); -- fullrect
	local irect = cc.rect(30, 30, 4, 4); -- insetrect
	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
	local bg = util.add_scale9sprite(layer, path, pos, ANCHOR_CENTER_CENTER, frect, irect, bgsize, 10); 
	local bg_rect = { x1 = pos.x - bgsize.width/2, x2 = pos.x + bgsize.width/2,
					  y1 = pos.y - bgsize.height/2, y2 = pos.y + bgsize.height/2};

	path = util.get_path('popup_title.png');
	frect = cc.rect(0, 0, 64, 55); -- fullrect
	irect = cc.rect(30, 25, 4, 5); -- insetrect
	local barsize = cc.size(bgsize.width-50, 60); -- realsize
	pos = cc.p(bgsize.width/2, bgsize.height - 50);
	local bar = util.add_scale9sprite(bg, path, pos, ANCHOR_CENTER_CENTER, frect, irect, barsize, 10); 
	pos = cc.p(barsize.width/2, barsize.height/2);
	util.add_labelttf(bar, title, nil, 30, pos, cc.c4b(68, 37, 16, 255), ANCHOR_CENTER_CENTER, 10);

	local items = {};
	local item;

	pos = cc.p(bgsize.width-20, bgsize.height-20);
	add_item_close(items, pos, ANCHOR_CENTER_CENTER, cb_close);

	util.add_menu(bg, items, 20);
	
	return bg, bg_rect;
end

function add_icon_gold(layer, pos, anchorpoint, zorder, scale)
	local path = util.get_path('gold.png');
	local sprite = util.add_sprite(layer, path, pos, anchorpoint, zorder);
	sprite:setScale(scale or 1);
	return sprite;
end

function add_font_1(layer, text, pos, anchorpoint, zorder, scale)
	local path = util.get_path(FNT_1);
	local label = util.add_labelbmf(layer, text, path, pos, anchorpoint, zorder);
	label:setScale(scale or 1);
	return label;
end

function add_line_1(layer, pos, anchorpoint, zorder, width)
	local path = util.get_path('line_1.png');
	local sprite = util.add_sprite(layer, path, pos, anchorpoint, zorder);
	sprite:setScaleX(width/sprite:getContentSize().width);
	return sprite;
end

function add_line_2(layer, pos, anchorpoint, zorder, width)
	local path = util.get_path('line_2.png');
	local sprite = util.add_sprite(layer, path, pos, anchorpoint, zorder);
	sprite:setScaleX(width/sprite:getContentSize().width);
	return sprite;
end

function add_status_eff_sprite(layer, eff_id, pos, anchorpoint, scale, zorder)
	local filename = string.format("e_%d.plist", eff_id);
	if true ~= util.check_file(filename) then
		return nil;
	end
	local path = util.get_path(filename);	
	local cache = cc.SpriteFrameCache:getInstance();
	cache:addSpriteFrames(path);
	filename = string.format("e_%d_1.png", eff_id);
	local sprite = cc.Sprite:createWithSpriteFrameName(filename);
	sprite:setPosition(pos);
	sprite:setScale(scale);
	sprite:setAnchorPoint(anchorpoint);
	layer:addChild(sprite, zorder);
	local animation = cc.Animation:create();
	local len = 0;
	filename = string.format("e_%d_%d.png", eff_id, 1);
	local frame = cache:spriteFrameByName(filename);
	repeat
		len = len + 1;
		animation:addSpriteFrame(frame);
		local filename = string.format("e_%d_%d.png", eff_id, len);
		frame = cache:spriteFrameByName(filename);
	until nil == frame;
	local pt = 0.1;
	if len > 5 then
		pt = 0.07;
	end
	animation:setDelayPerUnit(pt);
	local action = cc.RepeatForever:create(cc.Animate:create(animation));
	action:setTag(TAG_STATUS_EFF);
	sprite:runAction(action);
	return sprite;
end

function show_pop_anim(node)
	if nil == node then return; end
	local layer_color = node:getChildByTag(TAG_LAYER_COLOR);
	local size = cc.size(FULL_WIDTH, FULL_HEIGHT);
	local fscale = 0.5; -- scale from
	node:setScale(fscale);
	if nil ~= layer_color then
		local s = 1 / fscale;
		local nwidth = size.width * s;
		local nheight = size.height * s;
		layer_color:setPosition(cc.p(-(nwidth-size.width)/2, -(nheight-size.height)/2));
		layer_color:setContentSize(cc.size(nwidth, nheight));
	end
	local list = {};
	table.insert(list, cc.EaseIn:create(cc.ScaleTo:create(0.2, 1.1), 0.2));
	table.insert(list, cc.EaseOut:create(cc.ScaleTo:create(0.15, 1), 0.15));
	if nil ~= layer_color then
		local function reset_color()
			layer_color:setPosition(cc.p(0, 0));
			layer_color:setContentSize(size);
		end
		table.insert(list, cc.CallFunc:create(reset_color));
	end
	local action = cc.Sequence:create(list);
	node:runAction(action);
end

function clean_for_replay()
	cc.Director:getInstance():getScheduler():setTimeScale(1);
	layer_anim:remove();
	layer_card:remove();
	data_handler:cleanup();
	g_euser.side = nil;
	g_euser.room_data = nil;
	g_scene:map();
	g_scene:add_layer(ZORDER_LAYER_INFO, layer_info:create(g_euser));
	local eid = layer_video.eid or '';
	local cmd = 'lreplay ' .. eid;
	net_send(cmd);
end

function get_friend_list()
	local layer, name = layer_friend:create();
	g_scene:add_layer(ZORDER_LAYER_FRIEND, layer, name, true);
	local cmd = string.format("flist 0 %d", layer_friend.PAGE_SIZE);
	net_send(cmd, true);
end

function uc_submit_data(key)
	local eid = (g_euser.eid or 'eid_null') .. '';
	local alias = g_euser.alias or 'alias_null';
	local level = (g_euser.level or 'level_null') .. '';
--	local data = string.format("{\"eid\":\"%s\",\"alias\":\"%s\",\"level\":\"%s\"}", eid, alias, level);
	local data = string.format("{\"roleId\":\"%s\",\"roleName\":\"%s\",\"roleLevel\":\"%s\",\"zoneId\":\"%s\",\"zoneName\":\"%s\"}", eid, alias, level, 1, 's1正式服务器');
	UCSdkHandler:submitExtendData(key, data);
end

function ljsdk_submit_data(key)
	local data = {};
	data._id		= key;
	data.roleId		= (g_euser.eid or g_euser.lj_userid or 0) .. '';
	data.roleName	= g_euser.alias or ('决战王者' .. (g_euser.lj_userid or 0));
	data.roleLevel	= (g_euser.level or 1) .. '';
	data.zoneId		= '1';
	data.zoneName	= 's1正式服务器';
	data.balance	= (g_euser.crystal or 0) .. '';
	data.vip		= 1;
	data.partyName	= g_euser.gname or '无帮派';
	LJSdkImpl:setExtRoleData(util.get_json_str(data));
end

function show_lai()
	local layer, name = layer_solo:create();
	g_scene:add_layer(ZORDER_LAYER_SOLO, layer, name, true);
	net_send('lai', true);
end

function show_list_solo()
	local layer, name = layer_solo_plus:create();
	g_scene:add_layer(ZORDER_LAYER_SOLO_PLUS, layer, name, true);
	net_send('list_solo ' .. g_euser.solo_pos, true);
end

function show_pay_ad()
	local layer, name = layer_pay_ad:create();
	g_scene:add_layer(ZORDER_LAYER_PAY_AD, layer, name, true);
end

function show_gate()
	local layer, name = layer_gate:create();
	g_scene:add_layer(ZORDER_LAYER_GATE, layer, name, true);
	local cmd = string.format("lgate 0 %d", layer_gate.PAGE_SIZE);
	net_send(cmd, true);
end
			
function show_service()
	local layer, name = layer_service:create();
	g_scene:add_layer(ZORDER_LAYER_SERVICE, layer, name, true);
	net_send('fdata', true);
end

function get_res_number_area(side)
	local info = g_ui_table.label_res[side]
	if nil == info then
		return false;
	end
	local rdata = layer_dragtutorial.get_sprite_data(info, false);
	info = g_ui_table.label_res_max[g_euser.side];
	if nil == info then
		return false;
	end
	local rmdata = layer_dragtutorial.get_sprite_data(info, false);

	local pos = cc.p(rdata.x, rdata.y + rdata.height / 2);
	local size = cc.size(rmdata.x + rmdata.width * 4 - rdata.x, rmdata.height * 2);
	return pos, size;
end

function get_res_area(side)

	local info = g_ui_table[side][T_RES];
	local pos = cc.p(info.x, info.y);
	local size = cc.size(info.width, info.height);

	local rpos, rsize = get_res_number_area(side);
	local gap_y = 0;

	local s = g_ui_table.label_res[side];
	local y = s:getPositionY();
	local h = s:getContentSize().height * s:getScale();
	if side == SIDE_DOWN then
		gap_y = pos.y-size.height/2 - y;
		size.height = pos.y + size.height/2 - y;
		pos.y = y;
	else
		gap_y = y + h - (pos.y + size.height/2);
		size.height = size.height + gap_y;
	end
	return pos, size;
end

function get_hand_area(side)
	local info = g_ui_table[side][T_HAND];

	local c = CARD_SIZE_2;
	local pos = cc.p(info.x + info.width / 2 - c.width / 2, info.y);
	local size = cc.size(info.width, info.height);
	if (side == SIDE_DOWN) then
		size.width = size.width + HAND_GAP * 2;
	end
	return pos, size;
end

function get_ally_area(side)
	local info = g_ui_table[side][T_ALLY];

	local c = CARD_SIZE_2;
	local pos = cc.p(info.x + info.width / 2 - c.width / 2, info.y);
	local size = cc.size(info.width, info.height);
	return pos, size;
end

function get_support_area(side)
	local info = g_ui_table[side][T_SUPPORT];

	local c = CARD_SIZE_2;
	local pos = cc.p(info.x + info.width / 2 - c.width / 2, info.y);
	local size = cc.size(info.width, info.height);
	return pos, size;
end

function get_space_area(side)
	local apos, asize = get_ally_area(side)
	local spos, ssize = get_support_area(side)
	local c = CARD_SIZE_2;

	local size = cc.size(asize.width, (asize.height + ssize.height) / 2 + math.abs(spos.y - apos.y));
	local pos = cc.p(apos.x, (apos.y + spos.y) / 2);
	return pos, size;
end

function get_deck_area(side)
	local info = g_ui_table[side][T_DECK];

	local pos = cc.p(info.x, info.y);
	local size = cc.size(info.width, info.height);
	return pos, size;
end

function get_hero_area(side)
	local info = g_ui_table[side][T_HERO];

	local pos = cc.p(info.x, info.y);
	local size = cc.size(info.width, info.height);
	return pos, size;
end

function show_tutor_gate()
	if g_euser.level > 1 then return false; end
	local btn = layer_map.btn_pve;
	if nil == btn then return false; end

	local function callback()
		g_tutor_wait_net = show_tutor_do_gate;
		show_gate();
		--show_tutor_do_gate();
	end
	local fdata = layer_dragstory.get_sprite_data(btn, false);
	fdata.x = fdata.x + fdata.width/2;
	fdata.y = fdata.y + fdata.height/2;
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
	return true;
end

function show_tutor_do_gate()
	g_tutor_wait_net = nil;
	local function callback()
		local info = layer_gate.list[1];
		if nil ~= info then
			local cmd = 'gate ' .. info.gate_id;
			net_send(cmd);
		end
		return;
	end
	if nil == layer_gate.layer then return; end
	if 0 == #(layer_gate.list or {}) then return; end
	local width = layer_gate.cwidth;
	local height = layer_gate.cheight;
	local th = layer_gate.theight;
	local x, y = layer_gate.tableview:getPosition();
	local fdata = { x=x+width/2, y=y+th-height+height/2, width=width, height=height, use_circle=false };
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	local f = layer_dragstory.finger;
	if nil ~= f then
		local fxx, fyy = f:getPosition();
		f:setPosition(cc.p(fxx+width/4, fyy-height/2));
	end
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
end

function show_tutor_mission()
	if g_euser.level > 10 then return false; end
	--if nil == g_mission_tip or g_mission_tip < 1 or g_mission_tip > 3 then return; end
	local btn = layer_chat.btn_mission;
	if nil == btn then return false; end
	local fdata = layer_dragstory.get_sprite_data(btn, false);

	if g_euser.level > 4 then
		local finger = btn:getChildByTag(TAG_MISSION_FINGER);
		if nil == finger then
			local tpos = cc.p(fdata.width / 2, fdata.height / 2);
			local finger = util.play_frame(btn, 'tutor_finger', tpos, ANCHOR_LEFT_UP, 0.1, 70, true);
			finger:setTag(TAG_MISSION_FINGER);
		end
		return false;
	end

	local function callback()
		g_tutor_wait_net = show_tutor_do_mission;
		show_mission_list();
	end
	fdata.x = fdata.x + fdata.width/2;
	fdata.y = fdata.y + fdata.height/2;
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
	return true;
end

function show_tutor_do_mission()
	g_tutor_wait_net = nil;
	-- also limit under 5 in net_mlist
	if g_euser.level > 4 then return; end
	if nil == layer_mission.layer then return; end
	if 0 == #(layer_mission.list or {}) then return; end
	local function callback()
		local info = layer_mission.list[1];
		if nil == info then return; end
		if 16 ~= tonumber(info.mtype) then return; end
		if 2 == tonumber(info.status) then
			local mid = info.mid;
			net_send('mreward ' .. mid);
			return;
		end
		layer_mission:do_gate(info.p2);
	end
	local width = layer_mission.cwidth;
	local height = layer_mission.cheight;
	local th = layer_mission.theight;
	local x, y = layer_mission.tableview:getPosition();
	local fdata = { x=x+width/2, y=y+th-height+height/2, width=width, height=height, use_circle=false };
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	local f = layer_dragstory.finger;
	if nil ~= f then
		local fxx, fyy = f:getPosition();
		f:setPosition(cc.p(fxx+width/4, fyy-height/2));
	end
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
end

function go_pay()
	local layer, name = layer_pay:create();
	g_scene:add_layer(ZORDER_LAYER_PAY, layer, name, true);
	if is_ver(VER_ANYSDK) or is_ver(VER_ANYSDK_NO_LOGIN) then
		if nil == g_anysdk_plugin or false == g_anysdk_init_play then
			local iap_plugin_maps = AgentManager:getInstance():getIAPPlugin();
			for key, value in pairs(iap_plugin_maps) do
				print('key: ' .. key);
				value:setResultListener(anysdk_pay_result);
				g_anysdk_plugin = value;
				break;
			end
		end
		net_send('lpay 6');
		--[[
				local list = {};
				local l = {};
				l.pay_code = 123;
				l.pay_price = 10;
				l.money_type = 1;
				l.money = 20;
				l.title = 'test anysdk';
				l.description = 'test anysdk';
				l.a = a;
				table.insert(list, l);
				layer_pay:add_list(5, list);
		]]--
	elseif is_ver(VER_APAY) then
		net_send('lpay 4');
	elseif is_ver(VER_APPSTORE) then
		net_send('lpay 3');
	elseif is_ver(VER_UCSDK) then
		net_send('lpay 7');
	elseif is_ver(VER_LJSDK) then
		net_send('lpay 8');
	else
		net_send('lpay 1');
	end
end

function show_money_tip(tip)
	tip = tip or "资金不足";
	tip = tip .. "，点击确定进行充值";
	g_scene:add_layer(ZORDER_LAYER_TIP, layer_tip:create(tip, go_pay));
end

function show_crystal_tip()
	if true == is_vip_member(g_euser) then
		local tip = t_lang("TIP_NOT_ENOUGH_CRYSTAL");
		show_money_tip(tip);
		return;
	end
	tip = "您的水晶不足,点击确定进行充值。\n成为月卡vip会员更可获得每日赠送100水晶";
	g_scene:add_layer(ZORDER_LAYER_TIP, layer_tip:create(tip, go_pay));
end

function show_book()
	g_scene:add_layer(ZORDER_LAYER_BOOK, layer_book:create());
	g_list_shop = g_list_shop or {};
	if 0 == #g_list_shop then
		layer_book:callback_reloadlist();
	else
		if true ~= SHOP_PAGE then
			layer_book:add_to_list(g_list_shop);
		else
			layer_book:add_to_list(g_list_shop,g_list_shop[#g_list_shop].cid);
		end
	end
end

function add_scroll_icons(layer, pos, is_up)
	local anchor = (true == is_up) and ANCHOR_RIGHT_UP or ANCHOR_RIGHT_DOWN;
	local fname = 'btn_3.png';
	local path = util.get_path('btn_3.png');
	local s = util.add_sprite(layer, path, pos, anchor, 100);
	local size = s:getContentSize();
	local gap = 0;
	local sy = pos.y;
	if true == is_up then
		gap = 30;
		s:setRotation(90);
		sy = sy-size.height-gap;
	else
		gap = -30;
		s:setRotation(-90);
		sy = sy+size.height-gap;
	end
	s:setPositionY(sy);

	local x = pos.x;
	local y = sy;
	local array = {};
	table.insert(array, cc.MoveTo:create(0.8, cc.p(x, y+gap)));
	table.insert(array, cc.MoveTo:create(0.1, cc.p(x, y)));
	s:runAction(cc.RepeatForever:create(cc.Sequence:create(array)));
	return s;
end

function update_scroll_icon(icon_up, icon_down, view, table_height)
	local offset_y = view:getContentOffset().y;
	local content_height = view:getContentSize().height;
	icon_down:setVisible(false);
	icon_up:setVisible(false);
	if offset_y < 0 then
		icon_down:setVisible(true);
	end
	if table_height - content_height < offset_y then
		icon_up:setVisible(true);
	end
end

function is_vip_member(user)
	if nil == user then	return false;	end
	local cur_time = os.time();
	local end_time = user.monthly_end_date or 0;
--	print('=============================================');
--	print('cur_time:', cur_time, ' end_time:', end_time);
--	print('=============================================');
	return (end_time - cur_time > 0);
end

function show_lottery()
	local layer, name = layer_lottery:create();
	g_scene:add_layer(ZORDER_LAYER_LOTTERY, layer, name, true);
	net_send('lottery 0', true);
end

function is_view_top()
	local support_table = g_logic_table[SIDE_DOWN][T_SUPPORT];
	for i = 1, #support_table do
		local card = support_table[i];
		if card.view_top == true then
			return true;
		end
	end
	return false;
end

function is_view_oppo()
	local support_table = g_logic_table[SIDE_DOWN][T_SUPPORT];
	for i = 1, #support_table do
		local card = support_table[i];
		if card.view_oppo == true then
			return true;
		end
	end
	return false;
end

-- /////////////////////// COMMON END   ///////////////////////////

-- /////////////////////// ANYSDK START ///////////////////////////
g_anysdk_init = false;

function show_anysdk_tip(tip)
	local layer = layer_touch.layer;
	if nil == layer then return; end
	local function cb_tip()
		layer:unscheduleUpdate();
		show_msg(tip);
	end
	layer:scheduleUpdateWithPriorityLua(cb_tip, 1);
end

g_anysdk_init_action = false;
function anysdk_action_result(plugin, code, msg)
	hide_netloading();
	print('anysdk action_result code: ' .. code .. ' msg: ' .. msg);
	if code == UserActionResultCode.kInitSuccess then
		g_anysdk_init_action = true;
	elseif code == UserActionResultCode.kInitFail then
		g_anysdk_init_action = false;
		show_anysdk_tip("登录系统初始化失败");
	elseif code == UserActionResultCode.kLoginNetworkError then
		show_anysdk_tip("网络错误，登录失败");
	elseif code == UserActionResultCode.kLoginNoNeed then
	elseif code == UserActionResultCode.kLoginCancel then
	elseif code == UserActionResultCode.kLogoutFail then
		show_anysdk_tip("登出失败");
	elseif code == UserActionResultCode.kLoginFail then
		if g_scene:is_stage(STAGE_LOGIN) then
--			if 5 == code then
--			else
--				show_anysdk_tip("登录失败!\n"..msg);
--			end
			local agent = AgentManager:getInstance();
			local cid = tonumber(agent:getChannelId() or "0");
			-- 550 腾讯
			if cid == 550 and "Weixin NOT Installed" == msg then
				show_anysdk_tip('该设备尚未安装微信\n请到腾讯网下载微信最新版本');
--				show_msg('该设备尚未安装微信, 请到腾讯网下载微信最新版本');
--				return;
			else
				show_anysdk_tip("登录失败!\n"..msg);
			end
		else
			local layer = layer_touch.layer;
			if nil == layer then return; end
			local function cb()
				layer:unscheduleUpdate();
				logout();
			end
			layer:scheduleUpdateWithPriorityLua(cb, 1);
		end
	elseif code == UserActionResultCode.kAccountSwitchSuccess then
		--table.insert(g_chat_list[C_ALL], "hihihihi 999999");
		--show_anysdk_tip("切换账户:" .. msg);
		local layer = layer_touch.layer;
		if nil == layer then return; end
		local function cb()
			layer:unscheduleUpdate();
			local function parse_json_str(jstr, key)
				local p1, p2 = string.find(jstr, key);
				if nil == p1 then
					return nil;
				end
				local pstart = p2 + 4;
				local pend = pstart;
				for i = pstart, string.len(jstr) do
					local c = string.sub(jstr, i, i);
					if '"' == c then
						pend = i;
						break;
					end
				end
				if pend <= pstart then
					return nil;
				end
				local ret = string.sub(jstr, pstart, pend-1);
				return ret;
			end
			local user = AgentManager:getInstance():getUserPlugin();
			g_euser.userid = user:getUserID();
			local password = parse_json_str(msg, "password");
			local username = parse_json_str(msg, "username");
			g_euser.username = username;
			g_euser.password = password;
			net_cmd_log(username, password);
		end
		layer:scheduleUpdateWithPriorityLua(cb, 1);

	elseif code == UserActionResultCode.kLoginSuccess then
		local layer = layer_touch.layer;
		if nil == layer then return; end
		local function cb()
			local function parse_json_str(jstr, key)
				local p1, p2 = string.find(jstr, key);
				if nil == p1 then
					return nil;
				end
				local pstart = p2 + 4;
				local pend = pstart;
				for i = pstart, string.len(jstr) do
					local c = string.sub(jstr, i, i);
					if '"' == c then
						pend = i;
						break;
					end
				end
				if pend <= pstart then
					return nil;
				end
				local ret = string.sub(jstr, pstart, pend-1);
				return ret;
			end
			local password = parse_json_str(msg, "password");
			local username = parse_json_str(msg, "username");
			layer:unscheduleUpdate();
			local user = AgentManager:getInstance():getUserPlugin();
			g_euser.userid = user:getUserID();
			layer_login:cb_login_for_anysdk(username, password);
		end
		layer:scheduleUpdateWithPriorityLua(cb, 1);
	elseif code == UserActionResultCode.kAccountSwitchFail then
		show_anysdk_tip("切换账号失败");
	end
end

g_anysdk_plugin = nil;
g_anysdk_init_pay = false;
function anysdk_pay_result(code, msg, product_info)
	print('anysdk pay_result code: ' .. code .. ' msg: ' .. msg);
	if code == PayResultCode.kPayInitSuccess then
		g_anysdk_init_pay = true;	
	elseif code == PayResultCode.kPayInitFail then
		g_anysdk_init_pay = false;	
	elseif code == PayResultCode.kPayCancel then
	elseif code == PayResultCode.kPayNetworkError then
		show_anysdk_tip("网络错误，支付失败");
	elseif code == PayResultCode.kPayProductionInforIncomplete then
		show_anysdk_tip("产品信息有误，支付失败");
	elseif code == PayResultCode.kPayNowPaying then
		ProtocolIAP:resetPayState();
	elseif code == PayResultCode.kPayRechareSuccess then
		show_anysdk_tip("充值成功");
	elseif code == PayResultCode.kPaySuccess then
		show_anysdk_tip("购买成功");
	elseif code == PayResultCode.kPayFail then
		show_anysdk_tip("购买失败\n"..msg);
	end
end
-- /////////////////////// ANYSDK END   ///////////////////////////

-- /////////////////////// TUTOR START   ///////////////////////////

g_tutor_wait_net = nil;
g_is_in_tutor = nil;
story_data = nil;
story_next = nil;

function tutor_local()
	g_scene:preload(tutor_cb_fight_init, layer_preload.START, STAGE_PVE);
	return true;
end

-- ally 130x
function tutor_cb_fight_init()
	--[[
	local side = 1;
	local seed = 31197;
	local timeout = 60;
	local deck_1 = '1000000000000000000004200423040000000000000000000000000000000022102002000000000000000000000000000000000000000000000000000000000000020200000000000000000002400000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000';
	local deck_2 = '0000000100000000000000404000000000000400000000000000000000000000000000000000000000000000000000440000000000000000000000000000000000000040000000000000000000404003000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000';
	g_scene:pve(side, seed, deck_1, deck_2);
	g_is_in_tutor = true;
	story_1();
	]]--

	local side = 2;
	local my_hero = 1;
	local hero_name = "高手";
	local clist = c_str_array(g_euser.all_str);
	for i = 1, #clist do
		local card = clist[i].card;
		if card.ctype == HERO then
			my_hero = card.id;
			hero_name = card.name;
			break;
		end
	end
	local thn = "安妮";
	local t_icon = 1;
	if hero_list[15] ~= nil then
		local c = hero_list[15];
		thn = c.name;
		t_icon = c.id;
	end
	data_handler:cleanup();
	data_handler:init_side(side); 
	data_handler:init_tables();
	local info = {
		side_up = {
			hero = { 15 },
			deck = { },
			hand = { 79, 45 },
			ally = { 52, 41, 54 },
			support = { 77 },
			grave = { },
		},
		side_down = {
			hero = { my_hero },
			deck = { },
			hand = { 40 },
			ally = { 25, 35, 23, 37 },
			support = { },
			grave = { },
		},
	};
	anim.reset_data();
	logic_init_test(info);
	-- card in deck
	card_init_table(g_logic_table[1][T_DECK], { 45, 78 }, g_logic_table);
	card_init_table(g_logic_table[2][T_DECK], { 40 }, g_logic_table);
	---------------
	g_current_side = 2;
	local hp_up = g_logic_table[1][T_HERO][1].hp;
	local hp_down = g_logic_table[2][T_HERO][1].hp;
	g_logic_table[1][T_HERO][1]:change_hp(-(hp_up-9));
	g_logic_table[2][T_HERO][1]:change_hp(-(hp_down-10));
	g_logic_table[1].resource = 0;
	g_logic_table[1].resource_max = 8;
	g_logic_table[2].resource = 0;
	g_logic_table[2].resource_max = 5;
	g_is_in_tutor = true;
	g_scene:pve_do_scene(side);
	enable_btn(layer_table.btn_chat, false);
	story_data = {};
	story_data.actor = string.format("%s导师", hero_name);
	story_data.icon = my_hero;
	story_data.m_hero = hero_name;
	story_data.t_hero = thn;
	story_data.t_icon = t_icon;
	layer_card:init_wait_action(g_phase);
	story_1();
end

function story_1()
	local actor = { name = story_data.actor, icon = story_data.icon };
	local list_tip = {
		string.format("%s,欢迎你来到战场...", g_euser.alias or "朋友"),
		string.format("你选择了[%s]作为你的英雄,正在与[%s]进行作战...", story_data.m_hero or "", story_data.t_hero or ""),
		"来看看我们如何痛击对手吧!",
	};
	local function callback()
		play_game_cmd("s 0");
		play_game_cmd("t 2302 1301");
		play_game_cmd("t 2304 1301");
		play_game_cmd("t 2303 1301");
		play_game_cmd("t 2301 1101");
		story_next = story_2;
	end
	local layer, name = layer_story:create(actor, list_tip, callback);
	g_scene:add_layer(ZORDER_LAYER_STORY, layer, name);
end

function story_2()
	local actor = { name = story_data.actor, icon = story_data.icon };
	local list_tip = {
		"敌方军力已尽,只需再一回合就能取得胜利,英雄们继续向前!",
	};
	local function callback()
		play_game_cmd("n");
		play_game_cmd("s 1203");
		story_next = story_3;
	end
	local layer, name = layer_story:create(actor, list_tip, callback);
	g_scene:add_layer(ZORDER_LAYER_STORY, layer, name);
end

function story_3()
	local actor = { name = story_data.t_hero, icon = story_data.t_icon };
	local list_tip = {
		"太天真了，没那么容易让你胜利的。",
	};
	local function callback()
		play_game_cmd("b 1201 2101 2302 2303 2304");
		story_next = story_4;
	end
	local layer, name = layer_story:create(actor, list_tip, callback);
	g_scene:add_layer(ZORDER_LAYER_STORY, layer, name);
end

function story_4()
	local actor = { name = story_data.actor, icon = story_data.icon };
	local list_tip = {
		"我方英雄受到2点伤害,审判天使、九尾妖狐、扭曲树精被击杀。",
	};
	local function callback()
		play_game_cmd("b 1201");
		play_game_cmd("t 1301 2101");
		play_game_cmd("n");
		story_next = story_5;
	end
	local layer, name = layer_story:create(actor, list_tip, callback);
	g_scene:add_layer(ZORDER_LAYER_STORY, layer, name);
end

function story_5()
	local actor = { name = story_data.actor, icon = story_data.icon };
	local list_tip = {
		"敌人果然强大,但大家不要放弃。",
		"我方新兵听命,要战胜敌人,充足的资源必不可少,所以我们懂得放弃手上多余的卡牌转化为资源。",
	};
	local function callback()
		story_6();
	end
	local layer, name = layer_story:create(actor, list_tip, callback);
	g_scene:add_layer(ZORDER_LAYER_STORY, layer, name);
end

function story_6()
	local function callback()
		play_game_cmd("s 2202");
		story_next = story_7;
	end
	local info = g_ui_table[2][T_HAND][2];
	if nil == info then callback(); return; end
	local fdata = layer_dragstory.get_sprite_data(info:get_sprite(), true);
	info = g_ui_table[2][T_RES];
	if nil == info then callback(); return; end
	local tdata = { x = info.x, y = info.y, width = info.width, height = info.height, use_circle = false };
	local layer, name = layer_dragstory:create(fdata, tdata, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
end

function story_7()
	local actor = { name = story_data.actor, icon = story_data.icon };
	local list_tip = {
		"终于有足够资源召唤高级盟军,赶紧召唤潘森上场吧！",
	};
	local function callback()
		story_8();
	end
	local layer, name = layer_story:create(actor, list_tip, callback);
	g_scene:add_layer(ZORDER_LAYER_STORY, layer, name);
end

function story_8()
	local function callback()
		play_game_cmd("b 2201");
		story_next = story_9;
	end
	local info = g_ui_table[2][T_HAND][1];
	if nil == info then callback(); return; end
	local fdata = layer_dragstory.get_sprite_data(info:get_sprite(), true);
	info = g_ui_table[2][T_ALLY];
	if nil == info then callback(); return; end
	local tdata = { x = info.x+info.width/2-fdata.width/2, y = info.y, width = info.width, height = info.height, use_circle = false };
	local layer, name = layer_dragstory:create(fdata, tdata, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
end

function story_9()
	local actor = { name = story_data.actor, icon = story_data.icon };
	local list_tip = {
		"潘森具有[守护者]效果,只要他在场,我方其他非守护者盟军就不会成为敌方行动目标。",
		"但刚上场盟军会处于疲倦状态无法行动,还好我方还有恶魔小丑,赶紧进行攻击吧。",
	};
	local function callback()
		story_10();
	end
	local layer, name = layer_story:create(actor, list_tip, callback);
	g_scene:add_layer(ZORDER_LAYER_STORY, layer, name);
end

function story_10()
	local function callback()
		play_game_cmd("t 2301 1101");
		story_next = story_11;
	end
	local info = g_ui_table[2][T_ALLY][1];
	if nil == info then callback(); return; end
	local fdata = layer_dragstory.get_sprite_data(info:get_sprite(), true);
	info = g_ui_table[1][T_HERO][1];
	if nil == info then callback(); return; end
	local tdata = layer_dragstory.get_sprite_data(info:get_sprite(), true);
	local layer, name = layer_dragstory:create(fdata, tdata, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
end

function story_11()
	local function callback()
		play_game_cmd("n");
		play_game_cmd("s 0");
		story_next = story_12;
	end
	local item = layer_card.btn_next;
	if nil == item then callback(); return; end
	local fdata = layer_dragstory.get_sprite_data(item, false);
	fdata.x = fdata.x + fdata.width/2;
	fdata.y = fdata.y + fdata.height/2;
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
end

function story_12()
	local actor = { name = story_data.t_hero, icon = story_data.t_icon };
	local list_tip = {
		"你以为这样就能胜利了?看我的厉害。",
	};
	local function callback()
		story_13();
	end
	local layer, name = layer_story:create(actor, list_tip, callback);
	g_scene:add_layer(ZORDER_LAYER_STORY, layer, name);
end

function story_13()
	local actor = { name = story_data.actor, icon = story_data.icon };
	local list_tip = {
		"对方[跳过]弃牌阶段,一定是抽到关键卡牌,大家小心!",
	};
	local function callback()
		play_game_cmd("b 1201");
		story_next = story_14;
	end
	local layer, name = layer_story:create(actor, list_tip, callback);
	g_scene:add_layer(ZORDER_LAYER_STORY, layer, name);
end

function story_14()
	local actor = { name = story_data.actor, icon = story_data.icon };
	local list_tip = {
		"虽我军受创,但不要放弃,相信哪天我们一定能把敌人战胜。",
	};
	local function callback()
		story_next = nil;
		g_scene:map();
		story_15();
	end
	local layer, name = layer_story:create(actor, list_tip, callback);
	g_scene:add_layer(ZORDER_LAYER_STORY, layer, name);
end

function story_15()
	local actor = { name = story_data.actor, icon = story_data.icon };
	local list_tip = {
		"失败乃成功之母,多练习才能增加获胜的机会,加油啊。",
	};
	local function callback()
		story_16();
	end
	local layer, name = layer_story:create(actor, list_tip, callback);
	g_scene:add_layer(ZORDER_LAYER_STORY, layer, name);
end

function story_16()
	local function callback()
		--show_lai();
		show_gate();
		story_17();
	end
	local item = layer_map.btn_pve;
	if nil == item then callback(); return; end
	local fdata = layer_dragstory.get_sprite_data(item, false);
	fdata.x = fdata.x + fdata.width/2;
	fdata.y = fdata.y + fdata.height/2;
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
end

function story_17()
	local function callback()
		g_is_in_tutor = nil;
		story_data = nil;
		util.set_tutor(TUTOR_STORY, true, true);
		--[[
		local info = layer_solo.list[1];
		local eid = info.eid;
		local cmd = 'solo ' .. eid;
		net_send(cmd);
		]]--
		local info = layer_gate.list[1];
		if nil ~= info then
			local cmd = 'gate ' .. info.gate_id;
			net_send(cmd);
		end
		return;
	end
	if nil == layer_gate.layer then callback(); return; end
	if 0 == #(layer_gate.list or {}) then callback(); return; end
	local width = layer_gate.cwidth;
	local height = layer_gate.cheight;
	local th = layer_gate.theight;
	local x, y = layer_gate.tableview:getPosition();
	local fdata = { x=x+width/2, y=y+th-height+height/2, width=width, height=height, use_circle=false };
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
end

function tutor_tip(step)
	if step == TUTOR_SOLO then
		return "请先与电脑进行练习，熟悉基本玩法。";
	elseif step == TUTOR_RES then
		return "这是弃牌阶段，丢弃一张手牌可增加1点资源，出牌需要消耗资源。";
	elseif step == TUTOR_TAP_SKIP then
		return "手牌所剩无几啦，别再扔啦~试试点击跳过，可以跳过弃牌阶段";
	elseif step == TUTOR_TAP_CARD then
		return "点击查看牌的详细信息。";
	elseif step == TUTOR_COST then
		return "左上方数字表示出这张牌需要消耗的资源。";
	elseif step == TUTOR_DESC then
		return "描述部分会说明它的特殊技能和作用。";
	elseif step == TUTOR_HERO_POWER then
		return "英雄的法力值，每回合+1，用来施放英雄技能。";
	elseif step == TUTOR_HERO_HP then
		return "英雄的血量，降至0时战斗失败。";
	elseif step == TUTOR_ALLY_ATTACK then
		return "盟军的攻击力，每次攻击会使目标减少对应的血量。";
	elseif step == TUTOR_ALLY_HP then
		return "盟军的血量，降至0时盟军死亡。";
	elseif step == TUTOR_WEAPON_ATK then
		return "武器的攻击力，装备后使英雄获得对应的攻击力。";
	elseif step == TUTOR_WEAPON_DUR then
		return "武器的耐久度，每次使用武器后耐久度-1。";
	elseif step == TUTOR_ARMOR_DEF then
		return "防具的防御力，装备后使英雄获得对应的防御力。";
	elseif step == TUTOR_ARMOR_DUR then
		return "防具的耐久度，每次使用防具后耐久度-1。";
	elseif step == TUTOR_SAC then
		return "拖动你需要弃置的卡牌到资源区后就可以增加1点资源。";
	elseif step == TUTOR_SAC_TAP then
		return "你需要弃置的卡牌到资源区后就可以增加1点资源。";
	elseif step == TUTOR_PLAY then
		return "这是出牌阶段，消耗资源把手牌放出以及使用已上场卡牌的技能。";
	elseif step == TUTOR_HL then
		return "可操作的卡牌边框会高亮提示。";
	elseif step == TUTOR_NEED_RES then
		return "当前回合资源不足，不能出牌。";
	elseif step == TUTOR_NEXT then
		return "操作完成后点击【结束】按钮结束本回合，轮到对方操作。";
	elseif step == TUTOR_USE then
		return "使用你手上的牌。";
	elseif step == TUTOR_HL_ALLY then
		return "可操作的盟军牌边框会高亮提示。";
	elseif step == TUTOR_TAP_ATTACK then
		return "点击攻击进行目标选择。";
	elseif step == TUTOR_HL_ATTARGET then
		return "选择攻击的目标。";
	elseif step == TUTOR_TAP_ATTARGET then
		return "进行攻击吧。";
	elseif step == TUTOR_HL_HERO then
		return "英雄拥有足够技能点就可以发动技能。";
	elseif step == TUTOR_TAP_ABHERO then
		return "使用英雄技能吧。";
	elseif step == TUTOR_FIRST_SAC then
		return "弃除手牌可提升1点可用资源。";
	elseif step == TUTOR_WAIT_NEXT_SAC then
		return "可用资源不足支付手牌所需资源，无法进行出牌。";
	elseif step == TUTOR_WAIT_NEXT then
		return "结束回合，等待积累更多资源。";
	elseif step == TUTOR_SECOND_SAC then
		return "继续移除手牌，获取更多可用资源。";
	elseif step == TUTOR_HIGHLIGHT_CARD then
		return "可用资源足够支付出牌时，可用卡牌会被高亮与上移。";
	elseif step == TUTOR_SOMMON_CARD then
		return "拖动卡牌至盟军区域。";
	elseif step == TUTOR_WYLD_SKILL then
		return "恶魔小丑有迅捷技能，在出场回合即可立即攻击。";
	elseif step == TUTOR_NO_TARGET_ATK then
		return "但对方场上没有攻击目标，闯关模式下无法攻击对方英雄。";
	elseif step == TUTOR_REST then
		return "新上场的盟军会处于休息状态无法行动。";
	elseif step == TUTOR_ATTACK then
		return "拖动至攻击目标进行攻击。";
	elseif step == TUTOR_INTRO then
		return "欢迎来到决战王者，我们将以一系列的教程来引导各路新人在对战中战胜对手。";
	elseif step == TUTOR_AREA then
		return "首先，决战王者的战场主要划分为几个区域。";
	elseif step == TUTOR_AREA_RES then
		return "资源区：显示玩家或敌方当时所剩资源与回合可用的总资源。";
	elseif step == TUTOR_AREA_HAND then
		return "手牌区：显示玩家或敌方目前拥有的手牌，手牌可以通过消耗资源召唤至场上。";
	elseif step == TUTOR_AREA_HERO then
		return "英雄区：显示玩家或敌方目前英雄种类，所剩生命值(右边数字)，所剩技能点(左边数字)。";
	elseif step == TUTOR_AREA_DECK then
		return "牌堆：显示玩家或敌方目前剩余可抽牌数，当牌堆为0时，每抽取一次牌则扣除1点生命。";
	elseif step == TUTOR_AREA_SPACE then
		return "场地：通过消耗资源被召唤至场上的卡牌都会出现在场地上。卡牌被召唤后才能被使用或发挥效果。";
	elseif step == TUTOR_TURN_SAC then
		return "目前处于我方弃牌阶段，弃除手牌可提升1点可用资源。";
	elseif step == TUTOR_PVP_CAN_ATTACK then
		return "对战模式下，对方英雄生命点被扣至0时会宣布我方胜利，反之则我方失败。";
	elseif step == TUTOR_PVP_ATTACK then
		return "拖动至对方英雄位置进行攻击。";
	elseif step == TUTOR_TEST then
		return "sdafldfjlajdlajldfjaljd  aksdfjlajdfjk，啊啊发动机拉卡机阿事实上是,ajalfdsllkafkl\n999\n101010";
	end
	return nil;
end

function tutor_solo()
	local self = layer_solo;
	if nil == self.layer then
		return false;
	end
	if 0 == #(self.list or {}) then
		return false;
	end
	local size = cc.size(self.cwidth, self.cheight);
	local x, y = self.tableview:getPosition();
	local pos = cc.p(x, y + self.theight - size.height);
	return util.add_tutorial(pos, size, TUTOR_SOLO);
end

function tutor_res()
	local self = layer_table;
	if nil == self.layer then
		return false;
	end
	local info = g_ui_table[g_euser.side][T_RES];
	if nil == info then
		return false;
	end
	local size = cc.size(info.width, info.height);
	local pos = cc.p(info.x-size.width/2, info.y-size.height/2);
	return util.add_tutorial(pos, size, TUTOR_RES, tutor_tap_card);
end

function tutor_tap_skip()
	local self = layer_table;
	if nil == self.layer then
		return false;
	end
	local list = g_ui_table[g_euser.side][T_HAND] or {};
	if #list > 3 then
		return false;
	end
	local btn = layer_card.btn_skip;
	if nil == btn then return false; end
	if false == btn:isVisible() then return false; end
	local x, y = btn:getPosition();
	local pos = cc.p(x, y);
	local size = btn:getContentSize();
	return util.add_tutorial(pos, size, TUTOR_TAP_SKIP);
end

function tutor_tap_card()
	local self = layer_card;
	if nil == self.layer then
		return false;
	end
	local list = g_ui_table[g_euser.side][T_HAND];
	local info = list[1];
	if nil == info then
		return false;
	end
	local s = info:get_sprite();
	local x1, y1 = s:getPosition();
	local size1 = s:getContentSize();
	local size = cc.size(list.width, list.height);
	local pos = cc.p(x1-size1.width/2, y1-size1.height/2);
	return util.add_tutorial(pos, size, TUTOR_TAP_CARD);
end

function tutor_card_detail_area(sprite, tag)
	local ss = sprite:getChildByTag(tag);
	if nil == ss then 
		return false; 
	end
	local x, y = sprite:getPosition();
	local size = sprite:getContentSize();
	local scale = sprite:getScale();
	local x2 = x - size.width/2*scale;
	local y2 = y - size.height/2*scale;
	x, y = ss:getPosition();
	size = ss:getContentSize();
	size.width = size.width * scale;
	size.height = size.height * scale;
	local pos = cc.p(x*scale+x2-size.width/2, y*scale+y2-size.height/2);
	return true, pos, size;
end

function tutor_cost()
	local self = layer_action;
	if nil == self.layer then
		return false;
	end
	local list = layer_action.list or {};
	if 0 == #list then
		return false;
	end
	local sprite = list[1].sprite;
	if nil == sprite then return false; end

	local flag, pos, size = tutor_card_detail_area(sprite, TAG_COST);
	if true ~= flag then return false; end

	local cb = nil;
	if false == util.check_tutor(TUTOR_DESC) then
		cb = tutor_desc;
	end
	return util.add_tutorial(pos, size, TUTOR_COST, cb);
end

function tutor_desc()
	local self = layer_action;
	if nil == self.layer then
		return false;
	end
	local list = layer_action.list or {};
	if 0 == #list then
		return false;
	end
	local sprite = list[1].sprite;
	if nil == sprite then return false; end

	local flag, pos, size = tutor_card_detail_area(sprite, TAG_DESC);
	if true ~= flag then return false; end

	return util.add_tutorial(pos, size, TUTOR_DESC, tutor_sac_tap);
end

function tutor_left_down()
	local self = layer_action;
	if nil == self.layer then
		return false;
	end
	local list = layer_action.list or {};
	if 0 == #list then
		return false;
	end
	local sprite = list[1].sprite;
	if nil == sprite then return false; end

	local flag, pos, size = tutor_card_detail_area(sprite, TAG_POWER);
	if true ~= flag then return false; end

	return true, pos, size;
end

function tutor_right_down()
	local self = layer_action;
	if nil == self.layer then
		return false;
	end
	local list = layer_action.list or {};
	if 0 == #list then
		return false;
	end
	local sprite = list[1].sprite;
	if nil == sprite then return false; end

	local flag, pos, size = tutor_card_detail_area(sprite, TAG_HP);
	if true ~= flag then return false; end

	return true, pos, size;
end

function tutor_hero_power()
	local flag, pos, size = tutor_left_down();
	if false == flag then
		return false;
	end

	return util.add_tutorial(pos, size, TUTOR_HERO_POWER, tutor_hero_hp);
end

function tutor_hero_hp()
	local flag, pos, size = tutor_right_down();
	if false == flag then
		return false;
	end

	local cb = nil;
	if false == util.check_tutor(TUTOR_DESC) then
		cb = tutor_desc;
	end
	return util.add_tutorial(pos, size, TUTOR_HERO_HP, cb);
end

function tutor_ally_attack()
	local flag, pos, size = tutor_left_down();
	if false == flag then
		return false;
	end

	return util.add_tutorial(pos, size, TUTOR_ALLY_ATTACK, tutor_ally_hp);
end

function tutor_ally_hp()
	local flag, pos, size = tutor_right_down();
	if false == flag then
		return false;
	end

	local cb = nil;
	if false == util.check_tutor(TUTOR_COST) then
		cb = tutor_cost;
	end
	return util.add_tutorial(pos, size, TUTOR_ALLY_HP, cb);
end

function tutor_weapon_atk()
	local flag, pos, size = tutor_left_down();
	if false == flag then
		return false;
	end

	return util.add_tutorial(pos, size, TUTOR_WEAPON_ATK, tutor_weapon_dur);
end

function tutor_weapon_dur()
	local flag, pos, size = tutor_right_down();
	if false == flag then
		return false;
	end

	local cb = nil;
	if false == util.check_tutor(TUTOR_COST) then
		cb = tutor_cost;
	end
	return util.add_tutorial(pos, size, TUTOR_WEAPON_DUR, cb);
end

function tutor_armor_def()
	local flag, pos, size = tutor_left_down();
	if false == flag then
		return false;
	end

	return util.add_tutorial(pos, size, TUTOR_ARMOR_DEF, tutor_armor_dur);
end

function tutor_armor_dur()
	local flag, pos, size = tutor_right_down();
	if false == flag then
		return false;
	end

	local cb = nil;
	if false == util.check_tutor(TUTOR_COST) then
		cb = tutor_cost;
	end
	return util.add_tutorial(pos, size, TUTOR_ARMOR_DUR, cb);
end

function tutor_sac()
	local self = layer_card;
	if nil == self.layer then
		return false;
	end
	local list = g_ui_table[g_euser.side][T_HAND];
	local info = list[1];
	if nil == info then
		return false;
	end
	local s = info:get_sprite();
	local x, y = s:getPosition();
	local size = s:getContentSize();
	local pos = cc.p(x - size.width/2, y - size.height/2);
	local flag = util.add_tutorial(pos, size, TUTOR_SAC);
	if false == flag then
		return false;
	end
	local finger = layer_tutorial:get_finger();
	if nil == finger then	
		return false;
	end
	finger:stopAllActions();
	info = g_ui_table[g_euser.side][T_RES];
	if nil == info then
		return false;
	end
	size = cc.size(info.width, info.height);
	local pos2 = cc.p(info.x, info.y);
	local array = {};
	local action = cc.MoveTo:create(2, pos2);
	table.insert(array, action);
	action = cc.MoveTo:create(0.05, pos);
	table.insert(array, action);
	action = cc.Sequence:create(array);
	action = cc.RepeatForever:create(action);
	finger:runAction(action);
	return true;
end

function tutor_sac_tap()
	local self = layer_action;
	if nil == self.layer then
		return false;
	end
	if PHASE_SACRIFICE ~= g_phase then
		return false;
	end
	local menu = self.menu;
	if nil == menu then return false; end
	local item = menu:getChildren()[1];
	if nil == item then return false; end

	local x, y = item:getPosition();
	local size = item:getContentSize();
	local scale = item:getScale();
	local pos = cc.p(x-size.width/2, y);
	return util.add_tutorial(pos, size, TUTOR_SAC_TAP);
end

function tutor_play()
	local self = layer_card;
	if nil == self.layer then
		return false;
	end
	local label = g_ui_table.label_res[SIDE_DOWN];
	if nil == label then return false; end
	local x, y = label:getPosition();
	local size = label:getContentSize();
	local pos = cc.p(x-size.width, y-size.height);
	local cb = nil;
	if false == util.check_tutor(TUTOR_HL) then
		cb = tutor_hl;
	end
	return util.add_tutorial(pos, size, TUTOR_PLAY, cb);
end

function tutor_hl()
	local self = layer_card;
	if nil == self.layer then
		return false;
	end
	local list = g_ui_table[g_euser.side][T_HAND];
	local info = check_hl_in_list(list);
	if nil == info then
		--[[
		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		local size = cc.size(0, 0);
		return util.add_tutorial(pos, size, TUTOR_NEED_RES, tutor_next, true);
		]]--
		return util.trigger_tutor(TUTOR_NEXT);
	end
	local s = info:get_sprite();
	local size = s:getContentSize();
	local x, y = s:getPosition();
	local pos = cc.p(x - size.width/2, y - size.height/2);
	return util.add_tutorial(pos, size, TUTOR_HL);
end

function tutor_use()
	local self = layer_action;
	if nil == self.layer then
		return false;
	end
	if PHASE_PLAY ~= g_phase then
		return false;
	end
	local menu = self.menu;
	if nil == menu then return false; end
	local item = menu:getChildren()[1];
	if nil == item then return false; end

	local x, y = item:getPosition();
	local size = item:getContentSize();
	local scale = item:getScale();
	local pos = cc.p(x-size.width/2, y);
	return util.add_tutorial(pos, size, TUTOR_USE);
end

function tutor_hl_ally()
	local self = layer_card;
	if nil == self.layer then
		return false;
	end
	local list = g_ui_table[g_euser.side][T_ALLY];
	local info = check_hl_in_list(list);
	if nil == info then
		return false;
	end
	local s = info:get_sprite();
	local size = s:getContentSize();
	local x, y = s:getPosition();
	local pos = cc.p(x - size.width/2, y - size.height/2);
	return util.add_tutorial(pos, size, TUTOR_HL_ALLY);
end

function tutor_tap_attack()
	local self = layer_action;
	if nil == self.layer then
		return false;
	end
	if PHASE_PLAY ~= g_phase then
		return false;
	end
	local menu = self.menu;
	if nil == menu then return false; end
	local item = menu:getChildren()[1];
	if nil == item then return false; end

	local x, y = item:getPosition();
	local size = item:getContentSize();
	local scale = item:getScale();
	local pos = cc.p(x-size.width/2, y);
	return util.add_tutorial(pos, size, TUTOR_TAP_ATTACK);
end

function tutor_hl_attarget()
	local self = layer_card;
	if nil == self.layer then
		return false;
	end
	local list = list_attack_target(g_src_index, g_logic_table, g_current_side);
	local index = list[1];
	if nil == index then return false; end
	local info = get_ui_card(index);
	if nil == info then return false; end
	local s = info:get_sprite();
	local size = s:getContentSize();
	local x, y = s:getPosition();
	local pos = cc.p(x - size.width/2, y - size.height/2);
	return util.add_tutorial(pos, size, TUTOR_HL_ATTARGET);
end

function tutor_tap_attarget()
	local self = layer_action;
	if nil == self.layer then
		return false;
	end
	if PHASE_PLAY ~= g_phase then
		return false;
	end
	local menu = self.menu;
	if nil == menu then return false; end
	local item = menu:getChildren()[1];
	if nil == item then return false; end

	local x, y = item:getPosition();
	local size = item:getContentSize();
	local scale = item:getScale();
	local pos = cc.p(x-size.width/2, y);
	return util.add_tutorial(pos, size, TUTOR_TAP_ATTARGET);
end

function tutor_hl_hero()
	local self = layer_card;
	if nil == self.layer then
		return false;
	end
	local info = g_ui_table[g_euser.side][T_HERO][1];
	if nil == info then return false; end
	local kind = check_kind(info.card, g_logic_table, g_current_side, g_phase);
	if kind ~= AKIND_ABILITY and kind ~= AKIND_BOTH then
		return false;
	end
	local s = info:get_sprite();
	--[[
	local h = s:getChildByTag(TAG_HIGHLIGHT);
	if nil == h then return false; end
	local index = cindex(info.card);
	if nil == index then return false; end
	local indexs = list_ability_target(index, g_logic_table, g_current_side, {}, 1);
	if #indexs == 0 then return false; end
	]]--
	local size = s:getContentSize();
	local x, y = s:getPosition();
	local pos = cc.p(x - size.width/2, y - size.height/2);
	return util.add_tutorial(pos, size, TUTOR_HL_HERO);
end

function tutor_tap_abhero()
	local self = layer_action;
	if nil == self.layer then
		return false;
	end
	if PHASE_PLAY ~= g_phase then
		return false;
	end
	local menu = self.menu;
	if nil == menu then return false; end
	local items = menu:getChildren();
	if 0 == #items then return false; end
	local item = items[#items];
	if nil == item then return false; end

	local x, y = item:getPosition();
	local size = item:getContentSize();
	local scale = item:getScale();
	local pos = cc.p(x-size.width/2, y);
	return util.add_tutorial(pos, size, TUTOR_TAP_ABHERO);
end

function tutor_next()
	local self = layer_card;
	if nil == self.layer then
		return false;
	end
	local item = self.btn_next;
	if nil == item then
		return false;
	end
	local x, y = item:getPosition();
	local pos = cc.p(x, y);
	local size = item:getContentSize();
	return util.add_tutorial(pos, size, TUTOR_NEXT);
end

function tutor_first_sac()
	local slist = g_logic_table[g_euser.side][T_ALLY];
	local cur_res = g_logic_table[g_euser.side].resource;
	if false == g_scene:is_stage(STAGE_PVG)
	or PHASE_SACRIFICE ~= g_phase
	or cur_res > 0
	or #slist > 0 then
		return false;
	end

	local self = layer_card;
	if nil == self.layer then
		return false;
	end
	local list = g_ui_table[g_euser.side][T_HAND];
	local info = list[1];
	local card_pos = 1;
	for i=1,#list do
		local card = list[i].card;
		if card.cost > info.card.cost then
			info = list[i];
			card_pos = i;
		end
	end
	if nil == info then
		return false;
	end

	local s = info:get_sprite();
	local size = s:getContentSize();
	local fdata = layer_dragtutorial.get_sprite_data(info:get_sprite(), true);
	info = g_ui_table[g_euser.side][T_RES];
	if nil == info then
		return false;
	end
	local tdata = { x = info.x, y = info.y, width = info.width, height = info.height, use_circle = false };
	local cliplist = { fdata, tdata };
	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT * 3 / 4);
	local tip = tutor_tip(TUTOR_FIRST_SAC);
	local function callback()
		play_game_cmd("s " .. g_euser.side .. "20" .. card_pos);
	end
	local layer, name = layer_dragtutorial:create(cliplist, fdata, tdata, pos, tip, callback);
--	create = function(self, cliplist, fdata, tdata, pos, size, tip, callback)
	
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);

	-- TODO
	util.set_tutor(TUTOR_FIRST_SAC, true, true)
	return true;
end

function tutor_wait_next_sac()
	if false == g_scene:is_stage(STAGE_PVG)
	or #g_logic_table[g_euser.side][T_ALLY] > 0 then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end

	local list = g_ui_table[g_euser.side][T_HAND];
	local min_cost = 10;
	for i = 1, #list do
		if min_cost > list[i].card.cost then
			min_cost = list[i].card.cost;
		end
	end
	local cur_res = g_logic_table[g_euser.side].resource;
	if min_cost <= cur_res then
		return false;
	end

	local info = list[1];

	local s = info:get_sprite();
	local size = s:getContentSize();
	local s_data = layer_dragtutorial.get_sprite_data(info:get_sprite(), false);
	fdata = {
		x = s_data.x + s_data.width * #list / 2 - s_data.width / 4,
		y = s_data.y + s_data.height / 3,
		width = s_data.width * #list + s_data.width / 2,
		height = s_data.height / 3,
		use_circle = false
	};

	local rpos, rsize = get_res_number_area(g_euser.side);

	local resdata = {
		x = rpos.x,
		y = rpos.y,
		width = rsize.width,
		height = rsize.height,
		use_circle = false
	};

	local function callback()
		util.trigger_tutor(TUTOR_WAIT_NEXT)
	end
	local cliplist = { fdata, resdata };
	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT * 3 / 4);
	local tip = tutor_tip(TUTOR_WAIT_NEXT_SAC);
	local layer, name = layer_dragtutorial:create(cliplist, nil, nil, pos, tip, callback);
	
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);

	return true;
end

function tutor_wait_next()
	if false == g_scene:is_stage(STAGE_PVG) then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end

	local function callback()
		play_game_cmd("n");
		util.set_tutor(TUTOR_WAIT_NEXT_SAC, true, true)
	end
	local item = layer_card.btn_next;
	if nil == item then callback(); return; end
	local fdata = layer_dragtutorial.get_sprite_data(item, false);
	fdata.x = fdata.x + fdata.width/2;
	fdata.y = fdata.y + fdata.height/2;
	local cliplist = { fdata };
	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT * 3 / 4);
	local size = g_ui_table[g_euser.side][T_HAND][1]:get_sprite():getContentSize();
	local tip = tutor_tip(TUTOR_WAIT_NEXT);
	local layer, name = layer_dragtutorial:create(cliplist, fdata, nil, pos, tip, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);
	return true;
end

function tutor_second_sac()
	if false == g_scene:is_stage(STAGE_PVG) then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end
	local list = g_ui_table[g_euser.side][T_HAND];
	local info = list[1];
	local card_pos = 1;
	for i=1,#list do
		local card = list[i].card;
		if card.cost > info.card.cost then
			info = list[i];
			card_pos = i;
		end
	end
	if nil == info then
		return false;
	end

	local s = info:get_sprite();
	local size = s:getContentSize();
	local fdata = layer_dragtutorial.get_sprite_data(info:get_sprite(), true);
	info = g_ui_table[g_euser.side][T_RES];
	if nil == info then
		return false;
	end
	local tdata = { x = info.x, y = info.y, width = info.width, height = info.height, use_circle = false };
	local cliplist = { fdata, tdata };
	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT * 3 / 4);
	local tip = tutor_tip(TUTOR_SECOND_SAC);
	local function callback()
		play_game_cmd("s " .. g_euser.side .. "20" .. card_pos);
	end
	local layer, name = layer_dragtutorial:create(cliplist, fdata, tdata, pos, tip, callback);
	
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);

	-- TODO
	util.set_tutor(TUTOR_SECOND_SAC, true, true)
	return true;
end

function tutor_highlight_card()
	if false == g_scene:is_stage(STAGE_PVG)
	or #g_ui_table[g_euser.side][T_ALLY] > 0 then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end

	local list = g_ui_table[g_euser.side][T_HAND];
	local slist = {};
	local info = nil;
	local cdata = nil;
	local ally_count = 0;
	for i=1,#list do
		info = list[i];
		local cs = info.sprite;
		local hl = cs:getChildByTag(TAG_HIGHLIGHT);
		if nil ~= hl then
			cdata = layer_dragtutorial.get_sprite_data(info:get_sprite(), true);
			table.insert(slist, cdata);
			ally_count = ally_count + 1;
		end
	end

	if ally_count == 0 then
		return false;
	end

	local s = list[1]:get_sprite();
	local size = s:getContentSize();

	local rpos, rsize = get_res_number_area(g_euser.side);
	local resdata = {
		x = rpos.x,
		y = rpos.y,
		width = rsize.width,
		height = rsize.height,
		use_circle = false
	};
	table.insert(slist, resdata);

	local function callback()
		util.trigger_tutor(TUTOR_SOMMON_CARD)
	end
	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT * 3 / 4);
	local tip = tutor_tip(TUTOR_HIGHLIGHT_CARD);
	local layer, name = layer_dragtutorial:create(slist, nil, nil, pos, tip, callback);
	
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);

	return true;
end


function tutor_summon_card()
	if false == g_scene:is_stage(STAGE_PVG) then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end

	local cur_res = g_logic_table[g_euser.side].resource;

	local list = g_ui_table[g_euser.side][T_HAND];
	local info = nil;
	local card_pos = -1;
	for i=1,#list do
		local card = list[i].card;
		if card.cost <= cur_res and card.ctype == ALLY then
			info = list[i];
			card_pos = i;
			break;
		end
	end

	if nil == info then
		return false;
	end

	local s = info:get_sprite();
	local size = s:getContentSize();
	local fdata = layer_dragtutorial.get_sprite_data(s, true);

	info = g_ui_table[g_euser.side][T_ALLY];
	if nil == info then
		print("ERROR: ally info nil");
		return false;
	end
	local tdata = {
		x = info.x + info.width / 2 - fdata.width / 2,
		y = info.y,
		width = info.width,
		height = info.height,
		use_circle = false
	};

	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT * 3 / 4);
	local tip = tutor_tip(TUTOR_SOMMON_CARD);
	local cliplist = { fdata, tdata };
	local function callback()
		play_game_cmd("b " .. g_euser.side .. "20" .. card_pos);
		util.set_tutor(TUTOR_HIGHLIGHT_CARD, true, true)
	end
	local layer, name = layer_dragtutorial:create(cliplist, fdata, tdata, pos, tip, callback);
	
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);

	return true;
end

function tutor_wyld_skill()
	if false == g_scene:is_stage(STAGE_PVG) then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end

	local list = g_ui_table[g_euser.side][T_ALLY];
	local info = nil;
	for i=1, #list do
		local card = list[i].card;
		if card.id == 25 then
			info = list[i];
			break;
		end
	end
	if nil == info then
		return false;
	end

	local s = info:get_sprite();
	local size = s:getContentSize();
	local f_data = layer_dragtutorial.get_sprite_data(info:get_sprite(), true);

	local function callback()
		local flag = false;
		list = g_ui_table[3-g_euser.side][T_ALLY];
		if #list == 0 then
			flag = util.trigger_tutor(TUTOR_NO_TARGET_ATK);
		else
			flag = util.trigger_tutor(TUTOR_ATTACK);
		end
		util.set_tutor(TUTOR_WYLD_SKILL, true, true)

		if false == flag then
			flag = show_svg_help();
		end
	end
	local cliplist = { f_data };
	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT * 3 / 4);
	local tip = tutor_tip(TUTOR_WYLD_SKILL);
	local layer, name = layer_dragtutorial:create(cliplist, nil, nil, pos, tip, callback);
	
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);

	return true;
end

function tutor_no_target_atk()
	if false == g_scene:is_stage(STAGE_PVG) then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end

	if #(g_logic_table[3-g_euser.side][T_ALLY] or {}) > 0 then
		return false;
	end

	local apos, asize = get_ally_area(3-g_euser.side);
	local fdata = {
		x = apos.x,
		y = apos.y,
		width = asize.width,
		height = asize.height,
		use_circle = false
	};

	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT * 3 / 4);
	local tip = tutor_tip(TUTOR_NO_TARGET_ATK);
	local cliplist = { fdata };
	function callback()
		local flag = false;
		if false == flag then
			flag = util.trigger_tutor(TUTOR_WAIT_NEXT);
		end
		if false == flag then
			flag = show_svg_help();
		end
	end
	local layer, name = layer_dragtutorial:create(cliplist, nil, nil, pos, tip, callback);
	
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);

	return true;
end

function tutor_rest()

	if false == g_scene:is_stage(STAGE_PVG) then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end

	local alist = g_ui_table[g_euser.side][T_ALLY];
	local info = nil;
	for i = 1, #alist do
		if alist[i].card.ready == 0 and alist[i].card.id ~= 25 then
			info = alist[i];
			break;
		end
	end

	if nil == info then
		return false;
	end

	local s = info:get_sprite();
	local size = s:getContentSize();
	local s_data = layer_dragtutorial.get_sprite_data(info:get_sprite(), false);
	local fdata = {
		x = s_data.x + s_data.width / 3,
		y = s_data.y + s_data.height / 3,
		width = s_data.width * 3 / 4,
		height = s_data.height / 2,
		use_circle = false
	};

	local cliplist = { fdata };
	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT * 3 / 4);
	local tip = tutor_tip(TUTOR_REST);
	function callback()
		util.trigger_tutor(TUTOR_WAIT_NEXT)
	end
	local layer, name = layer_dragtutorial:create(cliplist, nil, nil, pos, tip, callback);
	
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);

	-- TODO
	util.set_tutor(TUTOR_REST, true, true);
	return true;
end

function tutor_attack()
	if false == g_scene:is_stage(STAGE_PVG) then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end

	local tlist = g_ui_table[3-g_euser.side][T_ALLY];
	if #tlist == 0 then
		return false;
	end

	local list = g_ui_table[g_euser.side][T_ALLY];
	local info = nil;
	local card_pos = -1;
	for i=1,#list do
		local card = list[i].card;
		if check_ready_attack(card) then
			info = list[i];
			card_pos = i;
			break;
		end
	end

	if nil == info then
		return false;
	end

	local s = info:get_sprite();
	local size = s:getContentSize();
	local fdata = layer_dragtutorial.get_sprite_data(s, true);

	info = tlist[1];
	if nil == info then
		return false;
	end
	local tdata = layer_dragtutorial.get_sprite_data(info:get_sprite(), true);

	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT * 3 / 4);
	local tip = tutor_tip(TUTOR_ATTACK);
	local cliplist = { fdata, tdata };
	local function callback()
		play_game_cmd("t " .. g_euser.side .. "30" .. card_pos .. " " .. (3-g_euser.side) .. "301");
		util.set_tutor(TUTOR_ATTACK, true, true)
	end
	local layer, name = layer_dragtutorial:create(cliplist, fdata, tdata, pos, tip, callback);
	
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);

	return true;

end

function tutor_intro()
	if false == g_scene:is_stage(STAGE_PVG)
	or g_round > 2 or g_euser.level > 1 then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end

	local function callback()
		util.trigger_tutor(TUTOR_AREA);
	end
	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
	local tip = tutor_tip(TUTOR_INTRO);
	local layer, name = layer_dragtutorial:create(nil, nil, nil, pos, tip, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);
	return true;
end

function tutor_area()
	if false == g_scene:is_stage(STAGE_PVG) then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end

	local function callback()
		util.trigger_tutor(TUTOR_AREA_RES);
	end
	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
	local tip = tutor_tip(TUTOR_AREA);
	local layer, name = layer_dragtutorial:create(nil, nil, nil, pos, tip, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);
	return true;
end

function tutor_area_res()
	if false == g_scene:is_stage(STAGE_PVG) then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end

	local dpos, dsize = get_res_area(SIDE_DOWN);
	local ddata = {
		x = dpos.x,
		y = dpos.y + dsize.height/2,
		width = dsize.width,
		height = dsize.height,
		use_circle = false
	};
	local upos, usize = get_res_area(SIDE_UP);
	local udata = {
		x = upos.x,
		y = upos.y,
		width = usize.width,
		height = usize.height,
		use_circle = false
	};

	local cliplist = { ddata, udata };

	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
	local tip = tutor_tip(TUTOR_AREA_RES);
	function callback()
		util.trigger_tutor(TUTOR_AREA_HAND);
	end
	local layer, name = layer_dragtutorial:create(cliplist, nil, nil, nil, tip, callback);
	
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);

	return true;
end

function tutor_area_hand()
	if false == g_scene:is_stage(STAGE_PVG) then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end

	local dpos, dsize = get_hand_area(SIDE_DOWN);
	local ddata = {
		x = dpos.x,
		y = dpos.y,
		width = dsize.width,
		height = dsize.height,
		use_circle = false
	};
	local upos, usize = get_hand_area(SIDE_UP);
	local udata = {
		x = upos.x,
		y = upos.y,
		width = usize.width,
		height = usize.height,
		use_circle = false
	};

	local cliplist = { ddata, udata };

	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
	local tip = tutor_tip(TUTOR_AREA_HAND);
	function callback()
		util.trigger_tutor(TUTOR_AREA_HERO);
	end
	local layer, name = layer_dragtutorial:create(cliplist, nil, nil, pos, tip, callback);
	
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);

	return true;
end

function tutor_area_hero()
	if false == g_scene:is_stage(STAGE_PVG) then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end

	local dpos, dsize = get_hero_area(SIDE_DOWN);
	local ddata = {
		x = dpos.x,
		y = dpos.y,
		width = dsize.width,
		height = dsize.height,
		use_circle = true
	};
	local upos, usize = get_hero_area(SIDE_UP);
	local udata = {
		x = upos.x,
		y = upos.y,
		width = usize.width,
		height = usize.height,
		use_circle = true
	};

	local cliplist = { ddata, udata };

	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
	local tip = tutor_tip(TUTOR_AREA_HERO);
	function callback()
		util.trigger_tutor(TUTOR_AREA_DECK);
	end
	local layer, name = layer_dragtutorial:create(cliplist, nil, nil, pos, tip, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);
	return true;
end

function tutor_area_deck()
	if false == g_scene:is_stage(STAGE_PVG) then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end

	local dpos, dsize = get_deck_area(SIDE_DOWN);
	local ddata = {
		x = dpos.x,
		y = dpos.y,
		width = dsize.width,
		height = dsize.height,
		use_circle = true
	};

	local cliplist = { ddata };

	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
	local tip = tutor_tip(TUTOR_AREA_DECK);
	function callback()
		util.trigger_tutor(TUTOR_AREA_SPACE);
	end
	local layer, name = layer_dragtutorial:create(cliplist, nil, nil, pos, tip, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);
	return true;
end

function tutor_area_space()
	if false == g_scene:is_stage(STAGE_PVG) then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end

	local dpos, dsize = get_space_area(SIDE_DOWN);
	local ddata = {
		x = dpos.x,
		y = dpos.y,
		width = dsize.width,
		height = dsize.height,
		use_circle = false
	};
	local upos, usize = get_space_area(SIDE_UP);
	local udata = {
		x = upos.x,
		y = upos.y,
		width = usize.width,
		height = usize.height,
		use_circle = false
	};

	local cliplist = { ddata, udata };

	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT * 7 / 8);
	local tip = tutor_tip(TUTOR_AREA_SPACE);
	function callback()
		util.trigger_tutor(TUTOR_TURN_SAC);
	end
	local layer, name = layer_dragtutorial:create(cliplist, nil, nil, pos, tip, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);
	return true;
end

function tutor_turn_sac()

	if false == g_scene:is_stage(STAGE_PVG) then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end
	local info = layer_table.phase
	if nil == info then
		return false;
	end
	local f_data = layer_dragtutorial.get_sprite_data(info, false);

	local cliplist = { f_data }
	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT * 3 / 4);
	local tip = tutor_tip(TUTOR_TURN_SAC);
	function callback()
		util.set_tutor(TUTOR_INTRO, true, true)
		util.trigger_tutor(TUTOR_FIRST_SAC);
	end
	local layer, name = layer_dragtutorial:create(cliplist, nil, nil, pos, tip, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);
	return true;
end

function show_svg_help()
	if false == g_scene:is_stage(STAGE_PVG) or nil ~= g_net_win_data then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end
	if g_euser.level >= 5 then
		return false;
	end

	local tips = '';

	local cur_res = g_logic_table[g_euser.side].resource;
	local list = g_ui_table[g_euser.side][T_HAND];
	local info = nil;
	for i=1,#list do
		local card = list[i].card;
		if card.cost <= cur_res and card.ctype == ALLY then
			info = list[i];
			break;
		end
	end
	if nil ~= info then
		tips = tips .. "\n召唤新卡牌上场";
	end

	local tlist = g_ui_table[3-g_euser.side][T_ALLY];
	local list = g_ui_table[g_euser.side][T_ALLY];
	info = nil;
	if #tlist > 0 then
		for i=1,#list do
			local card = list[i].card;
			if check_ready_attack(card) then
				info = list[i];
				break;
			end
		end
	end
	if nil ~= info then
		tips = tips .. "\n盟军进行攻击";
	end

	if 0 == string.len(tips) then
		layer_card:eff_btn_next();
		tips = "无可选择行为，结束回合";
	else
		tips = "可选择行为：" .. tips;
	end
	layer_card:show_tip_help(tips);
	return true;
end

function tutor_pvp_can_attack()
	print("tutor_pvp_can_attack");
	if false == g_scene:is_stage(STAGE_PVP) then
		return false;
	end
	if nil == g_euser.room_data then
		return false;
	end
	local guest_list = g_euser.room_data.guest_list or {};
	local info = guest_list[3-g_euser.side];
	if nil == info then return false; end
	if info.eid >= 500 then return false; end

	print("pvp check atk:" ..  info.eid);
	local list = g_ui_table[g_euser.side][T_ALLY];
	info = nil;
	local thero = nil;
	local findex = nil;
	local tindex = nil;
	for i=1,#list do
		local card = list[i].card;
		findex = cindex(card);
		print("findex: " , findex);
		local tlist = list_attack_target(findex, g_logic_table, g_current_side);
		for j = 1, #tlist do
			tindex = tlist[j];
			print("tindex:" , tindex);
			local tb = index_table_num(tindex);
			if tb == T_HERO then
				info = list[i];
				thero = g_ui_table[3-g_euser.side][T_HERO][1];
				break;
			end
		end
	end
	print("findex: ", findex, " tindex:", tindex);

	if nil == info or nil == thero then
		return false;
	end

	local tdata = layer_dragtutorial.get_sprite_data(thero:get_sprite(), true);

	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT / 4);
	local tip = tutor_tip(TUTOR_PVP_CAN_ATTACK);
	local cliplist = { tdata };
	local function callback()
		util.trigger_tutor(TUTOR_PVP_ATTACK);
		util.set_tutor(TUTOR_PVP_CAN_ATTACK, true, true)
	end
	local layer, name = layer_dragtutorial:create(cliplist, nil, nil, pos, tip, callback);
	
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);

	return true;

end

function tutor_pvp_attack()
	if false == g_scene:is_stage(STAGE_PVP) then
		return false;
	end
	if nil == g_euser.room_data then
		return false;
	end
	local guest_list = g_euser.room_data.guest_list or {};
	local info = guest_list[3-g_euser.side];
	if nil == info then return false; end
	if info.eid >= 500 then return false; end

	local list = g_ui_table[g_euser.side][T_ALLY];
	info = nil;
	local thero = nil;
	local findex = nil;
	local tindex = nil;
	for i=1,#list do
		local card = list[i].card;
		findex = cindex(card);
		local tlist = list_attack_target(findex, g_logic_table, g_euser.side);
		for j = 1, #tlist do
			tindex = tlist[j];
			local tb = index_table_num(tindex);
			if tb == T_HERO then
				info = list[i];
				thero = g_ui_table[3-g_euser.side][T_HERO][1];
				break;
			end
		end
	end

	if nil == info or nil == thero then
		return false;
	end

	local s = info:get_sprite();
	local size = s:getContentSize();
	local fdata = layer_dragtutorial.get_sprite_data(s, true);
	local tdata = layer_dragtutorial.get_sprite_data(thero:get_sprite(), true);

	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT / 8);
	local tip = tutor_tip(TUTOR_PVP_ATTACK);
	local cliplist = { fdata, tdata };
	local function callback()
		play_game_cmd("t " .. findex .. " " .. tindex);
		util.set_tutor(TUTOR_PVP_ATTACK, true, true)
	end
	local layer, name = layer_dragtutorial:create(cliplist, fdata, tdata, pos, tip, callback);
	
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);

	return true;
end


function tutor_pay_ad()
	if false == g_scene:is_stage(STAGE_MAP) then
		return false;
	end
	--if g_euser.level > 5 then return false; end

	local btn = layer_map.btn_lottery;
	if nil == btn then return false; end
	local fdata = layer_dragstory.get_sprite_data(btn, false);
	local function callback()
		g_tutor_wait_net = tutor_pay_ad_2;
		show_lottery();
		--tutor_pay_ad_2();
	end
	fdata.x = fdata.x + fdata.width/2;
	fdata.y = fdata.y + fdata.height/2;
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);

	return true;
end

function tutor_pay_ad_2()
	g_tutor_wait_net = nil;
	local function callback()
		local info = layer_lottery.list[1];
		if nil ~= info then
			--g_scene:add_layer(ZORDER_LAYER_POPCLIST, layer_popclist:create({},true));
			--tutor_pay_ad_3();
			g_tutor_wait_net = tutor_pay_ad_3;
			--layer_popclist.after_eff();
			layer_lottery:do_it(1);
		end
		return;
	end
	if nil == layer_lottery.layer then callback(); return; end
	if 0 == #(layer_lottery.list or {}) then callback(); return; end
	local width = layer_lottery.cwidth;
	local height = layer_lottery.cheight;
	local th = layer_lottery.theight;
	local x, y = layer_lottery.tableview:getPosition();
	local fdata = { x=x+width/2, y=y+th-height+height/2, width=width, height=height, use_circle=false };
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
end

function tutor_pay_ad_3()
	g_tutor_wait_net = nil;
	local btn = layer_popclist.btn_back;
	if nil == btn then return false; end
	local fdata = layer_dragstory.get_sprite_data(btn, false);
	local function callback()
		layer_popclist.back();
		tutor_pay_ad_4();
	end
	fdata.x = fdata.x;
	fdata.y = fdata.y + fdata.height/2;
	local cliplist = { fdata };
	local info = layer_popclist.list[1];
	print('1 : ', info);
	if nil ~= info then
		local cinfo = info.info;
	print('2 : ', cinfo);
		if nil ~= cinfo then
			local scale = info.scale;
			local dd = layer_dragstory.get_sprite_data(cinfo.sprite, false);
			table.insert(cliplist, dd);
		end
	end
	--local layer, name = layer_dragstory:create(fdata, nil, callback);
	local layer, name = layer_dragtutorial:create(cliplist, fdata, nil, nil, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
end

function tutor_pay_ad_4()
	local function callback()
		show_pay_ad();
		return;
	end
	if nil == layer_lottery.layer then callback(); return; end
	if 1 >= #(layer_lottery.list or {}) then callback(); return; end
	local width = layer_lottery.cwidth;
	local height = layer_lottery.cheight;
	local th = layer_lottery.theight;
	local x, y = layer_lottery.tableview:getPosition();
	local fdata = { x=x+width/2, y=y+th-2*height+height/2, width=width, height=height, use_circle=false };
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
end

function tutor_pay()
	local function callback()
		util.set_tutor(TUTOR_PAY, true, true);
	end
	if nil == layer_pay.layer then return false; end
	if 0 == #(layer_pay.list or {}) then return false; end
	local width = layer_pay.cwidth;
	local height = layer_pay.cheight;
	local th = layer_pay.theight;
	local x, y = layer_pay.tableview:getPosition();
	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT/8*7);
	local fdata = { x=x+width/2, y=y+th-height+height/2, width=width, height=height, use_circle=false };
	local cliplist = { fdata };
	local tip = "购买后获得100水晶并成为月卡会员资格,月卡会员可每日获得100水晶(价值10元)赠送";
	local layer, name = layer_dragtutorial:create(cliplist, fdata, nil, pos, tip, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
	return true;
end

function tutor_deck()
	local btn = layer_map.btn_deck;
	if nil == btn then return false; end
	local fdata = layer_dragstory.get_sprite_data(btn, false);
	local function callback()
		g_tutor_wait_net = tutor_deck_2;
		g_scene:deck();
		--tutor_deck_2();
	end
	fdata.x = fdata.x + fdata.width/2;
	fdata.y = fdata.y + fdata.height/2;
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);

	return true;
end

function tutor_deck_2()
	g_tutor_wait_net = nil;
	local function callback()
		local self = layer_deck;
		local info = self.list_slot[1];
		if nil == info then return; end
		self:move_card('slot', 'deck', info.card, 1);
		tutor_deck_3();
	end
	if nil == layer_deck.layer then return; end
	if 0 == #(layer_deck.list_deck or {}) then return; end
	if 0 == #(layer_deck.list_slot or {}) then return; end
	local width = layer_deck.cwidth_slot;
	local height = layer_deck.cheight_slot;
	local x, y = layer_deck.tableview_slot:getPosition();
	local twidth = layer_deck.twidth_slot;
	local fdata = { x=x+width/2, y=y+height/2, width=width, height=height, use_circle=false };
	width = layer_deck.cwidth_deck;
	height = layer_deck.cheight_deck;
	x, y = layer_deck.tableview_deck:getPosition();
	twidth = layer_deck.twidth_deck;
	local tdata = { x=x+twidth/2, y=y+height/2, width=twidth, height=height, use_circle=false };
	local layer, name = layer_dragstory:create(fdata, tdata, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
end

function tutor_deck_3()
	local btn = layer_deck.btn_back;
	if nil == btn then return false; end
	local fdata = layer_dragstory.get_sprite_data(btn, false);
	local function callback()
		layer_deck.callback_ask_return();
		tutor_deck_4();
	end
	fdata.x = fdata.x + fdata.width/2;
	fdata.y = fdata.y + fdata.height/2;
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);

	return true;
end

function tutor_deck_4()
	local btn = layer_tip.btn_confirm;
	if nil == btn then return false; end
	local fdata = layer_dragstory.get_sprite_data(btn, false);
	local function callback()
		layer_tip.confirm();
	end
	local bg = layer_tip.bg;
	local bx, by = bg:getPosition();
	local bsize = bg:getContentSize();
	fdata.x = fdata.x + bx - bsize.width/2;
	fdata.y = fdata.y + fdata.height/2 + by - bsize.height/2;
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);

	return true;
end

-- /////////////////////// TUTOR END   ///////////////////////////

-- /////////////////////// GUI START ///////////////////////////
GUI_LOGIN      = 1;
GUI_MAIN       = 2;
GUI_MATCH      = 3;
GUI_PRACTICE   = 4;
GUI_DECK       = 5;
GUI_ROLE       = 8;
GUI_PLAYERINFO = 9;
GUI_VIDEO      = 10;
GUI_QUICK      = 11;
GUI_ARENA      = 12;
GUI_SHOP       = 13;
GUI_RANK       = 14;
GUI_GM         = 15;
GUI_NOTICE     = 16;
GUI_OPTION     = 17;
GUI_FRIEND     = 18;
GUI_PAY        = 19;
GUI_LGUILD     = 20;
GUI_WELFARE    = 21;
GUI_GUILD      = 22;
GUI_MEMBER     = 23;
GUI_APPROVE    = 24;
GUI_STOCK      = 25;
GUI_INVEST     = 26;
GUI_RECORD     = 27;
GUI_MISSION    = 28;
GUI_ROOM       = 29;
GUI_LMATCH     = 30;
GUI_PRANK      = 31;
GUI_MAIL       = 32;
GUI_SERVICE    = 33;
GUI_GATE       = 34;
GUI_LOTTERY    = 35;
GUI_PAY_AD     = 36;
--GUI_TOWER      = 37;

gui_list = {};

function gui_flag_bool(flag)
	local b = false;
	if 1 == flag then
		b = true;
	end
	return b;
end

function gui_psd_xy(xpsd, ypsd, width, height, ltype)
	local size = SCREEN_SIZE_REF;
	local x = xpsd;
	local y = size.height - ypsd - height;

	return x, y;
end

function gui_get_list(ltype)
	local list = gui_list[ltype] or {};
	return list;
end

function print_gui_data(data)
	print('--------');
		local str = string.format("[%s][%s][%s][%s][%s][%s][%s][%s][%s][%s][%s]", data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8], data[9], data[10], data[11]);
		print('str : ', str);
	print('--------');
end

gui_info = {
	{ key = GUI_LOGIN, file = 'ui_login.csv' };
	{ key = GUI_MAIN, file = 'ui_main.csv' };
	{ key = GUI_MATCH, file = 'ui_match.csv' };
	{ key = GUI_PRACTICE, file = 'ui_practice.csv' };
	{ key = GUI_DECK, file = 'ui_deck.csv' };
	{ key = GUI_ROLE, file = 'ui_role.csv' };
	{ key = GUI_PLAYERINFO, file = 'ui_playerinfo.csv' };
	{ key = GUI_VIDEO, file = 'ui_video.csv' };
	{ key = GUI_QUICK, file = 'ui_quick.csv' };
	{ key = GUI_ARENA, file = 'ui_arena.csv' };
	{ key = GUI_SHOP, file = 'ui_shop.csv' };
	{ key = GUI_RANK, file = 'ui_rank.csv' };
	{ key = GUI_GM, file = 'ui_gm.csv' };
	{ key = GUI_NOTICE, file = 'ui_notice.csv' },
	{ key = GUI_OPTION, file = 'ui_option.csv' },
	{ key = GUI_FRIEND, file = 'ui_friend.csv' },
	{ key = GUI_PAY, file = 'ui_pay.csv' },
	{ key = GUI_LGUILD, file = 'ui_lguild.csv' },
	--{ key = GUI_WELFARE, file = 'ui_welfare.csv' },
	{ key = GUI_GUILD, file = 'ui_guild.csv' },
	{ key = GUI_MEMBER, file = 'ui_member.csv' },
	{ key = GUI_APPROVE, file = 'ui_approve.csv' },
	{ key = GUI_STOCK, file = 'ui_stock.csv' },
	{ key = GUI_INVEST, file = 'ui_invest.csv' },
	{ key = GUI_RECORD, file = 'ui_record.csv' },
	{ key = GUI_MISSION, file = 'ui_mission.csv' },
	{ key = GUI_ROOM, file = 'ui_room.csv' },
	{ key = GUI_LMATCH, file = 'ui_lmatch.csv' },
	{ key = GUI_PRANK, file = 'ui_prank.csv' },
	{ key = GUI_MAIL, file = 'ui_mail.csv' },
	{ key = GUI_SERVICE, file = 'ui_service.csv' },
	{ key = GUI_GATE, file = 'ui_gate.csv' },
	{ key = GUI_LOTTERY, file = 'ui_lottery.csv' },
	{ key = GUI_PAY_AD, file = 'ui_pay_ad.csv' },
--	{ key = GUI_TOWER, file = 'ui_tower.csv' },
};

function gui_get_origin_data(key, ltype)
	local list = gui_get_list(ltype);
	local info = list[key];
	assert(nil ~= info, 'ERROR gui_get_origin_data key [' .. key .. '] is nil');
	local data = {};
	data.key = info.key;
	data.fname1 = info.filename1;
	data.fname2 = info.filename2;
	data.x = info.x * g_scale.x;
	data.y = info.y * g_scale.y;
	data.ox = info.x;
	data.oy = info.y;
	data.rwidth = info.width;
	data.rheight = info.height;
	data.width = info.width * g_scale.x;
	data.height = info.height * g_scale.y;
	data.zorder = info.zorder;
	data.istoggle = gui_flag_bool(info.istoggle);
	data.label1 = info.label1;
	data.label2 = info.label2;
	data.owidth = info.owidth;
	data.oheight = info.oheight;
	data.r = info.r;
	data.g = info.g;
	data.b = info.b;
	data.sr = info.sr;
	data.sg = info.sg;
	data.sb = info.sb;
	return data;
end

function gui_load_data(ltype, str)
	local list_line = csplit(str, "[\r\n]");
	table.remove(list_line, 1);
	table.remove(list_line, 1);
	table.remove(list_line, 1);
	local list = {};
	for i = 1, #list_line do
		local line = list_line[i];
		line = string.gsub(line, "\n", "")
--		print('gui line: ', line);
		local colomn = csplit(line, ",");
		if #colomn >= 11 then

			local key = colomn[1];
			-- if is toggle, filename1 is unselected, filename2 is selected
			local filename1 = colomn[2];
			local filename2 = colomn[3];
			local xpsd = tonumber(colomn[4]);
			local ypsd = tonumber(colomn[5]);
			local width = tonumber(colomn[6]);
			local height = tonumber(colomn[7]);
			local zorder = tonumber(colomn[8]);
			local istoggle = tonumber(colomn[9]); -- 0 false 1 true
			local label1 = colomn[10];
			local label2 = colomn[11];
			local owidth = tonumber(colomn[12]) or 0;
			local oheight = tonumber(colomn[13]) or 0;
			--local is_9scale = (0==owidth) and false or true;
			local r = tonumber(colomn[14]) or 0;
			local g = tonumber(colomn[15]) or 0;
			local b = tonumber(colomn[16]) or 0;
			local sr = tonumber(colomn[17]) or 0;
			local sg = tonumber(colomn[18]) or 0;
			local sb = tonumber(colomn[19]) or 0;
			local x, y;
			x, y = gui_psd_xy(xpsd, ypsd, width, height, ltype);
			local data = {};
			data.key = key;
			data.filename1 = filename1;
			data.filename2 = filename2;
			data.x = x;
			data.y = y;
			data.width = width;
			data.height = height;
			data.zorder = zorder;
			data.istoggle = istoggle;
			data.label1 = label1;
			data.label2 = label2;
			data.owidth = owidth;
			data.oheight = oheight;
			--data.is_9scale = is_9scale;
			data.r = r;
			data.g = g;
			data.b = b;
			data.sr = sr;
			data.sg = sg;
			data.sb = sb;
			list[key] = data;
		end
	end
	
	return list;
end;

function set_gui_list_data(foldername)
	local list_file = gui_info;
	for i = 1, #list_file do
		local info = list_file[i];
		local key = info.key;
		local filename = info.file;
		local str = open_file(F_DOCX, filename);
		local l = gui_load_data(key, str);
		local len = string.len(filename);
		l.rname = string.sub(filename, 1, len-4); 
		gui_list[key] = l;
	end
end

function gui_get_test_list()
	return gui_info;
end

function gui_load_frame(ltype)
	local list = gui_get_list(ltype);
	if nil == list then
		return nil;
	end
	local rname = list.rname;
	if nil == rname then
		return nil;
	end
	rname = rname .. '.plist';
	return rname;
end

function gui_sfactor_pos(sfactor, data)
	local size = SCREEN_SIZE_REF;
	local scale = data.width/data.rwidth;
	local x = data.ox;
	local y;
	if sfactor == ANCHOR_NULL then
		x = data.x + data.width/2 - data.rwidth/2;
		y = data.y + data.height/2 - data.rheight/2;
		local hscale = data.height / data.rheight;
		if hscale < scale then
			scale = hscale;
		end
	elseif sfactor == ANCHOR_DOWN then
		y = data.oy;
	elseif sfactor == ANCHOR_UP then
		y = FULL_HEIGHT - (size.height - (data.oy + data.rheight) + data.rheight) * scale;
	else -- elseif sfactor == ANCHOR_CENTER then
		local hscale = data.height / data.rheight;
		if hscale < scale then
			scale = hscale;
		end
		x = HALF_WIDTH - (size.width / 2 - data.ox) * scale;
		y = FULL_HEIGHT - (size.height - (data.oy + data.rheight) + data.rheight) * scale;
	end
	local npos = ccp(x, y);
	return npos, scale;
end

function gui_get_data(key, ltype, sfactor)
	local ndata = {};
	local data = gui_get_origin_data(key, ltype);
	if nil == sfactor then
		return data, nil;
	end
	local pos, scale = gui_sfactor_pos(sfactor, data);
	for k, v in pairs(data) do
		ndata[k] = v;
	end
	ndata.x = pos.x;
	ndata.y = pos.y;
	ndata.width = data.rwidth * scale;
	ndata.height = data.rheight * scale;
	return ndata, scale;
end

function gui_add_cell_bg(cell, data, width, height)
	width = width or data.width;
	height = height or data.height;
	local sprite = nil;
	local path = util.get_path(data.fname1);
	local pos = cc.p(0, 0);
	local anchor = ANCHOR_LEFT_DOWN;
	if 0 == data.owidth then
		sprite = util.add_sprite(cell, path, pos, anchor, data.zorder);
	else
		local w = data.owidth;
		local h = data.oheight;
		local frect = cc.rect(0, 0, w, h); -- fullrect
		local irect = cc.rect(w/2-2, h/2-2, 4, 4); -- insetrect
		local rsize = cc.size(width, height); -- realsize
		sprite = util.add_scale9sprite(cell, path, pos, anchor, frect, irect, rsize, data.zorder); 
		return sprite;
	end
	if nil ~= scale then
		sprite:setScale(scale);
	else
		local size = sprite:getContentSize();
		sprite:setScaleX(width/size.width);
		sprite:setScaleY(height/size.height);
	end
	return sprite;
end

function gui_add_sprite_on_cell(cell, cdata, key, ltype, sfactor)
	local sprite, data = gui_add_sprite(cell, key, ltype, sfactor);
	local x, y = sprite:getPosition();
	local pos = ccp(x - cdata.x, y - cdata.y);
	sprite:setPosition(pos);
	data.x = pos.x;
	data.y = pos.y;
	return sprite, data;
end

function gui_add_labelbmf_on_cell(cell, cdata, str, path, key, ltype, sfactor)
	local label, data = gui_add_labelbmf(cell, str, path, key, ltype, sfactor);
	local x, y = label:getPosition();
	local pos = cc.p(x - cdata.x, y - cdata.y);
	label:setPosition(pos);
	data.x = pos.x;
	data.y = pos.y;
	return label, data;
end

function gui_add_label_on_cell(cell, cdata, str, fsize, key, ltype, sfactor, color)
	local label, data = gui_add_label(cell, str, fsize, key, ltype, sfactor, color);
	local x, y = label:getPosition();
	local pos = cc.p(x - cdata.x, y - cdata.y);
	label:setPosition(pos);
	data.x = pos.x;
	data.y = pos.y;
	return label, data;
end

function gui_add_stroke_on_cell(cell, cdata, str, fsize, key, ltype, sfactor, color, scolor)
	local label, data = gui_add_stroke(cell, str, fsize, key, ltype, sfactor, color, scolor)
	local x, y = label:getPosition();
	local pos = cc.p(x - cdata.x, y - cdata.y);
	label:setPosition(pos);
	data.x = pos.x;
	data.y = pos.y;
	return label, data;
end

function gui_add_item_on_cell(items, cdata, key, ltype, callback, sfactor)
	local item, data = gui_add_item(items, key, ltype, callback, sfactor);
	local x, y = item:getPosition();
	local pos = cc.p(x - cdata.x, y - cdata.y);
	item:setPosition(pos);
	data.x = pos.x;
	data.y = pos.y;
	return item, data;
end

function gui_add_sprite(layer, key, ltype, sfactor, offsety, offsetheight)
	offsety = offsety or 0;
	offsetheight = offsetheight or 0;
	local data, scale = gui_get_data(key, ltype, sfactor);
	local fname = data.fname1;
	local pos = ccp(data.x, data.y + offsety);
	local anchor = ANCHOR_LEFT_DOWN;
	local width = data.width;
	local height = data.height + offsetheight;
	data.y = pos.y;
	data.height = height;
	local sprite = nil;
	local path = util.get_path(fname);
	if 0 == data.owidth then
		sprite = util.add_sprite(layer, path, pos, anchor, data.zorder);
	else
		local w = data.owidth;
		local h = data.oheight;
		local frect = cc.rect(0, 0, w, h); -- fullrect
		local irect = cc.rect(w/2-2, h/2-2, 4, 4); -- insetrect
		local rsize = cc.size(width, height); -- realsize
		sprite = util.add_scale9sprite(layer, path, pos, anchor, frect, irect, rsize, data.zorder); 
		return sprite, data;
	end
	if nil ~= scale then
		sprite:setScale(scale);
	else
		local size = sprite:getContentSize();
		sprite:setScaleX(width/size.width);
		sprite:setScaleY(height/size.height);
	end
	return sprite, data;
end

function gui_add_mask_image(layer, path, mask_path, key, ltype, sfactor)
	local data, scale = gui_get_data(key, ltype, sfactor);
	local pos = ccp(data.x, data.y);
	local sprite = util.add_mask_sprite(layer, path, mask_path, pos, ANCHOR_LEFT_DOWN, data.zorder);
	sprite:setAnchorPoint(ANCHOR_LEFT_DOWN);
	local x, y = sprite:getPosition();
	sprite:setScale(scale);
	return sprite;
end

function gui_add_sprite_tip(layer, key, ltype, sfactor)
	local data, scale = gui_get_data(key, ltype, sfactor);
	local fname = data.fname1;
	local pos = ccp(data.x + data.width/2, data.y + data.height/2);
	local anchor = ANCHOR_CENTER_CENTER;
	local width = data.width;
	local height = data.height;
	local fullpath = util.get_fullpath(F_IMAGE, fname);
	local sprite = util.add_sprite(layer, fullpath, pos, anchor, data.zorder);
	if nil ~= scale then
		sprite:setScale(scale);
	else
		local size = sprite:getContentSize();
		local s1 = width / size.width;
		local s2 = height / size.height;
		if s1 < s2 then
			sprite:setScale(s1);
		else
			sprite:setScale(s2);
		end
	end
	return sprite, data;
end

function gui_add_text_on_sprite(sprite, text, key, ltype, sfactor, size, color)
	local data = gui_get_data(key, ltype, sfactor);
	color = color or cc.c3b(data.r, data.g, data.b);
	local label = util.add_text_to_sprite(sprite, text, size, color);
	return label, data;
end

function gui_add_text_on_sprite_2(sprite, text, data, size, color)
	color = color or cc.c3b(data.r, data.g, data.b);
	local label = util.add_text_to_sprite(sprite, text, size, color);
	return label;
end

function gui_add_text_outline_on_sprite(sprite, text, key, ltype, sfactor, size, color, outline_color)
	local data = gui_get_data(key, ltype, sfactor);
	color = color or cc.c4b(data.r, data.g, data.b, 255);
	outline_color = outline_color or cc.c4b(data.sr, data.sg, data.sb, 255);
	local label = util.add_text_outline_to_sprite(sprite, text, size, color, outline_color, 2);
	return label, data;
end

function gui_add_item(items, key, ltype, callback, sfactor, offsety, offsetheight)
	offsety = offsety or 0;
	offsetheight = offsetheight or 0;
	local data, scale = gui_get_data(key, ltype, sfactor);
	local fname1 = data.fname1;
	local fname2 = data.fname2;
	local mark = true;
	if true ~= util.check_file(fname2) then
		fname2 = fname1;
		mark = false;
	end
	local width = data.width;
	local height = data.height + offsetheight;
	local path, path1, path2, sprite, unsprite, size;
	path1 = util.get_path(fname1);
	path2 = util.get_path(fname2);
	if 0 == data.owidth then
		unsprite = util.create_sprite(path1);
		sprite = util.create_sprite(path2);
	else
		local w = data.owidth;
		local h = data.oheight;
		local frect = cc.rect(0, 0, w, h); -- fullrect
		local irect = cc.rect(w/2-2, h/2-2, 4, 4); -- insetrect
		local rsize = cc.size(width, height); -- realsize
		unsprite = util.create_scale9sprite(path1,frect,irect,rsize);
		sprite = util.create_scale9sprite(path2,frect,irect,rsize);
	end

	local label1 = data.label1;
	local label2 = data.label2;
	if nil ~= unsprite and nil ~= label1 and '0' ~= label1 then
		if nil==label2 or '0'==label2 or true~=util.check_file(label2) then
			label2 = label1;
		end
		path = util.get_path(label1);
		local p = cc.p(data.rwidth / 2, data.rheight / 2);
		util.add_sprite(unsprite, path, p, ANCHOR_CENTER_CENTER, 1);
	end
	if nil ~= sprite and nil ~= label2 and '0' ~= label2 then
		path = util.get_path(label2);
		local p = cc.p(data.rwidth / 2, data.rheight / 2);
		util.add_sprite(sprite, path, p, ANCHOR_CENTER_CENTER, 1);
	end

	local pos = ccp(data.x, data.y + offsety);
	data.y = pos.y;
	data.height = height;
	local anchor = ANCHOR_LEFT_DOWN;
	
	local item;
	if true == data.istoggle then
		item=util.create_toggle_sprite(unsprite,sprite,pos,anchorpoint,callback);
	else
		if true ~= mark then
			sprite:setScale(1.1);
		end
		item=util.create_item_sprite(unsprite, sprite, pos,anchorpoint,callback);
	end
	if 0 == data.owidth then
		if nil ~= scale then
			item:setScale(scale);
		else
			local size = item:getContentSize();
			item:setScaleX(width/size.width);
			item:setScaleY(height/size.height);
		end
	end
	if nil ~= items then
		table.insert(items, item);
	end
	return item, data;
end

function gui_add_editbox(layer, key, ltype, sfactor, fsize, callback, max_length, place_holder, color)
	local data, scale = gui_get_data(key, ltype, sfactor);
	local pos = cc.p(data.x, data.y);
	local size = cc.size(data.width, data.height);
	color = color or cc.c3b(data.r, data.g, data.b);
	local editbox = util.add_editbox_blank(layer, size, ANCHOR_LEFT_DOWN, 
		pos, util.f_default, fsize, color, cc.EDITBOX_INPUT_MODE_SINGLELINE, 
		cc.KEYBOARD_RETURNTYPE_DONE, nil, callback, max_length, place_holder,
		color, data.zorder);
	return editbox, data;
end

function gui_add_label_ali(layer, str, fsize, key, ltype, sfactor, alignment, color, offsety, offsetheight)
	offsety = offsety or 0;
	offsetheight = offsetheight or 0;
	local data, scale = gui_get_data(key, ltype, sfactor);
	local pos, width, height;
	local pos = ccp(data.x, data.y + offsety);
	local width = data.width;
	local height = data.height + offsetheight;
	local r = data.r;
	local g = data.g;
	local b = data.b;
	color = color or cc.c4b(r, g, b, 255);
	local label = util.add_labelttf(layer, str, nil, fsize, pos, color, ANCHOR_LEFT_DOWN, data.zorder, cc.size(width, height), alignment, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);
	label:setScale(scale);
	data.y = pos.y;
	data.height = height;
	return label, data;
end

function gui_add_label(layer, str, fsize, key, ltype, sfactor, color, offsety, offsetheight)
	local alignment = cc.TEXT_ALIGNMENT_LEFT;
	local label, data = gui_add_label_ali(layer, str, fsize, key, ltype, sfactor, alignment, color, offsety, offsetheight);
	return label, data;
end

function gui_add_stroke(layer, str, fsize, key, ltype, sfactor, color, scolor)
	local data, scale = gui_get_data(key, ltype, sfactor);
	local pos, width, height;
	local pos = ccp(data.x, data.y);
	local width = data.width;
	local height = data.height;
	local r = data.r;
	local g = data.g;
	local b = data.b;
	color = color or cc.c4b(r, g, b, 255);
	local sr = data.sr;
	local sg = data.sg;
	local sb = data.sb;
	scolor = scolor or cc.c4b(sr, sg, sb, 255);
	local outline_size = 1;
	-- kelton:
	-- height * 2 is for fit the string while the font size is to large
	local label = util.add_labeloutline(layer, str, nil, fsize, pos, color, scolor, outline_size, ANCHOR_LEFT_DOWN, data.zorder, cc.size(width, height*2), cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);
	label:setScale(scale);
	return label, data;
end

function gui_add_labeloutblack(layer, str, fsize, key, ltype, sfactor, color)
	local data, scale = gui_get_data(key, ltype, sfactor);
	local pos, width, height;
	local pos = ccp(data.x, data.y);
	local width = data.width;
	local height = data.height;
	local r = data.r;
	local g = data.g;
	local b = data.b;
	color = color or cc.c4b(r, g, b, 255);
	local outline_color = util.c4b_black;
	local outline_size = 1;
	local label = util.add_labeloutline(layer, str, nil, fsize, pos, color, outline_color, outline_size, ANCHOR_LEFT_DOWN, data.zorder, cc.size(width, height), cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);
	label:setScale(scale);
	return label, data;
end

function gui_add_labelglow(layer, str, fsize, color, glow_color,key,ltype,sfactor)
	local data, scale = gui_get_data(key, ltype, sfactor);
	local pos, width, height;
	local pos = ccp(data.x, data.y);
	local width = data.width;
	local height = data.height;
	local label = util.add_labelglow(layer, str, nil, fsize, pos, color, glow_color, ANCHOR_LEFT_DOWN, data.zorder, cc.size(width, height), cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);
	label:setScale(scale);
	return label, data;
end

function gui_add_labeloutline(layer, str, fsize,color,outline_color,outline_size,key,ltype,sfactor)
	local data, scale = gui_get_data(key, ltype, sfactor);
	local pos, width, height;
	local pos = ccp(data.x, data.y);
	local width = data.width;
	local height = data.height;
	local label = util.add_labeloutline(layer, str, nil, fsize, pos, color, outline_color, outline_size, ANCHOR_LEFT_DOWN, data.zorder, cc.size(width, height), cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);
	label:setScale(scale);
	return label, data;
end

function gui_add_labelbmf(layer, str, path, key, ltype, sfactor)
	local data, scale = gui_get_data(key, ltype, sfactor);
	local pos = ccp(data.x, data.y);
	local label = util.add_labelbmf(layer, str, path, pos, ANCHOR_LEFT_DOWN, data.zorder);
	label:setScale(scale);
	return label, data;
end
-- /////////////////////// GUI END   ///////////////////////////

-- /////////////////////// ALIAS START ///////////////////////////
function load_alias_data()
	local str = open_file(F_DOCX, "evil_alias.csv");
	--alias_list = alias_read_data(str);
	local list_line = csplit(str, "[\r\n]");
	for i = 1, 6 do
		table.remove(list_line, 1);
	end
	local l_prefix = {};
	local l_boy = {};
	local l_girl = {};
	for i = 1, #list_line do
		local line = list_line[i];
		line = string.gsub(line, "\n", "")
		--print('line: ', line);
		local colomn = csplit(line, ",");
		if #colomn == 4 then
			local rid = colomn[1];
			local prefix = colomn[2];
			local boy = colomn[3];
			local girl = colomn[4];
			if '0' ~= prefix then table.insert(l_prefix, prefix); end
			if '0' ~= boy then table.insert(l_boy, boy); end
			if '0' ~= girl then table.insert(l_girl, girl); end
		end
	end
	return l_prefix, l_boy, l_girl;
end
-- /////////////////////// ALIAS END   ///////////////////////////

-- /////////////////////// ANIM START ///////////////////////////
anim = {};
anim.queue = {};
anim.cache = {};
anim.eff_list = {};
anim.anim_list = {};
anim.multi_target_list = { src_index = 0, tcount = 0 };
anim.eff_hp_count = 0;
anim.eff_power_count = 0;
anim.last_rm_attach_index = 0;
anim.anim_list_length = 0;
anim.anim_list_counter = 0;

function anim.reset_data()
	anim.queue = {};
	anim.cache = {};
end

-- almost same as layer_action.obj_to_new_layer
-- because sprite remove from parent will remove all the running action 
--   in sprite or it's child
-- so must run these action again
function switch_layer(sprite, new_layer)
	local tlist = {};
	local children = sprite:getChildren();
	local count = sprite:getChildrenCount();
	for i = 1, count do
		local s = children[i];
		local es = s:getChildByTag(TAG_STATUS_SPRITE);
		if nil ~= es then
			local action = es:getActionByTag(TAG_STATUS_EFF);
			if nil ~= action then
				action:retain();
				tlist[#tlist + 1] = { sprite = es, action = action }; 
			end
		end
		--[[
		--local s = children:objectAtIndex(i);
		--s = tolua.cast(s, "cc.Node");
		local action = s:getActionByTag(TAG_VIRTUAL_ACTION);
		if nil ~= action then
			action:retain();
			tlist[#tlist + 1] = { sprite = s, action = action }; 
		end
		]]--
	end
	sprite:retain();
	sprite:removeFromParentAndCleanup(true);
	new_layer:addChild(sprite, ZORDER_CARD);
	for i = 1, #tlist do
		local s = tlist[i].sprite;
		local action = tlist[i].action;
		s:runAction(action);
		action:release();
	end
	sprite:release();
	return sprite;
end

-- use in anim_action_anim, anim_action_map_damage
-- for the case that attack multi targets, show the eff at the same time
-- then show the hurt eff one after one
function anim_set_tlist_src(src_index)
	anim.multi_target_list.src_index = src_index;
	anim.multi_target_list.tcount = 0;
end
function anim_insert_tlist(index)
	if nil == index then
		return;
	end
	anim.multi_target_list.tcount = anim.multi_target_list.tcount + 1;
end
function anim_remove_tlist(src_index, is_remove_all)
	if true == is_remove_all then
		anim.multi_target_list = { src_index = 0, tlist = {} };
		return false;
	end
	--print('src_index, src: ', src_index, anim.multi_target_list.src_index);
	if src_index ~= anim.multi_target_list.src_index then
		return false;
	end
	anim.multi_target_list.tcount = anim.multi_target_list.tcount - 1;
	if 0 == anim.multi_target_list.tcount then
		anim.multi_target_list.src_index = 0;
	end
	return true;
end

function anim_preprocess_efflist(list, front_index)
	list = list or {};

	if 0 == #list then
		--anim_return('preprocess_efflist 0==#list'); -- do it outside
		return list;
	end

	-- usually, 'card' is the first eff
	-- but, in sacrifice, next, no eff 'card' come
	--[[
	[LUA] effect list: #eff_list=2
	[LUA]     EFF card, id=47, index=1301, |
	[LUA]     EFF damage, target_index=2101, dtype=1, src_index=1301, power=1, |
	-----------
	[LUA] effect list: #eff_list=3
	[LUA]     EFF move, src_index=2202, target_index=2701, |
	[LUA]     EFF resource_max, side=1, offset=1, |
	[LUA]     EFF phase, |
	]]--
	local use_index = nil;
	local fisrt_src_index = nil;
	if 'card' == list[1][1] then
		list[1].front_index = nil;--front_index;
		use_index = list[1].index;
		list[2].front_index = use_index;
		first_src_index = use_index;
	else
		list[1].front_index = nil;--front_index;
		first_src_index = list[1].src_index;
	end
	if nil ~= front_index and first_src_index ~= front_index then
		alog('DEBUG preprocess add scale_back: ', front_index);
		local eff = {'scale_back', index = front_index};
		table.insert(list, 1, eff);
	end

	-- TODO LOG
	for i = 1, #list do
		local eff = list[i];
		alog('eff ', eff[1]);
	end

	return list;
end

function efflist_to_anim(list) -- {
	local anim_info = { has_anim = false, anim_group = {} };

	if nil == list then
		-- the first eff_list is nil, so eff_group is empty
		alog('DEBUG eff_list == nil');
		return anim_info;
	end

	if 0 == #list then
		alog('DEBUG #eff_list <= 0');
		return anim_info;
	end

	-- make anim group
	if 0 < #list then
		alog('DEBUG efflist_to_anim before make_anim,#list: ', list[1][1], #list);
	end
	anim_group = make_anim(list[1]);
	table.remove(list, 1);
	if 0 < #list then
		alog('DEBUG efflist_to_anim after make_anim, #list: ', list[1][1], #list);
	end

	if nil ~= anim_group then
		--anim_info[1] = true;
		anim_info.has_anim = true;
	end
	anim_info.anim_group = anim_group;

	return anim_info;
end -- efflist_to_anim }

function run_anim(animation, anim_list)
	--alog('DEBUG do run_anim #animation, #anim_list: ', #animation, #anim_list);
	anim.anim_list_length = #animation;
	anim.anim_list_counter = 0;

	for i = 1, #animation do
		run_sprite_actions(animation[i]);	
	end
	table.remove(anim_list, 1);
	--alog('DEBUG end run_anim #anim_list: ', #anim_list);
end

-- @see in logic.lua index_side(index)
function anim_index_side(index)
	return index_side(index);
	--[[
	local s;
	-- avoid attach
	if index >= 10000 then
		index = math.floor(index / 10);
	end

	s = math.floor(index / 1000);
	if s < 1 or s > 2 then
		print('BUG anim_index_side out of range: ', index);
	end
	return s;
	]]--
end

-- @see in logic.lua index_table_num(index)
function anim_index_table_num(index)
	return index_table_num(index);
	--[[
	local tbindex;
	index = tonumber(index) or 9999;
	-- avoid attach
	if index >= 10000 then
		index = math.floor(index / 10);
	end
	tbindex = math.floor((index % 1000) / 100);
	return tbindex;
	]]--
end

-- @see in logic.lua index_offset(index)
function anim_index_offset(index)
	return index_offset(index);
	--[[
	-- avoid attach
	if index >= 10000 then
		index = math.floor(index / 10);
	end
	return index % 100;
	]]--
end

--[[
local src_table_index, src_list_index, src_card_list, src_card;
src_table_index, src_list_index, src_card_list, src_card 
	= anim_get_info(src_index);
local tar_table_index, tar_list_index, tar_card_list, tar_card;
tar_table_index, tar_list_index, tar_card_list, tar_card 
	= anim_get_info(tar_index);
local front_table_index, front_list_index, front_card_list, front_card;
front_table_index, front_list_index, front_card_list, front_card 
	= anim_get_info(front_index);
]]--
function anim_get_info(index)
	if nil == index then
		return;
	end
	local side_index = anim_index_side(index);
	local table_index = anim_index_table_num(index);
	local list_index = anim_index_offset(index);
	local table_side = g_ui_table[side_index];
	if nil ==  table_side then
		return table_index, list_index, nil, nil;
	end
	local table_list = table_side[table_index];
	if nil ==  table_list then
		return table_index, list_index, table_list, nil;
	end
	local card = table_list[list_index];

	--alog('DEBUG anim_get_info index, table_index, list_index, #table_list: ', index, table_index, list_index, #table_list);
	return table_index, list_index, table_list, card;
end

function anim_get_card_info(index)
	return get_ui_card(index);
end

function anim_get_npos(index)
	local table_index, list_index, list, info = anim_get_info(index);
	local pos = cc.p(list.x, list.y);
	local cwidth = list.cwidth;
	local limit = list.width / cwidth;

	if table_index ~= T_GRAVE and table_index ~= T_HERO and
	   table_index ~= T_DECK and table_index ~= T_RES then
	   
	   	local offset = list_index - 1;
		if list_index > limit then
			offset = limit - 1;
		end
		pos.x = pos.x + offset * cwidth;
	end
	return pos;
end

-- action is 'insert' or 'remove'
function anim_arrange_list(index, anim_list, action)
	local table_index, list_index, list, info = anim_get_info(index);
	local cscale = list.cscale;
	if table_index == T_GRAVE or table_index == T_DECK or table_index==T_RES then
		return;
	end

	for i = 1, #list do
		local info = list[i];
		local sprite = anim_get_sprite(info);
		local pos;
		local rotation = 0;
		pos, rotation = anim_get_card_pos_rotation(list, i);

		info.frame.x = pos.x;
		info.frame.y = pos.y;
		info.frame.rotation = rotation;
		info.frame.zorder = ZORDER_CARD;
		info.t_index = table_index;
		if 'remove' == action or i ~= list_index then
			anim_list[#anim_list + 1] = {
				sprite = sprite,
				anims = {
					{ anim_name = 'spawn', 
					  anim_parts = {
						  { anim_part = 'move', pos = pos },
						  { anim_part = 'rotate', rotation = rotation },
						  { anim_part = 'scale', scale = cscale },
					  },
					},
				},
			};
		end
	end
end

function anim_arrange_grave(tar_index, anim_list, action)
	local side = anim_index_side(tar_index);
	local lindex = anim_index_offset(tar_index);
	local ui_table = g_ui_table[side][T_GRAVE];
	local len = ui_table.pic_len or 1;
	if #ui_table < len then
		len = #ui_table;
	end
	local scale = ui_table.pic_scale;
	local index = 1;
	for i = #ui_table, 1, -1 do
		local info = ui_table[i];
		local pos = info:get_grave_pos(ui_table, index);
		if nil ~= pos then
			local sprite = anim_get_sprite(info);
			--local sprite = info:change_grave(pos, ui_table.pic_scale);
			if i == lindex then
				if 'remove' == action then
					-- no need to remove the sprite
					--info:remove_sprite();
				else
					--sprite:setScale(0);
					anim_list[#anim_list + 1] = {
						sprite = sprite,
						anims = {
							{ anim_name = 'spawn', 
							  anim_parts = {
								  { anim_part = 'scale', scale = scale },
							  },
							},
					        { anim_name='to_grave', ui_table = ui_table, index = index, info = info },
						},
					};
				end
			elseif index == len + 1 then
				anim_list[#anim_list + 1] = {
					sprite = sprite,
					anims = {
						{ anim_name = 'hide' },
					},
				};
			else
				anim_list[#anim_list + 1] = {
					sprite = sprite,
					anims = {
						{ anim_name = 'spawn', 
						  anim_parts = {
							  { anim_part = 'move', pos = pos },
							  { anim_part = 'rotate', rotation = 1 },
						  },
						},
					},
				};
			end
			index = index + 1;
			if index > len + 1 then
				break;
			end
		end
	end
end

function callback_front(...)
	local arg = {...}
	local sprite = arg[1];
	if nil == sprite then
		alog('BUG nil == sprite');
		return nil;
	end
	local layer = sprite:getParent();
	layer:reorderChild(sprite, ZORDER_SHOWING);
end

function anim_callback_remove(...)
	local args = { ... };
	local sprite = args[1];
	sprite:removeFromParentAndCleanup(true);
	alog('DEBUG do anim_callback_remove');
end

function callback_table(...)
	local arg = {...};
	local sprite = arg[1];
	if nil == sprite then
		alog('BUG nil == sprite');
		return nil;
	end
	local layer = sprite:getParent();
	layer:reorderChild(sprite, ZORDER_CARD);
end

function callback_play_eff(...)
	local args = { ... };
	local sprite = args[1];
	sprite:removeFromParentAndCleanup(true);

	local cache = cc.SpriteFrameCache:getInstance();
	cache:removeUnusedSpriteFrames();
end

function anim_csprite_info(sprite)
	if nil == sprite then
		return nil, nil, nil;
	end
	local size = sprite:getContentSize();
	local scale = sprite:getScaleY();
	local rscale = sprite:getScale() * 2;
	rscale = 1;
	local rsize = cc.size(size.width*scale, size.height*scale);
	local rpos = cc.p(sprite:getPositionX(), sprite:getPositionY());
	return rsize, rscale, rpos;
end

function a_play_eff_show(sprite, delay, is_show)
	if nil == sprite then
		return;
	end
	local array, action;
	array = {};
	action = cc.DelayTime:create(delay);
	table.insert(array, action);
	if true == is_show then
		action = cc.CallFunc:create(a_particle_sac);
		table.insert(array, action);
		action = cc.DelayTime:create(0.4);
		table.insert(array, action);
		action = cc.Show:create();
		table.insert(array, action);
	else
		action = cc.Hide:create();
		table.insert(array, action);
		action = cc.CallFunc:create(a_particle_sac);
		table.insert(array, action);
	end
	action = cc.Sequence:create(array);
	sprite:runAction(action);
end

-- eff image size is ref from half size of the card(365x512), see in gui.lua
-- so the scale factor should be card_sprite:getScale() * 2
function play_eff(layer, ekind, fsprite, tsprite, step, eff, callback)
	step = step or 0;
	eff = eff or false;
	
	local fsize, fscale, fpos = anim_csprite_info(fsprite);
	local tsize, tscale, tpos = anim_csprite_info(tsprite);
	local time = 0;
	local ename = string.format("s_%d", ekind);
	local list = {};
	if 0 == step or 1 == step then
		local l = { 
			pos = fpos, step = 1, size = fsize,
			csprite = fsprite, 
			radius = 4, ap = ANCHOR_CENTER_CENTER, scale = fscale 
		};
		table.insert(list, l);
		--[[
		l = { 
			pos = fpos, tpos = tpos, size = fsize, tsize = tsize,
			step = 0, ap = ANCHOR_CENTER_CENTER, scale = (fscale+tscale)/2
		};
		table.insert(list, l);
		]]--
	end
	if 0 == step or 2 == step then
		local l = { -- the number of fly effect should match the hurt effect  
			pos = fpos, tpos = tpos, size = fsize, tsize = tsize,
			step = 0, ap = ANCHOR_CENTER_CENTER, scale = (fscale+tscale)/2
		};
		table.insert(list, l);
		l = { 
			pos = tpos, step = 2, size = tsize,
			csprite = tsprite, 
			radius = 8, ap = ANCHOR_CENTER_CENTER, scale = tscale 
		};
		table.insert(list, l);
	end
	if 0 == step or 3 == step then
		local l = { 
			pos = ccp(HALF_WIDTH, HALF_HEIGHT), step = 3,
			ap = ANCHOR_CENTER_CENTER, scale = 1 
		};
		table.insert(list, l);
	end

	local cache = cc.SpriteFrameCache:getInstance();
	for i = 1, #list do
		local info = list[i];
		local step = info.step;
		local pos = info.pos;
		local ap = info.ap;
		local size = info.size;
		local scale = info.scale;
		local filename = string.format("%s_%d.plist", ename, step);
		if true == util.check_file(filename) then
			info.is_attacker_atnormal = false;
			local fullpath = util.get_fullpath(F_ANIM, filename);	
			cache:addSpriteFrames(fullpath);

			filename = string.format("%s_%d_1.png", ename, step);
			local sprite = cc.Sprite:createWithSpriteFrameName(filename);
			sprite:setPosition(pos);
			sprite:setAnchorPoint(ap);
			--sprite:setScale(scale);
			layer:addChild(sprite, ZORDER_EFFECT);
			local animation = cc.Animation:create();
			local len = 0;
			filename = string.format("%s_%d_%d.png", ename, step, 1);
			local frame = cache:spriteFrameByName(filename);
			repeat
				len = len + 1;
				animation:addSpriteFrame(frame);
				local filename = string.format("%s_%d_%d.png", ename, step, len);
				frame = cache:spriteFrameByName(filename);
			until nil == frame;
			local pt = 0.1;
			if len > 5 then
				pt = 0.07;
			end
			animation:setDelayPerUnit(pt);
			local t = pt * len;
			time = time + t;

			info.animation = animation;
			info.sprite = sprite;
			info.time = t;
		elseif 1 == step then
			info.is_attacker_atnormal = true;
			info.sprite = fsprite;
		end
	end

	local delay = 0;
	if 'e_hide' == eff and (0 == step or 1 == step) then
		a_play_eff_show(fsprite, delay, false);
	end
	for i = 1, #list do
		local info = list[i];
		local animation = info.animation;
		local csprite = info.csprite;
		local radius = info.radius;
		local sprite = info.sprite;
		local step = info.step;
		if 1 == step and true == info.is_attacker_atnormal and nil ~= sprite then
			local action, array, sarray, scale;
			local x = sprite:getPositionX();
			local y = sprite:getPositionY();
			scale = sprite:getScale();
			local svv = 1;
			if y > HALF_HEIGHT then
				svv = -1;
			end
			array = {};
			table.insert(array, cc.DelayTime:create(delay));
			sarray = {};
			action = cc.ScaleTo:create(0.2, scale + 0.05);
			table.insert(array, action);
			action = cc.ScaleTo:create(0.1, scale + 0.03);
			table.insert(array, action);

			sarray = {};
			action = cc.ScaleTo:create(0.2, scale + 0.01);
			table.insert(sarray, action);
			action = cc.MoveTo:create(0.2, cc.p(x, y + svv*15));
			table.insert(sarray, action);
			action = cc.Spawn:create(sarray);
			action = cc.EaseIn:create(action, 0.1);
			table.insert(array, action);
			action = cc.Sequence:create(array);
			sprite:runAction(action);
			delay = delay + 0.4;

			array = {};
			table.insert(array, cc.DelayTime:create(delay + 0.1));
			sarray = {};
			action = cc.RotateTo:create(0.2, 0);
			table.insert(sarray, action);
			action = cc.ScaleTo:create(0.1, scale);
			table.insert(sarray, action);
			action = cc.MoveTo:create(0.1, cc.p(x, y));
			table.insert(sarray, action);
			action = cc.Spawn:create(sarray);
			table.insert(array, action);
			action = cc.Sequence:create(array);
			sprite:runAction(action);

		elseif nil ~= animation and nil ~= info.sprite then
			local t = info.time;
			local tpos = info.tpos;
			local pos = info.pos;
			local tsize = info.tsize;
			local scale = info.scale;

			local array = {};
			table.insert(array, cc.Hide:create());
			table.insert(array, cc.DelayTime:create(delay));
			table.insert(array, cc.Show:create());
			if nil ~= tpos then
				local spawns = {};
				local action = cc.MoveTo:create(t, tpos);
				table.insert(spawns, action);
				table.insert(spawns, cc.Animate:create(animation));
				table.insert(array, cc.Spawn:create(spawns));

				local pp = cc.p(tpos.x-pos.x, tpos.y-pos.y);
				local r = math.atan2(pp.y, pp.x);
				local r1 = r * 360 / ( 2 * 3.14 );
				local r2 = 90 - r1;
				sprite:setRotation(r2);
				
				if nil ~= tsize then
					local s = sprite:getContentSize();
					sprite:setScale(scale);
				end
			else
				table.insert(array, cc.Animate:create(animation));
			end
			table.insert(array, cc.CallFunc:create(callback_play_eff));
			if i == #list and nil ~= callback then
				table.insert(array, cc.CallFunc:create(callback));
			end
			sprite:runAction(cc.Sequence:create(array));

			if nil ~= csprite then
				csprite:shake(0.2, radius, delay+0.1);
			end

			delay = delay + t;
		end
	end
	local flag = fsprite:isVisible();
	if false == flag and (0 == step or 2 == step or 3 == step) then
		a_play_eff_show(fsprite, delay, true);
	end

	return delay;
end

-- eff image size is ref from half size of the card(365x512), see in gui.lua
-- so the scale factor should be card_sprite:getScale() * 2
function play_animation(layer, ekind, fsprite, tsprite, step, eff, callback)
	step = step or 0;
	eff = eff or false;
	
	local fsize, fscale, fpos = anim_csprite_info(fsprite);
	local tsize, tscale, tpos = anim_csprite_info(tsprite);
	local time = 0;
	local ename = string.format("s_%d", ekind);
	local list = {};
	if 0 == step or 1 == step then
		local l = { 
			pos = fpos, step = 1, size = fsize,
			csprite = fsprite, 
			radius = 4, ap = ANCHOR_CENTER_CENTER, scale = fscale 
		};
		table.insert(list, l);
		--[[
		l = { 
			pos = fpos, tpos = tpos, size = fsize, tsize = tsize,
			step = 0, ap = ANCHOR_CENTER_CENTER, scale = (fscale+tscale)/2
		};
		table.insert(list, l);
		]]--
	end
	if 0 == step or 2 == step then
		local l = { -- the number of fly effect should match the hurt effect  
			pos = fpos, tpos = tpos, size = fsize, tsize = tsize,
			step = 0, ap = ANCHOR_CENTER_CENTER, scale = (fscale+tscale)/2
		};
		table.insert(list, l);
		l = { 
			pos = tpos, step = 2, size = tsize,
			csprite = tsprite, 
			radius = 8, ap = ANCHOR_CENTER_CENTER, scale = tscale 
		};
		table.insert(list, l);
	end
	if 0 == step or 3 == step then
		local l = { 
			pos = ccp(HALF_WIDTH, HALF_HEIGHT), step = 3,
			ap = ANCHOR_CENTER_CENTER, scale = 1 
		};
		table.insert(list, l);
	end

	local function handler(armatureBack, movementType, movementID)
		-- armatureBack is ccs.Armature
		--ccs.MovementEventType = {
	--		start = 0,
	--		complete = 1,
	--		loopComplete = 2, 
	--	}
		if movementType == ccs.MovementEventType.complete then
			armatureBack:removeFromParentAndCleanup(true);
			cc.SpriteFrameCache:getInstance():removeUnusedSpriteFrames();
		end
	end

	local function play_it(...)
		local args = {...};
		local armature = args[1];
		local animation = armature:getAnimation();
		animation:setMovementEventCallFunc(handler);
		--animation:playWithIndex(0, -1, 0);
		--animation:playWithName('play');
		animation:playWithIndex(0);
	end

	for i = 1, #list do
		local info = list[i];
		local step = info.step;
		local pos = info.pos;
		local ap = info.ap;
		local size = info.size;
		local scale = info.scale;
		local fname = string.format("%s_%d", ename, step);
		local filename = string.format("%s.csb", fname);
		if true == util.check_file(filename) then
			local path = util.get_fullpath(F_ANIM, filename);	
			print('path: ', path);
			ccs.ArmatureDataManager:getInstance():removeArmatureFileInfo(path);
			ccs.ArmatureDataManager:getInstance():addArmatureFileInfo(path);

			local armature = ccs.Armature:create(fname);
			local animation = armature:getAnimation();
			--animation:setMovementEventCallFunc(handler);
			--animation:playWithIndex(0, -1, 0);
			--animation:playWithName('play');
			armature:setPosition(pos);
			--armature:setAnchorPoint(ap);
			layer:addChild(armature, ZORDER_EFFECT);

			local animation_data = animation:getAnimationData();
			local movement_data = animation_data:getMovement('play');
			print('md: ', movement_data, movement_data.duration);
			--local t = pt * len;
			local t = 0.5;
			time = time + t;

			info.animation = animation;
			info.sprite = armature;
			info.time = t;
		end
	end

	local delay = 0;
	if 'e_hide' == eff and (0 == step or 1 == step) then
		a_play_eff_show(fsprite, delay, false);
	end
	for i = 1, #list do
		local info = list[i];
		local csprite = info.csprite;
		local radius = info.radius;
		local sprite = info.sprite;
		local step = info.step;
		if nil ~= sprite then
			local t = info.time;
			local tpos = info.tpos;
			local pos = info.pos;
			local tsize = info.tsize;
			local scale = info.scale;

			local array = {};
			table.insert(array, cc.Hide:create());
			table.insert(array, cc.DelayTime:create(delay));
			table.insert(array, cc.Show:create());
			if nil ~= tpos then
				local spawns = {};
				local action = cc.MoveTo:create(t, tpos);
				table.insert(spawns, action);
				table.insert(spawns, cc.Animate:create(animation));
				table.insert(array, cc.Spawn:create(spawns));

				local pp = cc.p(tpos.x-pos.x, tpos.y-pos.y);
				local r = math.atan2(pp.y, pp.x);
				local r1 = r * 360 / ( 2 * 3.14 );
				local r2 = 90 - r1;
				sprite:setRotation(r2);
				
				if nil ~= tsize then
					local s = sprite:getContentSize();
					sprite:setScale(scale);
				end
			else
				local sa = {};
				table.insert(sa, cc.DelayTime:create(t));
				table.insert(sa, cc.CallFunc:create(play_it));
				table.insert(array, cc.Spawn:create(sa));
			end
			if i == #list and nil ~= callback then
				table.insert(array, cc.CallFunc:create(callback));
			end
			sprite:runAction(cc.Sequence:create(array));

			if nil ~= csprite then
				csprite:shake(0.2, radius, delay+0.1);
			end

			delay = delay + t;
		end
	end
	local flag = fsprite:isVisible();
	if false == flag and (0 == step or 2 == step or 3 == step) then
		a_play_eff_show(fsprite, delay, true);
	end

	return delay;
end

-- eff image size is ref from half size of the card(365x512), see in gui.lua
-- so the scale factor should be card_sprite:getScale() * 2
function play_flash(layer, ekind, fsprite, tsprite, step, eff, callback)
	step = step or 0;
	eff = eff or false;
	
	local fsize, fscale, fpos = anim_csprite_info(fsprite);
	local tsize, tscale, tpos = anim_csprite_info(tsprite);
	local time = 0;
	local ename = string.format("s_%d", ekind);
	local list = {};
	if 0 == step or 1 == step then
		local l = { 
			pos = fpos, step = 1, size = fsize,
			csprite = fsprite, 
			radius = 4, ap = ANCHOR_CENTER_CENTER, scale = fscale 
		};
		table.insert(list, l);
		--[[
		l = { 
			pos = fpos, tpos = tpos, size = fsize, tsize = tsize,
			step = 0, ap = ANCHOR_CENTER_CENTER, scale = (fscale+tscale)/2
		};
		table.insert(list, l);
		]]--
	end
	if 0 == step or 2 == step then
		local l = { -- the number of fly effect should match the hurt effect  
			pos = fpos, tpos = tpos, size = fsize, tsize = tsize,
			step = 0, ap = ANCHOR_CENTER_CENTER, scale = (fscale+tscale)/2
		};
		table.insert(list, l);
		l = { 
			pos = tpos, step = 2, size = tsize,
			csprite = tsprite, 
			radius = 8, ap = ANCHOR_CENTER_CENTER, scale = tscale 
		};
		table.insert(list, l);
	end
	if 0 == step or 3 == step then
		local l = { 
			pos = ccp(HALF_WIDTH, HALF_HEIGHT), step = 3,
			ap = ANCHOR_CENTER_CENTER, scale = 1 
		};
		table.insert(list, l);
	end

	local last_action_index = 1;
	local factory = DBCCFactory:getInstance();
	--local cache = cc.SpriteFrameCache:getInstance();
	local is_has_anim = false;
	for i = 1, #list do
		local info = list[i];
		local step = info.step;
		local pos = info.pos;
		local ap = info.ap;
		local size = info.size;
		local scale = info.scale;
		local aname = string.format("%s_%d", ename, step);
		local slt_name = string.format("%s_skeleton.xml", aname);
		local tx_name = string.format("%s_texture.xml", aname);
		if true == util.check_file(slt_name) then
			factory:loadDragonBonesData(slt_name, aname);
			factory:loadTextureAtlas(tx_name, aname);
			local armature_node = factory:buildArmatureNode(aname);

			armature_node:setPosition(pos);
			armature_node:setAnchorPoint(ap);
			--sprite:setScale(scale);
			layer:addChild(armature_node, ZORDER_EFFECT);
			last_action_index = last_action_index + 1;
			local t = 0.5;
			if 0 == step then
			--pos = fpos, tpos = tpos, size = fsize, tsize = tsize,
				local pp = cc.p(info.tpos.x-pos.x, info.tpos.y-pos.y);
				local offset = math.sqrt(math.pow(pp.x, 2) + math.pow(pp.y, 2));
				t = offset / 1000;
				if t > 0.5 then t = 0.5 end
			end
			time = time + t;

			info.sprite = armature_node;
			info.time = t;
			is_has_anim = true;
		elseif 1 == step then
			info.is_attacker_atnormal = true;
			info.sprite = fsprite;
			info.time = 0;
		end
	end
	if false == is_has_anim then
		for i = 1, #list do
			local info = list[i];
			if true == info.is_attacker_atnormal then
				info.is_attacker_atnormal = nil;
				info.sprite = nil;
			end
		end
	end

	local delay = 0;
	if 'e_hide' == eff and (0 == step or 1 == step) then
		a_play_eff_show(fsprite, delay, false);
	end
	for i = 1, #list do
		local info = list[i];
		local csprite = info.csprite;
		local radius = info.radius;
		local sprite = info.sprite;
		local step = info.step;
		if 1 == step and true == info.is_attacker_atnormal and nil ~= sprite then
			local action, array, sarray, scale;
			local x = sprite:getPositionX();
			local y = sprite:getPositionY();
			scale = sprite:getScale();
			local svv = 1;
			if y > HALF_HEIGHT then
				svv = -1;
			end
			array = {};
			table.insert(array, cc.DelayTime:create(delay));
			sarray = {};
			action = cc.ScaleTo:create(0.2, scale + 0.05);
			table.insert(array, action);
			action = cc.ScaleTo:create(0.1, scale + 0.03);
			table.insert(array, action);

			sarray = {};
			action = cc.ScaleTo:create(0.2, scale + 0.01);
			table.insert(sarray, action);
			action = cc.MoveTo:create(0.2, cc.p(x, y + svv*15));
			table.insert(sarray, action);
			action = cc.Spawn:create(sarray);
			action = cc.EaseIn:create(action, 0.1);
			table.insert(array, action);
			action = cc.Sequence:create(array);
			sprite:runAction(action);
			delay = delay + 0.4;

			array = {};
			table.insert(array, cc.DelayTime:create(delay + 0.1));
			sarray = {};
			action = cc.RotateTo:create(0.2, 0);
			table.insert(sarray, action);
			action = cc.ScaleTo:create(0.1, scale);
			table.insert(sarray, action);
			action = cc.MoveTo:create(0.1, cc.p(x, y));
			table.insert(sarray, action);
			action = cc.Spawn:create(sarray);
			table.insert(array, action);
			action = cc.Sequence:create(array);
			sprite:runAction(action);
		elseif nil ~= info.sprite then
			local t = info.time;
			local tpos = info.tpos;
			local pos = info.pos;
			local tsize = info.tsize;
			local scale = info.scale;

			local function play_it()
				local function cb1(armature_node, event_type, movement_id, frame_label)
					--print('xx: ', event_type, movement_id, frame_label);
					if 7 == event_type then -- compelete
						armature_node:removeFromParent(true);
						--callback_func
			--callback_play_eff;
						--print('i, #list, callback: ', i, #list, callback);
						if i == last_action_index and nil ~= callback then
							callback();
						end
					end
				end
				sprite:registerMovementEventHandler(cb1);
				local anim = sprite:getAnimation();
				anim:play();
			end

			local array = {};
			table.insert(array, cc.Hide:create());
			table.insert(array, cc.DelayTime:create(delay));
			table.insert(array, cc.Show:create());
			local function removeForNotFinishFlash()
				sprite:removeFromParent(true);
			end
			if nil ~= tpos then
				local spawns = {};
				local action = cc.MoveTo:create(t, tpos);
				table.insert(spawns, action);
				table.insert(spawns, cc.DelayTime:create(t));
				table.insert(spawns, cc.CallFunc:create(play_it));
				table.insert(array, cc.Spawn:create(spawns));
				if 0 == step then
					table.insert(array, cc.CallFunc:create(removeForNotFinishFlash));
				end

				local pp = cc.p(tpos.x-pos.x, tpos.y-pos.y);
				local r = math.atan2(pp.y, pp.x);
				local r1 = r * 360 / ( 2 * 3.14 );
				local r2 = 90 - r1;
				sprite:setRotation(r2);
				
				if nil ~= tsize then
					local s = sprite:getContentSize();
					sprite:setScale(scale);
				end
			else
				local sa = {};
				table.insert(sa, cc.DelayTime:create(t));
				table.insert(sa, cc.CallFunc:create(play_it));
				table.insert(array, cc.Spawn:create(sa));
				if 0 == step then
					table.insert(array, cc.CallFunc:create(removeForNotFinishFlash));
				end
			end
			--print('---- i: ', i);
			--[[
			table.insert(array, cc.CallFunc:create(callback_play_eff));
			if i == #list and nil ~= callback then
				table.insert(array, cc.CallFunc:create(callback));
			end
			]]--
			sprite:runAction(cc.Sequence:create(array));

			if nil ~= csprite then
				csprite:shake(0.2, radius, delay+0.1);
			end

			delay = delay + t;
		end
	end
	local flag = fsprite:isVisible();
	if false == flag and (0 == step or 2 == step or 3 == step) then
		a_play_eff_show(fsprite, delay, true);
	end

	return delay;
end

function anim_play_frame(layer, effname, pos, rotation, scale, callback, time, is_repeat) -- {
	local cost_time = 0;
	local filename, fullpath;
	local cache, sprite, animation, len;
	cache = cc.SpriteFrameCache:getInstance();
	filename = effname .. '.plist';
	fullpath = util.get_fullpath(F_ANIM, filename);
	cache:addSpriteFrames(fullpath);
	filename = effname .. '_1.png';
	sprite = cc.Sprite:createWithSpriteFrameName(filename);
	sprite:setPosition(pos);
	sprite:setRotation(rotation);
	sprite:setScale(scale);
	layer:addChild(sprite, ZORDER_EFFECT);
	animation = cc.Animation:create();
	len = 0;
	filename = effname .. '_' .. 1 .. '.png';
	local frame = cache:spriteFrameByName(filename);
	repeat
		len = len + 1;
		animation:addSpriteFrame(frame);
		filename = effname .. '_' .. len .. '.png';
		frame = cache:spriteFrameByName(filename);
	until nil == frame;
	animation:setDelayPerUnit(time);
	cost_time = cost_time + time * len;

	local array = {};
	table.insert(array, cc.Animate:create(animation));
	if nil ~= callback then
		table.insert(array, cc.CallFunc:create(callback));
	end

	if true == is_repeat then
		local action = cc.RepeatForever:create(cc.Sequence:create(array));
		if nil ~= tag then
			action:setTag(tag);
		end
		sprite:runAction(action);
		cost_time = 3; -- won't have repeat case now, so set to anything is ok
	else
		local action = cc.Sequence:create(array);
		if nil ~= tag then
			action:setTag(tag);
		end
		sprite:runAction(action);
	end
	
	return sprite, cost_time;
end -- anim_play_frame }

function attack_eff(layer, attacker, defender, sframe, tframe, time) -- {
	time = time or 0;
	local svv = 1;
	if sframe.y > HALF_HEIGHT then
		svv = -1;
	end
	local action, array, sarray;
	array = {};
	table.insert(array, cc.DelayTime:create(time));
	sarray = {};
	action = cc.ScaleTo:create(0.2, sframe.scale + 0.05);
	table.insert(array, action);
	action = cc.ScaleTo:create(0.1, sframe.scale + 0.03);
	table.insert(array, action);

	sarray = {};
	action = cc.ScaleTo:create(0.2, sframe.scale + 0.01);
	table.insert(sarray, action);
	action = cc.MoveTo:create(0.2, cc.p(sframe.x, sframe.y + svv*15));
	table.insert(sarray, action);
	action = cc.Spawn:create(sarray);
	action = cc.EaseIn:create(action, 0.1);
	table.insert(array, action);
	action = cc.Sequence:create(array);
	attacker:runAction(action);
	time = time + 0.4;

	local sprite = nil;
	local effname = 's_0_2';
	local filename, fullpath;
	local cache, sprite, animation, len;
	cache = cc.SpriteFrameCache:getInstance();
	filename = effname .. '.plist';
	if true == util.check_file(filename) then
		fullpath = util.get_fullpath(F_ANIM, filename);
		cache:addSpriteFrames(fullpath);
		filename = effname .. '_1.png';
		sprite = cc.Sprite:createWithSpriteFrameName(filename);
		sprite:setPosition(cc.p(tframe.x, tframe.y));
		layer:addChild(sprite, ZORDER_EFFECT);
		animation = cc.Animation:create();
		len = 0;
		filename = effname .. '_' .. 1 .. '.png';
		local frame = cache:spriteFrameByName(filename);
		repeat
			len = len + 1;
			animation:addSpriteFrame(frame);
			filename = effname .. '_' .. len .. '.png';
			frame = cache:spriteFrameByName(filename);
		until nil == frame;
		animation:setDelayPerUnit(0.1);

		array = {};
		sarray = {};
		table.insert(array, cc.Hide:create());
		table.insert(array, cc.DelayTime:create(time));
		table.insert(array, cc.Show:create());
		table.insert(array, cc.Animate:create(animation));
		table.insert(array, cc.CallFunc:create(callback_play_eff));

		action = cc.Sequence:create(array);
		sprite:runAction(action);

		defender:shake(0.2, 3, time+0.1*len/2);
	end

	array = {};
	table.insert(array, cc.DelayTime:create(time+0.1*len/2));
	sarray = {};
	action = cc.RotateTo:create(0.2, 0);
	table.insert(sarray, action);
	action = cc.ScaleTo:create(0.1, sframe.scale);
	table.insert(sarray, action);
	action = cc.MoveTo:create(0.1, cc.p(sframe.x, sframe.y));
	table.insert(sarray, action);
	action = cc.Spawn:create(sarray);
	table.insert(array, action);
	action = cc.Sequence:create(array);
	attacker:runAction(action);

	time = time + 0.1*len; 
	
	return sprite, time;
end -- attack_eff }

-- asprite --> attacker sprite , dsprite --> defender sprite
function action_skill(layer, asprite, dsprite, time)
	local laser = nil;
	local function remove_laser()
		laser.batch:removeFromParentAndCleanup(true);
		return;
	end
	local apos = cc.p(asprite:getPositionX(), asprite:getPositionY());
	local dpos = cc.p(dsprite:getPositionX(), dsprite:getPositionY());
	local fullpath = util.get_fullpath(F_PARTICLE, 'laser.plist');	
	laser = util.add_particle(layer, fullpath, apos, ZORDER_EFFECT);
	local pp = cc.p(dpos.x-apos.x, dpos.y-apos.y);
	local r = math.atan2(pp.y, pp.x);
	local r1 = r * 360 / ( 2 * 3.14 );
	local r2 = 90 - r1;
	local offset = math.sqrt(math.pow(pp.x, 2) + math.pow(pp.y, 2));
	local spos = laser.emitter:getPosVar();
	spos.y = offset*0.5;
	laser.emitter:setPosVar(spos);
	local tpos = cc.p(pp.x/2+apos.x, pp.y/2+apos.y);
	laser.batch:setPosition(tpos);
	laser.batch:setRotation(r2);

	local action, array;
	array = {};
	action = cc.DelayTime:create(time);
	table.insert(array, action);
	action = cc.CallFunc:create(remove_laser);
	table.insert(array, action);
	action = cc.Sequence:create(array);
	asprite:runAction(action);
	
	asprite:shake(time-0.1, 8, 0);
	dsprite:shake(time-0.1, 8, 0);
	
	return time + 0.1;
end

function a_particle_sac(...) -- {
	local args = {...};
	local sprite = args[1];
	local scale = sprite:getScale();
	local pname = 'c_sac.plist';
	local layer = sprite:getParent();
	local pos = cc.p(sprite:getPositionX(), sprite:getPositionY());
	local zorder = sprite:getLocalZOrder();

	local path = util.get_path(pname);
	local info = util.add_particle(layer, path, pos, zorder-1);
	scale = sprite:getScale();
	info.batch:setScale(scale);
end -- a_particle_sac end }

function a_particle_shoot(sdata, data, parray)
	local action, array;
	local fsprite = data.att_sprite;
	local tsprite = data.sprite;
	local layer = data.layer;
	local fpos = cc.p(fsprite:getPositionX(), fsprite:getPositionY());
	local tpos = cc.p(tsprite:getPositionX(), tsprite:getPositionY());
	local fullpath = util.get_fullpath(F_PARTICLE, 'ab_tail.plist');
	local zorder = fsprite:getLocalZOrder();
	local info = util.add_particle(layer, fullpath, fpos, zorder+1);

	local pp = cc.p(tpos.x-fpos.x, tpos.y-fpos.y);
	local r = math.atan2(pp.y, pp.x);
	local r1 = r * 360 / ( 2 * 3.14 );
	local r2 = 90 - r1;
	local offset = math.sqrt(math.pow(pp.x, 2) + math.pow(pp.y, 2));
	local spos = info.emitter:getPosVar();
	spos.y = offset*0.5;
	spos.y = 0;
	info.emitter:setPosVar(spos);
	info.batch:setRotation(r2);

	array = {};
	action = cc.MoveTo:create(0.2, tpos);
	table.insert(array, action);
	action = cc.CallFunc:create(anim_callback_remove);
	table.insert(array, action);
	action = cc.Sequence:create(array);
	info.batch:runAction(action);

	action = cc.DelayTime:create(0.2);
	if nil ~= parray and nil ~= action then
		table.insert(parray, action);
	end
	return action;
end

--------------- ANIM_ACTION START ------------
function anim_action_use(use_index, front_index)
	--alog('DBEUG do anim_action_use');
	--alog('DEBUG use_index, front_index: ', use_index, front_index);
	local use_table_index, use_list_index, use_card_list, use_card;
	use_table_index, use_list_index, use_card_list, use_card 
		= anim_get_info(use_index);

	local anim_group = {};
	local alist, scale;

	if use_index == front_index then
		alog('DEBUG anim_action_use use_index == front_index: ', use_index);
		return anim_group;
	end

	if nil == front_index then
		local sprite = anim_get_sprite(use_card);
		local use_side = anim_index_side(use_index);
		if use_side ~= g_euser.side and true ~= SHOW_ALL and use_table_index == T_HAND then
			alist = {
				info = use_card,
				sprite = sprite,
				anims = {
					{ anim_name = 'scale_front', pos = ccp(HALF_WIDTH, HALF_HEIGHT), scale = 1.5 },
				},
			};
			anim_group[#anim_group + 1] = { alist };
		
			alist = {
				sprite = sprite,
				card_info = use_card,
				anims = {
					{ anim_name = 'flip_card', orient = 'front' },
				},
			};
			anim_group[#anim_group + 1] = { alist };

			alist = {
				sprite = sprite,
				card_info = use_card,
				anims = {
					{ anim_name = 'show_full_card', time = 1 },
				},
			};
			anim_group[#anim_group + 1] = { alist };
		elseif use_table_index == T_HAND then
		end

		return anim_group;
	end

	local front_table_index, front_list_index, front_card_list, front_card;
	front_table_index, front_list_index, front_card_list, front_card 
		= anim_get_info(front_index);

	sprite = anim_get_sprite(front_card);
	scale = front_card_list.cscale;
	local pos = cc.p(front_card.frame.x, front_card.frame.y);
	
	alist = {
		sprite = sprite,
		anims = {
			{ anim_name = 'spawn', 
			  anim_parts = {
			      { anim_part = 'move', pos = pos },
				  { anim_part = 'scale', scale = scale },
				  { anim_part = 'rotate', rotation = 0 },
			  },
		    },
			{ anim_name = 'to_back' },
		},
	};
	anim_group[#anim_group + 1] = { alist };

	sprite = anim_get_sprite(use_card);

	alist = {
		info = use_card,
		sprite = sprite,
	 	anims = {
			{ anim_name = 'to_front' },
		},
	};
	anim_group[#anim_group + 1] = { alist };

	return anim_group;
end

function anim_action_add(add_index, card_id)
	local table_index, list_index, card_list, info = anim_get_info(add_index);
	local side = anim_index_side(add_index);

	local anim_list = {};
	local anim_group = {};
	local pos = anim_get_npos(add_index);
	pos.x = g_ui_table[side][T_DECK].x;
	pos.y = g_ui_table[side][T_DECK].y;
	local layer = layer_card.layer;

	--print('index : ', add_side, add_table_index, add_list_index);
	local c = g_logic_table[side][table_index][list_index];
	local rotation = 0;
	if side == SIDE_UP then
		rotation = 180;
	end
	info = add_ui_card(layer, card_list, pos, rotation, c, nil, nil, list_index);

	anim_arrange_list(add_index, anim_list, 'insert');

	local sprite = anim_get_sprite(info);
	local scale = sprite:getScale();
	anim_list[#anim_list + 1] = {
		info = info,
		sprite = sprite,
		anims = {
			{ anim_name = 'scale', scale = scale*1.5 },
			{ anim_name = 'scale', scale = scale },
		},
	};
	anim_group[#anim_group + 1] = anim_list;

	return anim_group;
end

function anim_action_anim(cid, src_index, atype, tlist, front_index) --{
	local front_table_index, front_list_index, front_card_list, front_card;
	front_table_index, front_list_index, front_card_list, front_card 
		= anim_get_info(front_index);

	local src_table_index, src_list_index, src_card_list, src_card;
	src_table_index, src_list_index, src_card_list, src_card 
		= anim_get_info(src_index);

	-- anim group
	local anim_group = {};
	local alist = nil;

	if nil ~= front_card and front_table_index == T_HAND then
		local front_side = anim_index_side(front_index);
		local hs = anim_get_sprite(g_ui_table[front_side][T_HERO][1]);
		local pos = ccp(hs:getPositionX(), hs:getPositionY());
		local scale = ANIM_SCALE_CENTER;--*0.6;--anim.SCALE_SHOW/3.5;
		local sprite = anim_get_sprite(front_card);

		alist = {
			info = front_card,
			sprite = sprite,
			anims = {
				{ anim_name = 'to_front' },
				{ anim_name = 'spawn', 
				  anim_parts = {
					  { anim_part = 'move', pos = pos },
					  { anim_part = 'scale', scale = scale },
					  { anim_part = 'rotate', rotation = 0 },
				  }
				},
				{ anim_name = 'to_back' },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	end
	
	if nil == src_card or 0 == #tlist then
		return anim_group;
	end

	local is_screen_eff = false;
	local filename = '';
	if true == USE_FLASH then
		filename = string.format("s_%s_%d_skeleton.xml", atype, 2);
	else
		filename = string.format("s_%s_%d.plist", atype, 2);
	end
	if true ~= util.check_file(filename) then
		is_screen_eff = true;
	end

	anim_list = {};
	local sprite = anim_get_sprite(src_card);
	for i = 1, #tlist do
		local tar_index = tlist[i];
		local tar_table_index, tar_list_index, tar_card_list, tar_card;
		tar_table_index, tar_list_index, tar_card_list, tar_card 
			= anim_get_info(tar_index);
		local eff = nil;
		if front_table_index == T_HAND then
			eff = 'e_hide';
		end
		if nil ~= tar_card then
			local tsprite = anim_get_sprite(tar_card);
			if 1 == i then
				local tar_pos = cc.p(sprite:getPositionX(),sprite:getPositionY());
				alist = {
					sprite = tsprite,
					att_sprite = sprite,
					layer = layer_anim.layer,
					anims = {
						{ anim_name = 'damage_anim', atype = atype, step = 1, eff = eff },
					},
				};
				anim_group[#anim_group + 1] = { alist };
				anim_set_tlist_src(src_index);
			end
			if 506 == atype or 507 == atype then -- hp up or hp down
				anim_set_tlist_src(0);
				anim.eff_hp_count = anim.eff_hp_count + 1;
			elseif 508 == atype or 509 == atype then -- power up or power down
				anim_set_tlist_src(0);
				anim.eff_power_count = anim.eff_power_count + 1;
			else
				if true ~= is_screen_eff then
					anim_list[#anim_list + 1] = {
						sprite = tsprite,
						att_sprite = sprite,
						layer = layer_anim.layer,
						anims = {
							--{ anim_name ='particle', ptype = 'ab_tail' },
							{ anim_name = 'damage_anim', atype = atype, step=2 },
						},
					};
				else
					anim_list[#anim_list + 1] = {
						sprite = tsprite,
						anims = {
							{ anim_name = 'eff_sprite', duration = 0.5, radius = 5, 
														 delay = 0, etype = 'shake' },
						},
					};
				end
				anim_insert_tlist(tar_index);
			end
		end
	end
	if true == is_screen_eff then
		anim_list[#anim_list + 1] = {
			att_sprite = sprite,
			layer = layer_anim.layer,
			anims = {
				{ anim_name = 'damage_anim', atype = atype, step = 3 },
			},
		};
	end
	--[[
	anim_list[#anim_list + 1] = {
		layer_anim = layer_anim.layer,
		layer_card = layer_card,
		anims = {
			{ anim_name = 'eff_layer', etype = 'shake' },
		},
	};
	]]--
	anim_group[#anim_group + 1] = anim_list;

	return anim_group;
end -- anim_action_anim }

function anim_move_from_hand(src_index, tar_index, front_index) -- {
	local src_table_index, src_list_index, src_card_list, src_card;
	src_table_index, src_list_index, src_card_list, src_card 
		= anim_get_info(src_index);

	local tar_table_index, tar_list_index, tar_card_list, tar_card;
	tar_table_index, tar_list_index, tar_card_list
		= anim_get_info(tar_index);

	local tar_side = anim_index_side(tar_index);

	local anim_group = {};
	local anim_list = {};
	local alist;

	--print('front_index, src_index: ', front_index, src_index);
	if nil ~= front_index and front_index ~= src_index then

		local front_card = anim_get_card_info(front_index);
		local sprite = anim_get_sprite(front_card);
		local src_sprite = anim_get_sprite(src_card);
		local pos = cc.p(src_sprite:getPositionX(), src_sprite:getPositionY());
		local scale = src_sprite:getScaleX()/4*3;

		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'spawn', 
				  anim_parts = {
				      { anim_part = 'move', pos = pos, efftype ='ease_out' },
					  { anim_part = 'scale', scale = scale },
					  { anim_part = 'rotate', rotation = 0 },
				  },
				},
				{ anim_name = 'to_back' },
			},
		}
		anim_group[#anim_group + 1] = { alist };

		alist = {
			sprite = sprite,
			anims = {	
				{ anim_name = 'particle', pname = 'dust' },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	end

	local pos = anim_get_npos(tar_index);
	local sprite = anim_get_sprite(src_card);
	local layer = layer_card.layer;

	local info = add_ui_card(layer, tar_card_list, pos, 0, src_card.card, sprite, nil, tar_list_index);

	anim_arrange_list(tar_index, anim_list, 'insert');

	if src_table_index == T_GRAVE then
		anim_arrange_grave(src_index, anim_list, 'remove');
	end

	table.remove(src_card_list, src_list_index);

	anim_arrange_list(src_index, anim_list, 'remove');

	tar_card = tar_card_list[tar_list_index];
	pos = cc.p(tar_card.frame.x, tar_card.frame.y);
	local scale = tar_card_list.cscale;
	local rotation = tar_card.frame.rotation;
	sprite = anim_get_sprite(tar_card);

	if tar_table_index == T_RES then
		--local spos = cc.p(sprite:getPositionX(), sprite:getPositionY());
		local y2 = g_ui_table.label_res_max[tar_side]:getPositionY();
		pos.y = pos.y + (y2 - pos.y)/2;
		anim_list[#anim_list + 1] = {
			info = tar_card, 
			sprite = sprite,
			anims = {
				{ anim_name = 'to_front' },
				{ anim_name = 'spawn', 
				  anim_parts = {
					  { anim_part = 'bezier_move', pos=pos, efftype='ease_in' },
					  { anim_part = 'scale',  scale = ANIM_SCALE_CENTER },
					  { anim_part = 'rotate', rotation = rotation },
				  },
				},
				{ anim_name = 'to_back' },
				{ anim_name = 'hide' },
				{ anim_name = 'particle', ptype = 'sac' },
				{ anim_name = 'remove' },
			},
		};
		anim_group[#anim_group + 1] = anim_list;
		return anim_group;
	end
	anim_list[#anim_list + 1] = {
		sprite = sprite,
		anims = {
			{ anim_name = 'to_front' },
			{ anim_name = 'spawn', 
			  anim_parts = {
				  { anim_part = 'move', pos = pos, efftype = 'ease_in' },
				  { anim_part = 'scale',  scale = scale },
				  { anim_part = 'rotate', rotation = rotation },
			  },
			},
			{ anim_name = 'to_back' },
		},
	};
	anim_group[#anim_group + 1] = anim_list;

	anim_list = {};
	if tar_table_index == T_GRAVE then
		anim_arrange_grave(tar_index, anim_list, 'insert');
		anim_group[#anim_group + 1] = anim_list;
	end

	return anim_group;
end -- anim_move_from_hand end }

function anim_get_card_pos_rotation(ui_table, index)
	local cwidth = CARD_SIZE_2.width;
	local cheight = CARD_SIZE_2.height;
	local cscale = ui_table.cscale;
	local gap;
	if ui_table.ltype == UP_GRAVE or ui_table.ltype == DOWN_GRAVE or 
	   ui_table.ltype == UP_DECK or ui_table.ltype == DOWN_DECK then
		gap = 0;
	else
		gap = calculate_gap(#ui_table, cwidth*cscale, ui_table.width, ui_table.ltype);
	end
	local pos;
	local rotation = 0;
	pos, rotation = get_card_pos_rotation(ui_table, gap, index, #ui_table);	
	return pos, rotation;
end

function anim_move_in_deck(src_index, tar_index, front_index) -- {
	local src_table_index, src_list_index, src_card_list, src_card;
	src_table_index, src_list_index, src_card_list, src_card 
		= anim_get_info(src_index);

	local tar_table_index, tar_list_index, tar_card_list, tar_card;
	tar_table_index, tar_list_index, tar_card_list
		= anim_get_info(tar_index);

	local anim_group = {};
	local alist;

	local anim_list = {};

	if nil ~= front_index and front_index ~= src_index then
		local front_card = anim_get_card_info(front_index);
		local sprite = anim_get_sprite(front_card);
		local src_sprite = anim_get_sprite(src_card);
		local pos = cc.p(src_sprite:getPositionX(), src_sprite:getPositionY());
		local scale = src_sprite:getScaleX()/4*3;

		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'spawn', 
				  anim_parts = {
				      { anim_part = 'move', pos = pos, efftype = 'ease_out'  },
					  { anim_part = 'scale', scale = scale },
					  { anim_part = 'rotate', rotation = 0 },
				  },
				},
				{ anim_name = 'to_back' },
			},
		}
		anim_group[#anim_group + 1] = { alist };

		alist = {
			sprite = sprite,
			anims = {	
				{ anim_name = 'particle', pname = 'dust' },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	end

	local src_side = anim_index_side(src_index);
	local tar_side = anim_index_side(tar_index);

	local pos = anim_get_npos(tar_index);
	local sprite = anim_get_sprite(src_card);
	local layer = layer_card.layer;

	local scale = tar_card_list.cscale;
	local rotation = src_card.frame.rotation;

	table.remove(src_card_list, src_list_index);
	local info = add_ui_card(layer, tar_card_list, pos, 0, src_card.card, sprite, nil, tar_list_index);

	tar_card = tar_card_list[tar_list_index];
	pos = cc.p(tar_card.frame.x, tar_card.frame.y);
	sprite = anim_get_sprite(tar_card);

--	if tar_table_index == T_DECK then
--		info:flip_to_cover();
--	end

	-- need flip card to front
	alist = {
		sprite = sprite,
		card_info = tar_card,
		anims = {
			{ anim_name = 'to_front' },
			{ anim_name = 'spawn', 
			  anim_parts = {
				{ anim_name = 'move', pos = cc.p(pos.x+wfix(50), pos.y) },
				{ anim_name = 'rotate', rotation = 0 },
			  },
			},
			{ anim_name = 'to_zorder', zorder = ZORDER_CARD-1 },
			{ anim_name = 'spawn', 
			  anim_parts = {
				{ anim_name = 'rotate', rotation = rotation },
				{ anim_name = 'move', pos = pos },
			  },
			},
		},
	};

	if info.status == CARD_FRONT then
		table.insert(alist.anims[2].anim_parts,	{ anim_name = 'flip_card', orient = 'back' });
	end
	anim_group[#anim_group + 1] = { alist };

	if is_view_top() then
		tar_card = tar_card_list[1];
		sprite = anim_get_sprite(tar_card);
		alist = {
			sprite = sprite,
			card_info = tar_card,
			anims = {
				{ anim_name = 'flip_card', orient = 'front' },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	end

	return anim_group;
end -- anim_move_in_deck end }

function anim_move_from_deck(src_index, tar_index, front_index) -- {
	local src_table_index, src_list_index, src_card_list, src_card;
	src_table_index, src_list_index, src_card_list, src_card 
		= anim_get_info(src_index);

	local tar_table_index, tar_list_index, tar_card_list, tar_card;
	tar_table_index, tar_list_index, tar_card_list
		= anim_get_info(tar_index);

	local anim_group = {};
	local alist;

	local anim_list = {};

	if nil ~= front_index and front_index ~= src_index then
		local front_card = anim_get_card_info(front_index);
		local sprite = anim_get_sprite(front_card);
		local src_sprite = anim_get_sprite(src_card);
		local pos = cc.p(src_sprite:getPositionX(), src_sprite:getPositionY());
		local scale = src_sprite:getScaleX()/4*3;

		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'spawn', 
				  anim_parts = {
				      { anim_part = 'move', pos = pos, efftype = 'ease_out'  },
					  { anim_part = 'scale', scale = scale },
					  { anim_part = 'rotate', rotation = 0 },
				  },
				},
				{ anim_name = 'to_back' },
			},
		}
		anim_group[#anim_group + 1] = { alist };

		alist = {
			sprite = sprite,
			anims = {	
				{ anim_name = 'particle', pname = 'dust' },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	end

	local src_side = anim_index_side(src_index);
	local tar_side = anim_index_side(tar_index);

	local pos = anim_get_npos(tar_index);
	local sprite = anim_get_sprite(src_card);
	local layer = layer_card.layer;

	local info = add_ui_card(layer, tar_card_list, pos, 0, src_card.card, sprite, nil, tar_list_index);

	if src_table_index == T_DECK then
		info:flip_to_cover();
	end

	anim_arrange_list(tar_index, anim_list, 'insert');

	table.remove(src_card_list, src_list_index);

	anim_arrange_list(src_index, anim_list, 'remove');

	tar_card = tar_card_list[tar_list_index];
	pos = cc.p(tar_card.frame.x, tar_card.frame.y);
	local scale = tar_card_list.cscale;
	local rotation = tar_card.frame.rotation;
	sprite = anim_get_sprite(tar_card);

	-- pos rotation should be same as in game.lua get_card_pos_rotation
	local tar_index_offset = anim_index_offset(tar_index);
	pos, rotation = anim_get_card_pos_rotation(tar_card_list, tar_index_offset);
	
	if ( tar_side == g_euser.side or true == data_handler.show_all_card or true == is_view_oppo()) and 
	   src_table_index == T_DECK then
		-- need flip card to front
		anim_list[#anim_list + 1] = {
			sprite = sprite,
			card_info = src_card,
			anims = {
				{ anim_name = 'to_front' },
				{ anim_name = 'spawn', 
				  anim_parts = {
					{ anim_name = 'flip_card', orient = 'front' },
					{ anim_name = 'deck_to_hand', end_pos = pos, scale = scale, tar_side = tar_side },
					{ anim_name = 'rotate', rotation = rotation },
				  },
				},
				{ anim_name = 'to_back' },
			},
		};
	else
		anim_list[#anim_list + 1] = {
			sprite = sprite,
			card_info = src_card,
			anims = {
				{ anim_name = 'to_front' },
				{ anim_name = 'spawn', 
				  anim_parts = {
					{ anim_name = 'deck_to_hand', end_pos = pos, scale = scale, tar_side = tar_side },
					{ anim_name = 'rotate', rotation = rotation },
				  },
				},
				{ anim_name = 'to_back' },
			},
		};
	end
	anim_group[#anim_group + 1] = anim_list;

	return anim_group;
end -- anim_move_from_deck end }

function anim_action_move(src_index, tar_index, front_index) -- {
	alog('DEBUG do anim_action_move src,tar,front: ', src_index, tar_index, front_index);
	local src_table_index, src_list_index, src_card_list, src_card;
	src_table_index, src_list_index, src_card_list, src_card 
		= anim_get_info(src_index);

	local tar_table_index, tar_list_index, tar_card_list, tar_card;
	tar_table_index, tar_list_index, tar_card_list
		= anim_get_info(tar_index);

	local anim_group = {};
	local alist;

	local anim_list = {};

	if #tar_card_list + 1 < tar_list_index then
		return anim_group;
	end

	if src_table_index == T_HAND then
		return anim_move_from_hand(src_index, tar_index, front_index);
	end

	local src_side = anim_index_side(src_index);
	local tar_side = anim_index_side(tar_index);
	
	if src_table_index == T_DECK then 
		if tar_table_index == T_DECK then
			return anim_move_in_deck(src_index, tar_index);
		else
			return anim_move_from_deck(src_index, tar_index, front_index);
		end
	end

	-- target ally or support back to hand , should turn to cover
	-- e.g retreat(132)
	if tar_side ~= g_euser.side and src_table_index ~= T_DECK 
		and tar_table_index == T_HAND and true ~= data_handler.show_all_card then

		local sprite = anim_get_sprite(src_card);
		alist = {
			sprite = sprite,
			card_info = src_card,
			anims = {
				{ anim_name = 'flip_card', orient = 'back' },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	end

	if nil ~= front_index and front_index ~= src_index then
		local front_card = anim_get_card_info(front_index);
		local sprite = anim_get_sprite(front_card);
		local src_sprite = anim_get_sprite(src_card);
		local pos = cc.p(src_sprite:getPositionX(), src_sprite:getPositionY());
		local scale = src_sprite:getScaleX()/4*3;

		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'spawn', 
				  anim_parts = {
				      { anim_part = 'move', pos = pos, efftype = 'ease_out'  },
					  { anim_part = 'scale', scale = scale },
					  { anim_part = 'rotate', rotation = 0 },
				  },
				},
				{ anim_name = 'to_back' },
			},
		}
		anim_group[#anim_group + 1] = { alist };

		alist = {
			sprite = sprite,
			anims = {	
				{ anim_name = 'particle', pname = 'dust' },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	end
	
	local pos = anim_get_npos(tar_index);
	local sprite = anim_get_sprite(src_card);
	local layer = layer_card.layer;

	local lt, lb, rb; -- left_top, left_bottom, right_bottom;
	if src_table_index == T_GRAVE then
		local d = src_card.data;
		lt = d.left_top;
		lb = d.left_bottom;
		rb = d.right_bottom;
	end
	local info = add_ui_card(layer, tar_card_list, pos, 0, src_card.card, sprite, nil, tar_list_index);
	if nil ~= lt then info.data.left_top = lt; end
	if nil ~= lb then info.data.left_bottom = lb; end
	if nil ~= rb then info.data.right_bottom = rb; end

	anim_arrange_list(tar_index, anim_list, 'insert');

	if src_table_index == T_GRAVE then
		anim_arrange_grave(src_index, anim_list, 'remove');
	end

	table.remove(src_card_list, src_list_index);

	if src_table_index ~= T_GRAVE then
		anim_arrange_list(src_index, anim_list, 'remove');
	end

	tar_card = tar_card_list[tar_list_index];
	pos = cc.p(tar_card.frame.x, tar_card.frame.y);
	local scale = tar_card_list.cscale;
	local rotation = tar_card.frame.rotation;
	sprite = anim_get_sprite(tar_card);

	if src_table_index == T_GRAVE then
		anim_list[#anim_list + 1] = {
			sprite = sprite,
			anims = {
				{ anim_name='from_grave', ui_table = tar_card_list, index = tar_index, info = info },
				{ anim_name = 'show' },
			},
		};
	end
	
	anim_list[#anim_list + 1] = {
		sprite = sprite,
		anims = {
			{ anim_name = 'to_front' },
			{ anim_name = 'spawn', 
			  anim_parts = {
				  { anim_part = 'move', pos = pos, efftype = 'ease_in' },
				  { anim_part = 'scale',  scale = scale },
				  { anim_part = 'rotate', rotation = rotation },
			  },
			},
			{ anim_name = 'to_back' },
		},
	};
	anim_group[#anim_group + 1] = anim_list;

	anim_list = {};
	if tar_table_index == T_GRAVE then
		anim_arrange_grave(tar_index, anim_list, 'insert');
		anim_group[#anim_group + 1] = anim_list;
	end
	return anim_group;
end -- anim_action_move end }

function anim_action_move_attach(src_index_full, tar_index, front_index) -- {
	local str = tostring(src_index_full);
	local len = string.len(str);
	local str_index = string.sub(str, 1, 4);
	local str_num = string.sub(str, 5, len); 

	local src_index = tonumber(str_index);
	local attach_index = tonumber(str_num);

	local src_table_index, src_list_index, src_card_list, src_card;
	src_table_index, src_list_index, src_card_list, src_card 
		= anim_get_info(src_index);

	-- main anim group
	local anim_group = {};
	-- actions list
	local anim_list= {};
	local alist = nil;

	if nil ~= front_index and front_index ~= src_index_full then
		local front_table_index, front_list_index, front_card_list, front_card;
		front_table_index, front_list_index, front_card_list, front_card 
			= anim_get_info(front_index);

		local sprite = anim_get_sprite(front_card);
		local src_sprite = anim_get_sprite(src_card);
		local pos = ccp(src_sprite:getPositionX(), src_sprite:getPositionY());
		local scale = src_sprite:getScaleX() / 2;

		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'spawn', 
				  anim_parts = {
				  	  { anim_part = 'move', pos = pos },
					  { anim_part = 'scale', scale = scale },
					  { anim_part = 'rotate', rotation = 0 },
				  },
				},
				{ anim_name = 'to_back' },
			},
		};
		anim_group[#anim_group + 1] = { alist };

		alist = {
			sprite = sprite,
			anims = {	
				{ anim_name = 'particle', pname = 'dust' },
			},
		};
		anim_group[#anim_group + 1] = { alist };

	end

	local attach_list = src_card.attach_list;

	if nil == attach_list or 0 == #attach_list then
		print('BUG attach_list == nil or 0', #attach_list);
		--alog('BUG attach_list == nil or 0');
		return anim_group;
	end
	--print('----xxxx----- ', src_index, #attach_list, attach_index);
	if attach_index > #attach_list then
	--[LUA] effect list: #eff_list=5
	--[LUA]     EFF card, id=38, index=2201, |
	--[LUA]     EFF move, src_index=2201, target_index=2305, |
	--[LUA]     EFF attach, target_index=2305, attach=0, acid=1032, id=38, |
	--[LUA]     EFF power, offset=1, index=2305, |
	--[LUA]     EFF resource, side=2, offset=-4, |
	-- need to create a attach card, but cannot get the card
	-- need 23052, and consider situation that play with ai, get many eff include
	-- add attach and remove attach
		print('anim attach_index > #attach_list');
		return anim_group;
	end

	local attach_card = attach_list[attach_index];
	
	if 1000 < attach_card.card.id and 0 == tar_index then
		-- TODO should make a destroy animation
		local src_sprite = anim_get_sprite(src_card);
		local pos = cc.p(src_sprite:getPositionX(), src_sprite:getPositionY());
		local sprite = anim_get_sprite(attach_card, pos);
		local count = #(sprite:getChildren() or {});
		alist = nil;
		--[[
		if 'cc.Node' == tolua.type(sprite) then
			alist = {
				sprite = sprite,
				anims = {
					{ anim_name = 'spawn', 
					  anim_parts = {
						  { anim_part = 'remove_csprite', obj = src_card },
					  },
					},
				},
			};
		else
		]]--
			alist = {
				sprite = sprite,
				anims = {
					{ anim_name = 'spawn', 
					  anim_parts = {
						  { anim_part = 'scale',  scale = 0 },
						  { anim_part = 'rotate', rotation = 0 },
						  { anim_part = 'remove_csprite', obj = src_card },
					  },
					},
				},
			};
		--end
		anim_group[#anim_group + 1] = { alist };
		table.remove(attach_list, attach_index);
		anim.last_rm_attach_index = src_index;
		return anim_group;
	end

	local tar_table_index, tar_list_index, tar_card_list, tar_card;
	tar_table_index, tar_list_index, tar_card_list, tar_card 
		= anim_get_info(tar_index);

	if #tar_card_list + 1 < tar_list_index then
		alog('BUG anim_action_move_attach #tar_card_list + 1 < tar_list_index');
		return anim_group;
	end

	local pos = ccp(src_card.frame.x, src_card.frame.y);
	local scale = src_card.frame.scale;
	local sprite = anim_get_sprite(attach_card, pos, scale);
	pos = anim_get_npos(tar_index);
	scale = tar_card_list.cscale;
	local layer = layer_card.layer;

	local info = add_ui_card(layer, tar_card_list, pos, 0, attach_card.card, sprite, nil, tar_list_index);
	info.t_index = tar_table_index;

	anim_arrange_list(tar_index, anim_list, 'insert');

	table.remove(attach_list, attach_index);

	-- TODO should reset the attach_list pos
	
	local tar_card = tar_card_list[tar_list_index];
	pos = cc.p(src_card.frame.x, src_card.frame.y);
	scale = src_card.frame.scale;
	sprite = anim_get_sprite(tar_card);
	local npos = cc.p(tar_card.frame.x, tar_card.frame.y);
	local nscale = tar_card_list.cscale;

	anim_list[#anim_list + 1] = {
		sprite = sprite,
		anims = {
			{ anim_name = 'to_front' },
			{ anim_name = 'spawn', 
			  anim_parts = {
			  	  { anim_part = 'move', pos = npos },
			      { anim_part = 'scale',  scale = nscale },
				  { anim_part = 'rotate', rotation = 0 },
			  },
			},
		    { anim_name = 'to_back' },
		},
	};
	anim_group[#anim_group + 1] = anim_list;

	anim_list = {};
	if tar_table_index == T_GRAVE then
		anim_arrange_grave(tar_index, anim_list, 'insert');
		anim_group[#anim_group + 1] = anim_list;
	end

	return anim_group;
end -- anim_action_move_attach }

function anim_action_attach_virtual(tar_index, src_index, id, acid, front_index)
	local tar_table_index, tar_list_index, tar_card_list, tar_card;
	tar_table_index, tar_list_index, tar_card_list, tar_card 
		= anim_get_info(tar_index);

	-- main anim group
	local anim_group = {};
	-- actions list
	local anim_list= {};

	if nil ~= front_index then

		local front_table_index, front_list_index, front_card_list, front_card;
		front_table_index, front_list_index, front_card_list, front_card 
			= anim_get_info(front_index);

		local sprite = anim_get_sprite(tar_card);
		local pos = ccp(sprite:getPositionX(), sprite:getPositionY());
		local scale = sprite:getScaleX() / 2;
		sprite = anim_get_sprite(front_card);

		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'spawn', 
				  anim_parts = {
				  	  { anim_part = 'move', pos = pos },
					  { anim_part = 'scale', scale = scale },
					  { anim_part = 'rotate', rotation = 0 },
				  },
				},
				{ anim_name = 'to_back' },
			},
		};
		anim_group[#anim_group + 1] = { alist };

		alist = {
			sprite = sprite,
			anims = {	
				{ anim_name = 'particle', pname = 'dust' },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	
	end

	local sprite = anim_get_sprite(tar_card);
	alist = {
		sprite = sprite,
		anims = {
			{ anim_name = 'attach', acid = acid },	
		},
	};
	anim_group[#anim_group + 1] = { alist };

	return anim_group;
end -- anim_action_attach_virtual }

function anim_action_attach(tar_index, src_index, id, acid, front_card_index)
	alog('DEBUG do anim_action_attach tar,src,id,acid,front: ', tar_index, src_index, id, acid, front_card_index);
	local src_table_index, src_list_index, src_card_list, src_card;
	src_table_index, src_list_index, src_card_list, src_card 
		= anim_get_info(src_index);
	
	local tar_table_index, tar_list_index, tar_card_list, tar_card;
	tar_table_index, tar_list_index, tar_card_list, tar_card 
		= anim_get_info(tar_index);
	
	-- main anim group
	local anim_group = {};
	-- actions list
	local anim_list= {};
	
	if nil == tar_card then
		return anim_group;
	end

	local attach_list = tar_card.attach_list;

	table.insert(attach_list, src_card);
	table.remove(src_card_list, src_list_index);

	anim_arrange_list(src_index, anim_list, 'remove');

	local attach_card = attach_list[#attach_list];
	local sprite = anim_get_sprite(attach_card);
	local pos = ccp(tar_card.frame.x, tar_card.frame.y);
	local scale = attach_card.frame.scale;
	
	anim_list[#anim_list + 1] = 
	{
		sprite = sprite,
		anims = {
			{ anim_name = 'to_front' },
			{ anim_name = 'spawn', 
			  anim_parts = {
			  	  { anim_part = 'move', pos = pos },
				  { anim_part = 'scale', scale = scale },
				  { anim_part = 'rotate', rotation = 0 },
			  }
			},
			{ anim_name = 'to_back' },
		}
	};
	anim_group[#anim_group + 1] = anim_list;

	return anim_group;
end -- anim_ation_attach }

-- e.g : anim_action_damage(1201, 2201, 1, 2);
function anim_action_damage(src_index, tar_index, dtype, power, atype) -- {
	local src_table_index, src_list_index, src_card_list, src_card;
	src_table_index, src_list_index, src_card_list, src_card 
		= anim_get_info(src_index);
		
	local tar_table_index, tar_list_index, tar_card_list, tar_card;
	tar_table_index, tar_list_index, tar_card_list, tar_card 
		= anim_get_info(tar_index);
	
	-- anim group
	local anim_group = {};
	local alist = nil;

	local src_sprite = anim_get_sprite(src_card);
	local tar_sprite = anim_get_sprite(tar_card);
	local sf = { x = src_card.frame.x, y = src_card.frame.y, 
					 scale = src_card_list.cscale };
	local tf = { x = tar_card.frame.x, y = tar_card.frame.y, 
					 scale = tar_card_list.cscale };

	alist = {
		sprite = tar_sprite,
		anims = {
			{ anim_name = 'to_back' },
		}
	};
	anim_group[#anim_group + 1] = { alist };
	if atype > 1 then
		local pos = cc.p(src_sprite:getPositionX(), src_sprite:getPositionY());
		local tar_pos = cc.p(tar_sprite:getPositionX(),tar_sprite:getPositionY());
		alist = {
			sprite = tar_sprite,
			att_sprite = src_sprite,
			layer = layer_anim.layer,
			anims = {
				{ anim_name = 'damage_anim', src_pos = pos, tar_pos = tar_pos, dtype = dtype, atype = atype, eff = eff },
			},
		};
	else
		alist = {
			def_sprite = tar_sprite,
			att_sprite = src_sprite,
			anims = {
				{ anim_name = 'at_normal', dtype = dtype, sframe=sf, tframe=tf },
			}
		};
	end
	anim_group[#anim_group + 1] = { alist };
	alist = {
		sprite = tar_sprite,
		anims = {
			{ anim_name = 'hp_num_change', offset = -power, flag ='negative' },
		}
	};
	anim_group[#anim_group + 1] = { alist };

	return anim_group;
	
end -- anim_action_damage }

-- fact, if dtype >= 5, do this anim
--so deathbone's skill do this anim
function anim_action_damage_map(src_index, tar_index, dtype, power, front_index, atype) -- {

	local front_table_index, front_list_index, front_card_list, front_card;
	front_table_index, front_list_index, front_card_list, front_card 
		= anim_get_info(front_index);

	local src_table_index, src_list_index, src_card_list, src_card;
	src_table_index, src_list_index, src_card_list, src_card 
		= anim_get_info(src_index);

	local tar_table_index, tar_list_index, tar_card_list, tar_card;
	tar_table_index, tar_list_index, tar_card_list, tar_card 
		= anim_get_info(tar_index);

	-- anim group
	local anim_group = {};
	local alist = nil;

	-- step 2
	--print('front_index, src_index: ', front_index, src_index);
	if nil ~= front_card and front_index ~= src_index then
		local front_side = anim_index_side(front_index);
		local hs = anim_get_sprite(g_ui_table[front_side][T_HERO][1]);
		local pos = ccp(hs:getPositionX(), hs:getPositionY());
		local scale = ANIM_SCALE_CENTER;--*0.6;--anim.SCALE_SHOW/3.5;
		local sprite = anim_get_sprite(front_card);

		alist = {
			info = front_card,
			sprite = sprite,
			anims = {
				{ anim_name = 'to_front' },
				{ anim_name = 'spawn', 
				  anim_parts = {
					  { anim_part = 'move', pos = pos },
					  { anim_part = 'scale', scale = scale },
					  { anim_part = 'rotate', rotation = 0 },
				  }
				},
				{ anim_name = 'to_back' },
			},
		};
		anim_group[#anim_group + 1] = { alist };

		sprite = anim_get_sprite(tar_card);
		local eff = nil;
		if front_table_index == T_HAND then
			eff = 'e_hide';
		end
		local tar_pos = ccp(sprite:getPositionX(), sprite:getPositionY());
		alist = {
			sprite = sprite,
			att_sprite = anim_get_sprite(front_card),
			layer = layer_anim.layer,
			anims = {
				{ anim_name = 'damage_anim', src_pos = pos, tar_pos = tar_pos, dtype = dtype, atype = atype, step = 1, eff = eff },
			},
		};
		anim_group[#anim_group + 1] = { alist };
		
		-- atype > 0 , eff will have two steps
		-- 1. go to target pos from origin pos
		-- 2. do eff
		--if 0 < atype and 3 ~= atype then
		if 0 < atype then
			alist = {
				sprite = sprite,
				att_sprite = anim_get_sprite(front_card),
				layer = layer_anim.layer,
				anims = {
					{ anim_name = 'damage_anim', src_pos = pos, tar_pos = tar_pos, dtype = dtype, atype = atype, step = 2 },
				},
			};
			anim_group[#anim_group + 1] = { alist };
		end

	elseif nil ~= front_card and front_index == src_index then

		local sprite = anim_get_sprite(front_card);
		local pos = ccp(front_card.frame.x, front_card.frame.y);
		local scale = front_card.frame.scale;

		alist = {
			sprite = sprite,
		 	anims = {	
				{ anim_name = 'to_front' },
				{ anim_name = 'spawn',
				  anim_parts = {
				  	  { anim_part = 'move', pos = pos },
					  { anim_part = 'scale', scale = scale },
					  { anim_part = 'rotate', rotation = 0 },
				  },
				},
				{ anim_name = 'to_back' },
			},
		};
		anim_group[#anim_group + 1] = { alist };
		
		local src_sprite = anim_get_sprite(src_card);
		local tar_sprite = anim_get_sprite(tar_card);
		local src_pos = ccp(src_sprite:getPositionX(), src_sprite:getPositionY());
		local tar_pos = ccp(tar_sprite:getPositionX(), tar_sprite:getPositionY());
		alist = {
			sprite = tar_sprite,
		    att_sprite = anim_get_sprite(src_card),
			layer = layer_anim.layer,
			anims = {
				{ anim_name = 'damage_anim', src_pos = src_pos, tar_pos = tar_pos, dtype = dtype, atype = atype },
			},
		};
		anim_group[#anim_group + 1] = { alist };

	else
		local scale = src_card.frame.scale;
		local pos = ccp(src_card.frame.x, src_card.frame.y);
		local sprite = anim_get_sprite(src_card);
		local p = ccp(sprite:getPositionX(), sprite:getPositionY());
		local s = sprite:getScale();
		if p.x ~= pos.x or p.y ~= pos.y or s ~= scale then
			alist = {
				info = src_card,
				sprite = sprite,
				anims = {
					{ anim_name = 'spawn',
					  anim_parts = {
						  { anim_part = 'move', pos = pos },
						  { anim_part = 'scale', scale = scale },
						  { anim_part = 'rotate', rotation = 0 },
					  },
					},
				},
			};
			anim_group[#anim_group + 1] = { alist };
		end

	end
	if false == anim_remove_tlist(src_index) then
		--[[
		-- no need to do below
		-- multi target attack (atype > 500) should all do anim in the same
		--   time
		local src_pos, tar_pos;
		local src_sprite = anim_get_sprite(src_card);
		local sprite = anim_get_sprite(tar_card);
		src_pos = ccp(src_sprite:getPositionX(), src_sprite:getPositionY());
		tar_pos = ccp(sprite:getPositionX(), sprite:getPositionY());
		alist = {
			sprite = sprite,
			att_sprite = anim_get_sprite(src_card),
			layer = layer_anim.layer,
			anims = {
				{ anim_name = 'damage_anim', src_pos = src_pos, tar_pos = tar_pos, dtype = dtype, atype = atype, step = 2 },
			},
		};
		anim_group[#anim_group + 1] = { alist };
		]]--
	end

	local sprite = anim_get_sprite(tar_card);

	alist = {
		sprite = sprite,
		anims = {
			{ anim_name = 'hp_num_change', offset = -power, flag = 'negative' },	
		},
	};
	anim_group[#anim_group + 1] = { alist };
	
	return anim_group;
end -- anim_action_damage_map }

function anim_action_hp(tar_index, offset, front_index) -- {
	local anim_group = {};
	local alist = nil;

	if nil == tar_index then
		return anim_group;
	end

	local tar_table_index, tar_list_index, tar_card_list, tar_card;
	tar_table_index, tar_list_index, tar_card_list, tar_card 
		= anim_get_info(tar_index);

	if tar_table_index == T_GRAVE then
		local sprite = anim_get_sprite(tar_card);
		alist = {
			sprite = sprite,
			info = tar_card,
			anims = {
				{ anim_name = 'hp_num_change', offset = offset, flag = 'positive', no_eff = true },
			},
		};
		anim_group[#anim_group + 1] = { alist };
		return anim_group;
	end

	if nil ~= front_index and front_index ~= tar_index then

		local front_table_index, front_list_index, front_card_list, front_card;
		front_table_index, front_list_index, front_card_list, front_card 
			= anim_get_info(front_index);

		local sprite = anim_get_sprite(tar_card);
		local pos = ccp(sprite:getPositionX(), sprite:getPositionY());
		local scale = sprite:getScaleX() / 2;
		sprite = anim_get_sprite(front_card);

		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'spawn', 
				  anim_parts = {
				  	  { anim_part = 'move', pos = pos },
					  { anim_part = 'scale', scale = scale },
					  { anim_part = 'rotate', rotation = 0 },
				  },
				},
				{ anim_name = 'to_back' },
			},
		};
		anim_group[#anim_group + 1] = { alist };

		alist = {
			sprite = sprite,
			anims = {	
				{ anim_name = 'particle', pname = 'dust' },
			},
		};
		anim_group[#anim_group + 1] = { alist };

	elseif front_index == tar_index then

		local front_table_index, front_list_index, front_card_list, front_card;
		front_table_index, front_list_index, front_card_list, front_card 
			= anim_get_info(front_index);

		local sprite = anim_get_sprite(front_card);
		alist = {
			sprite = sprite,
		 	anims = {
				{ anim_name = 'to_front' },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	
	end

	local sprite = anim_get_sprite(tar_card);

	--[[
	local no_eff = false;
	if tar_table_index == T_GRAVE then
		no_eff = true;
	end
	]]--
	alist = {
		sprite = sprite,
		anims = {
			{ anim_name = 'hp_num_change', offset = offset, flag = 'positive' },
		},
	};
	anim_group[#anim_group + 1] = { alist };
	
	if nil ~= front_index and front_index == tar_index then

		local sprite = anim_get_sprite(tar_card);

		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'to_front' },
			},
		};
		anim_group[#anim_group + 1] = { alist };

		local pos = ccp(tar_card.frame.x, tar_card.frame.y);
		local scale = tar_card.frame.scale;

		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'spawn', 
				  anim_parts = {
				  	  { anim_part = 'move', pos = pos },
					  { anim_part = 'scale', scale = scale },
					  { anim_part = 'rotate', rotation = 0 },
				  },
				},
				{ anim_name = 'to_back' },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	end

	return anim_group;
end -- anim_action_hp }

function anim_action_power(tar_index, offset, front_index) -- {

	local tar_table_index, tar_list_index, tar_card_list, tar_card;
	tar_table_index, tar_list_index, tar_card_list, tar_card 
		= anim_get_info(tar_index);

	local anim_group = {};
	local alist = nil;

	if tar_table_index == T_GRAVE then
		local sprite = anim_get_sprite(tar_card);
		alist = {
			sprite = sprite,
			info = tar_card,
			anims = {
				{ anim_name = 'power_num_change', offset = offset, tar_index = tar_index, no_eff = true},
			},
		};
		anim_group[#anim_group + 1] = { alist };
		return anim_group;
	end

	-- step 1
	if nil ~= front_index and front_index ~= tar_index then

		local front_table_index, front_list_index, front_card_list, front_card;
		front_table_index, front_list_index, front_card_list, front_card 
			= anim_get_info(front_index);

		local sprite = anim_get_sprite(tar_card);
		local pos = cc.p(sprite:getPositionX(), sprite:getPositionY());
		local scale = sprite:getScaleX() / 2;
		sprite = anim_get_sprite(front_card);

		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'spawn', 
				  anim_parts = {
				  	  { anim_part = 'move', pos = pos },
					  { anim_part = 'scale', scale = scale },
					  { anim_part = 'rotate', rotation = 0 },
				  },
				},
				{ anim_name = 'to_back' },
			},
		};
		anim_group[#anim_group + 1] = { alist };

		alist = {
			sprite = sprite,
			anims = {	
				{ anim_name = 'particle', pname = 'dust' },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	
	elseif front_index == tar_index then

		local front_table_index, front_list_index, front_card_list, front_card;
		front_table_index, front_list_index, front_card_list, front_card 
			= anim_get_info(front_index);

		local sprite = anim_get_sprite(front_card);

		alist = {
			sprite = sprite,
		 	anims = {
				{ anim_name = 'to_front' },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	
	end

	local sprite = anim_get_sprite(tar_card);
	local table_index = anim_index_table_num(tar_index);
	if table_index ~= T_HERO then
		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'power_num_change', offset = offset, tar_index = tar_index },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	end

	if nil ~= front_index and front_index == tar_index then

		local sprite = anim_get_sprite(tar_card);

		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'to_front' },
			},
		};
		anim_group[#anim_group + 1] = { alist };

		local pos = ccp(tar_card.frame.x, tar_card.frame.y);
		local scale = tar_card.frame.scale;

		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'spawn', 
				  anim_parts = {
				  	  { anim_part = 'move', pos = pos },
					  { anim_part = 'scale', scale = scale },
					  { anim_part = 'rotate', rotation = 0 },
				  },
				},
				{ anim_name = 'to_back' },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	end

	return anim_group;
end -- anim_action_power }

function anim_action_energy(side_index, offset, front_index) -- {
	
	local hero_card = g_ui_table[side_index][T_HERO][1];

	local front_table_index, front_list_index, front_card_list, front_card;
	front_table_index, front_list_index, front_card_list, front_card
		= anim_get_info(front_index);

	local anim_group = {};
	local alist = nil;

	-- step 1
	if nil ~= front_card and front_card ~= hero_card then

		local sprite = anim_get_sprite(hero_card);
		local pos = cc.p(sprite:getPositionX(), sprite:getPositionY());
		local scale = sprite:getScaleX() / 2;
		sprite = anim_get_sprite(front_card);

		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'spawn', 
				  anim_parts = {
				  	  { anim_part = 'move', pos = pos },
					  { anim_part = 'scale', scale = scale },
					  { anim_part = 'rotate', rotation = 0 },
				  },
				},
				{ anim_name = 'to_back' },
			},
		};
		anim_group[#anim_group + 1] = { alist };

		alist = {
			sprite = sprite,
			anims = {	
				{ anim_name = 'particle', pname = 'dust' },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	
	elseif nil ~= front_card and front_card == hero_card then

		local sprite = anim_get_sprite(front_card);

		alist = {
			sprite = sprite,
		 	anims = {
				{ anim_name = 'to_front' },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	
	end

	local sprite = anim_get_sprite(hero_card);
	alist = {
		sprite = sprite,
		anims = {
			{ anim_name = 'power_num_change', offset = offset, tar_index = nil },
		},
	};
	anim_group[#anim_group + 1] = { alist };

	if nil ~= front_card and front_card == hero_card then

		local sprite = anim_get_sprite(hero_card);

		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'to_front' },
			},
		};
		anim_group[#anim_group + 1] = { alist };

		local pos = ccp(hero_card.frame.x, hero_card.frame.y);
		local scale = hero_card.frame.scale;

		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'spawn', 
				  anim_parts = {
				  	  { anim_part = 'move', pos = pos },
					  { anim_part = 'scale', scale = scale },
					  { anim_part = 'rotate', rotation = 0 },
				  },
				},
				{ anim_name = 'to_back' },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	end

	return anim_group;
end -- anim_action_energy }

-- is_max == true  means change num for resource_max
-- is_assign == true means assign the value directly
function anim_action_resource(side_index, offset, is_max, is_assign) -- {

	local anim_group = {};
	local alist = nil;

	local sprite = nil;
	if true == is_max then
		sprite = g_ui_table.label_res_max[side_index];
	else
		sprite = g_ui_table.label_res[side_index];
	end

	--sprite = nil;
	if nil == sprite then
		return anim_group;
	end

	if true == is_assign then
		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'res_num_assign', value = offset },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	else
		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'res_num_change', offset = offset },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	end

	return anim_group;
end -- anim_action_resource }

function anim_action_show(index) -- {
	local table_index, list_index, table_list, card;
	table_index, list_index, table_list, card = anim_get_info(index);

	local anim_group = {};
	local alist;
	if nil == card then
		return anim_group;
	end
	local sprite = anim_get_sprite(card);
	local scale = ANIM_SCALE_CENTER;
	local pos = ccp(HALF_WIDTH, HALF_HEIGHT);

	alist = {
		info = card,
		sprite = sprite,
		anims = {
			{ anim_name = 'to_front' },
			{ anim_name = 'scale_front', pos = pos, scale = scale },
			{ anim_name = 'to_back' },
		},
	};
	anim_group[#anim_group + 1] = { alist };

	return anim_group;
end -- anim_action_show }

function anim_action_back(index) -- {
	local table_index, list_index, table_list, card;
	table_index, list_index, table_list, card = anim_get_info(index);

	local anim_group = {};
	local alist;
	if nil == card then
		return anim_group;
	end
	local scale = table_list.cscale;
	local pos = cc.p(card.frame.x, card.frame.y);
	local sprite = anim_get_sprite(card);

	alist = {
		info = card,
		sprite = sprite,
		anims = {
			{ anim_name = 'to_front' },
			{ anim_name = 'scale_back', pos = pos, scale = scale },
			{ anim_name = 'to_back' },
		},
	};
	anim_group[#anim_group + 1] = { alist };

	return anim_group;
end -- anim_action_back }

function anim_action_view_top(index) -- {
	local anim_group = {};
	local alist = nil;
	local sprite = nil;
	local card = nil;

	local tbl = index_table_num(index);
	local side = index_side(index);

	local ui_deck_table = g_ui_table[side][tbl];
	if #ui_deck_table <=0 then
		return anim_group;
	end

	card = ui_deck_table[1];
	if card.status == CARD_FRONT then
		return anim_group;
	end
	sprite = card.sprite;
	if nil == sprite then
		return anim_group;
	end

	alist = {
		sprite = sprite,
		card_info = card,
		anims = {
			{ anim_name = 'to_front' },
			{ anim_name = 'flip_card', orient = 'front' },
		},
	};
	anim_group[#anim_group + 1] = { alist };
	return anim_group;
end -- anim_action_view_top }

function anim_action_hide_top(index) -- {
	local anim_group = {};
	local alist = nil;
	local sprite = nil;
	local card = nil;

	if true == is_view_oppo() then
		return anim_group;
	end

	local tbl = index_table_num(index);
	local side = index_side(index);

	local ui_deck_table = g_ui_table[side][tbl];
	if #ui_deck_table <=0 then
		return anim_group;
	end

	card = ui_deck_table[1];
	if card.status == CARD_COVER then
		return anim_group;
	end
	sprite = card.sprite;
	if nil == sprite then
		return anim_group;
	end

	alist = {
		sprite = sprite,
		card_info = card,
		anims = {
			{ anim_name = 'flip_card', orient = 'back' },
		},
	};
	anim_group[#anim_group + 1] = { alist };
	return anim_group;
end -- anim_action_hide_top }

function anim_action_view_oppo(index) -- {
	local anim_group = {};
	local anim_list = {};
	local sprite = nil;
	local card = nil;

	local side = index_side(index);
	if g_euser.side == side then
		return anim_group;
	end
	local tbl = index_table_num(index);

	local ui_hand_table = g_ui_table[side][tbl];
	if #ui_hand_table <=0 then
		return anim_group;
	end

	for i=1, #ui_hand_table do
		card = ui_hand_table[i];
		sprite = card.sprite;
		if nil ~= sprite and card.status == CARD_COVER then
			anim_list[#anim_list + 1] = {
				sprite = sprite,
				card_info = card,
				anims = {
					{ anim_name = 'flip_card', orient = 'front' },
				},
			};
		end
	end

	if #anim_list > 0 then
		anim_group[#anim_group + 1] = anim_list;
	end
	return anim_group;
end -- anim_action_view_oppo }

function anim_action_hide_oppo(index) -- {
	local anim_group = {};
	local anim_list = {};
	local sprite = nil;
	local card = nil;

	if true == is_view_oppo() then
		return anim_group;
	end

	local tbl = index_table_num(index);
	local side = index_side(index);
	if g_euser.side == side then
		return anim_group;
	end

	local ui_hand_table = g_ui_table[side][tbl];
	if #ui_hand_table <=0 then
		return anim_group;
	end

	for i=1, #ui_hand_table do
		card = ui_hand_table[i];
		sprite = card.sprite;
		if nil ~= sprite and card.status == CARD_FRONT then
			anim_list[#anim_list + 1] = {
				sprite = sprite,
				card_info = card,
				anims = {
					{ anim_name = 'flip_card', orient = 'back' },
				},
			};
		end
	end

	if #anim_list > 0 then
		anim_group[#anim_group + 1] = anim_list;
	end
	return anim_group;
end -- anim_action_hide_oppo }
--------------- ANIM_ACTION END   ------------

function make_anim(eff) -- {
	local anim_group = {};
	print('DEBUG make_anim eff ', eff[1]);

	if 'card' == eff[1] then
		anim_group = anim_action_use(eff.index, eff.front_index);
	elseif 'add' == eff[1] then
		anim_group = anim_action_add(eff.index, eff.cid);
	elseif 'anim' == eff[1] then
		local list = {};
		local len = eff.total or 0;
		for i = 1, len do
			local target = eff['target' .. i];
			--print('--- !!! --- target: ', target);
			table.insert(list, target);
		end
		anim_group = anim_action_anim(eff.id, eff.index, eff.atype, list, eff.front_index);
	elseif 'move' == eff[1] then
		if eff.src_index < 10000 then
			anim_group = anim_action_move(eff.src_index, eff.target_index, eff.front_index);
			--alog('DEBUG make_anim #anim_group: ', #anim_group);
		else
			anim_group = anim_action_move_attach(eff.src_index, eff.target_index, eff.front_index);
		end	
	elseif 'attach' == eff[1] then
		if eff.attach == 0 then
			anim_group = anim_action_attach_virtual(eff.target_index, eff.attach, eff.id, eff.acid, eff.front_index);
		else
			anim_group = anim_action_attach(eff.target_index, eff.attach, eff.id, eff.acid, eff.front_index);
		end
	elseif eff[1] == 'damage' then
		if g_scene:is_stage(STAGE_PVG) then
			local tb = index_table_num(eff.target_index);
			local s = index_side(eff.target_index);
			if tb == T_HERO and s == SIDE_UP then
				return {};
			end
		end
		if eff.dtype < 5 then
			anim_group = anim_action_damage(eff.src_index, eff.target_index, eff.dtype, eff.power, eff.atype);
		else
			anim_group = anim_action_damage_map(eff.src_index, eff.target_index, eff.dtype, eff.power, eff.front_index, eff.atype);
		end

	elseif eff[1] == 'hp' then
		anim_group = anim_action_hp(eff.index, eff.offset, eff.front_index);

	elseif eff[1] == 'power' then
		anim_group = anim_action_power(eff.index, eff.offset, eff.front_index);

	elseif eff[1] == 'energy' then
		anim_group = anim_action_energy(eff.side, eff.offset, eff.front_index);

	elseif eff[1] == 'resource' then
		if g_scene:is_stage(STAGE_PVG) then
			if eff.side == SIDE_UP then
				return {};
			end
		end
		anim_group = anim_action_resource(eff.side, eff.offset, false);

	elseif eff[1] == 'resource_value' then
		if g_scene:is_stage(STAGE_PVG) then
			if eff.side == SIDE_UP then
				return {};
			end
		end
		anim_group = anim_action_resource(eff.side, eff.value, false, true);

	elseif eff[1] == 'resource_max' then
		if g_scene:is_stage(STAGE_PVG) then
			if eff.side == SIDE_UP then
				return {};
			end
		end
		anim_group = anim_action_resource(eff.side, eff.offset, true);

	elseif eff[1] == 'view_top' then
		anim_group = anim_action_view_top(eff.index);

	elseif eff[1] == 'hide_top' then
		anim_group = anim_action_hide_top(eff.index);

	elseif eff[1] == 'view_oppo' then
		anim_group = anim_action_view_oppo(eff.index);

	elseif eff[1] == 'hide_oppo' then
		anim_group = anim_action_hide_oppo(eff.index);
		

	elseif eff[1] == 'scale_front' then
		anim_group = anim_action_show(eff.index);

	elseif eff[1] == 'scale_back' then
		anim_group = anim_action_back(eff.index);

	end
	return anim_group;
end -- make_anim }

--------------- ACTION START ------------
function a_action_delay(card_action, anim_one, parray)
	local action = nil;
	local sprite = anim_one.sprite;
	local dtime = card_action.d_time or 0.5;
	action = cc.DelayTime:create(dtime);

	if nil ~= parray then
		table.insert(parray, action);
	end

	return action;
end

function a_action_scalefront(anim_action, anim_group, parray)
	local action, actions, animation;
	local info = anim_group.info;
	local sprite = anim_group.sprite;
	local pos = anim_action.pos;
	local scale = anim_action.scale;
	local rotation = 0;--info.frame.rotation;

	actions = {};
	action = cc.MoveTo:create(0.05, pos);
	table.insert(actions, action);
	action = cc.ScaleTo:create(0.05, scale/3*2);
	table.insert(actions, action);
	action = cc.RotateTo:create(0.05, rotation); 
	table.insert(actions, action);
	animation = {};
	table.insert(animation, cc.Spawn:create(actions));
	action = cc.EaseIn:create(cc.ScaleTo:create(0.1, scale+0.1), 0.1);
	table.insert(animation, action);
	action = cc.ScaleTo:create(0.1, scale-0.05);
	table.insert(animation, action);
	action = cc.EaseIn:create(cc.ScaleTo:create(0.2, scale), 0.2);
	table.insert(animation, action);

	action = cc.Sequence:create(animation);

	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_scaleback(anim_action, anim_group, parray)
	local action, actions, animation, spos, tpos;
	local info = anim_group.info;
	local sprite = anim_group.sprite;
	local pos = anim_action.pos;
	local scale = anim_action.scale;
	local cscale = sprite:getScaleX();
	local rotation = info.frame.rotation;
	spos = ccp(sprite:getPositionX(), sprite:getPositionY());

	animation = {};
	action = cc.EaseIn:create(cc.ScaleTo:create(0.05, cscale+0.1), 0.1);
	table.insert(animation, action);
	action = cc.ScaleTo:create(0.05, cscale-0.1);
	table.insert(animation, action);
	actions = {};
	tpos = cc.p((pos.x-spos.x)/2 + spos.x, (pos.y-spos.y)/2 + spos.y);
	action = cc.MoveTo:create(0.05, tpos);
	table.insert(actions, action);
	action = cc.ScaleTo:create(0.05, scale);
	table.insert(actions, action);
	action = cc.RotateTo:create(0.05, rotation); 
	table.insert(actions, action);
	table.insert(animation, cc.Spawn:create(actions));
	action = cc.EaseIn:create(cc.MoveTo:create(0.2, pos), 0.3);
	table.insert(animation, action);
	action = cc.DelayTime:create(0.03);
	table.insert(animation, action);

	action = cc.Sequence:create(animation);

	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_spawn(card_action, anim_one, parray)
	local action = nil;
	local sprite = anim_one.sprite;
	local spawn_array = {};
	for j = 1, #card_action.anim_parts do
		anim_get_action(card_action.anim_parts[j], anim_one, spawn_array);
	end
	action = cc.Spawn:create(spawn_array);

	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_move(sdata, data, parray)
	local action = nil;
	local pos = sdata.pos;
	local efftype = sdata.efftype;
	if nil == pos then
		pos = cc.p(sdata.x, sdata.y);
	end
	action = cc.MoveTo:create(0.3, pos);
	if 'ease_in' == efftype then
		action = cc.EaseIn:create(action, 0.3);
	elseif 'ease_out' == efftype then
		action = cc.EaseOut:create(action, 0.3);
	end

	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_beziermove(sdata, data, parray)
	local action = nil;
	local sprite = data.sprite;
	local efftype = sdata.efftype;
	local spos = cc.p(sprite:getPositionX(), sprite:getPositionY());
	local epos = sdata.pos;
	local time, x, y, end_point, control_point_1, control_point_2;
	time = 0.4;

	end_point = epos;
	if epos.x >= spos.x then
		x = spos.x + (epos.x - spos.x) / 3;
	else
		x = spos.x - (spos.x - epos.x) / 3;
	end
	if epos.y >= spos.y then
		y = spos.y + hfix(50);
	else
		y = spos.y - hfix(50);
	end
	control_point_1 = cc.p(x, y);
	if epos.x >= spos.x then
		x = epos.x - (epos.x - spos.x) / 3;
	else
		x = epos.x + (spos.x - epos.x) / 3;
	end
	if epos.y >= spos.y then
		y = spos.y + hfix(30);
	else
		y = spos.y - hfix(30);
	end
	control_point_2 = cc.p(x, y);
	local bezier = { control_point_1, control_point_2, end_point };
	action = cc.BezierTo:create(time, bezier);

	if 'ease_in' == efftype then
		action = cc.EaseIn:create(action, time);
	elseif 'ease_out' == efftype then
		action = cc.EaseOut:create(action, time);
	end

	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_scale(sdata, data, parray)
	local action = nil;
	local scalex, scaley;
	if nil ~= sdata.scale then
		scalex = sdata.scale;
		scaley = scalex;
	else
		scalex = sdata.x;
		scaley = sdata.y;
	end
	action = cc.ScaleTo:create(0.3, scalex, scaley);

	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_rotate(sdata, data, parray)
	local action = nil;
	action = cc.RotateTo:create(0.3, sdata.rotation);

	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_bezier(sdata, data, parray)
	local action = nil;
	local endx = sdata.endx;
	local endy = sdata.endy;
	local cp1x = sdata.cp1x;
	local cp1y = sdata.cp1y;
	local cp2x = sdata.cp2x;
	local cp2y = sdata.cp2y;
	
	local control_point_1 = cc.p(cp1x, cp1y);
	local control_point_2 = cc.p(cp2x, cp2y);
	local end_point = cc.p(endx, endy);
	local bezier = { control_point_1, control_point_2, end_point };
	action = cc.BezierTo:create(0.3 , bezier);

	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_attach(card_action, anim_one, parray)
	local action = nil;

	--[LUA] effect list: #eff_list=5
	--[LUA]     EFF card, id=38, index=2201, |
	--[LUA]     EFF move, src_index=2201, target_index=2305, |
	--[LUA]     EFF attach, target_index=2305, attach=0, acid=1032, id=38, |
	--[LUA]     EFF power, offset=1, index=2305, |
	--[LUA]     EFF resource, side=2, offset=-4, |
	-- need to create a attach card, but cannot get the card
	-- need 23052, and consider situation that play with ai, get many eff include
	-- add attach and remove attach

	action = cc.DelayTime:create(0.01);

	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;

	--[[
	local sprite = anim_one.sprite;
	local sx = anim_one.sprite:getPositionX();
	local sy = anim_one.sprite:getPositionY();

	local layer = layer_anim.layer;
	local eff_name = 'attach_1';
	local delay_per_unit = 0.05;
	local pos = ccp(sx, sy);
	local rotation = sprite:getRotation();
	local scale = sprite:getScaleX();
	local callback = callback_play_eff;
	local sprite, time = anim_play_frame(layer, eff_name, pos, rotation, scale, callback, delay_per_unit);

	action = CCDelayTime:create(time);
	return action;
	]]--
end

function anim_eff_numpop(layer, sprite, desc, offset, color)
	local fullpath = util.get_fullpath(F_FONT, FNT_CARD);
	local pos = cc.p(sprite:getPositionX(), sprite:getPositionY());
	local size = sprite:getContentSize();
	local scale = sprite:getScaleX();
	pos.x = pos.x - size.width*scale/2;
	pos.y = pos.y - size.height*scale/2;
	local sx = desc:getPositionX();
	local sy = desc:getPositionY();
	pos.x = pos.x + sx * scale;
	pos.y = pos.y + sy * scale;
	local label = util.add_labelbmf(layer, offset, fullpath, pos, ANCHOR_CENTER_CENTER, ZORDER_EFFECT);
	if flag == 'positive' then
		label:setColor(color);
	else
		label:setColor(color);
	end

	pos.y = pos.y + 40;
	local actions = {};
	table.insert(actions, cc.EaseOut:create(cc.MoveTo:create(0.5, pos), 0.5));
	table.insert(actions, cc.CallFunc:create(anim_sprite_clean));
	label:runAction(cc.Sequence:create(actions));
end

function a_action_poweranim(card_action, anim_one, parray)
	local action = nil;
	--local sprite = anim_one.sprite;

	action = cc.DelayTime:create(0);

	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_powernumchange(card_action, anim_one, parray)
	local action = nil;
	local sprite = anim_one.sprite;
	local layer = sprite:getParent();
	local offset = card_action.offset;
	local no_eff = card_action.no_eff;
	if true == no_eff then
		local info = anim_one.info;
		if nil ~= info then
			if nil ~= info.data then
				if nil ~= info.data.left_bottom then
					info.data.left_bottom = info.data.left_bottom + offset;
				end
			end
		end
		action = cc.DelayTime:create(0.1);
		if nil ~= parray then
			table.insert(parray, action);
		end
		return action;
	end
	local power_desc = sprite:getChildByTag(TAG_POWER);	
	tolua.cast(power_desc, "cc.Label");
	if nil == power_desc then
		alog('ERROR power_desc == nil');
		action = cc.DelayTime:create(0.2);
		return action;
	end
	local color;
	if card_action.flag == 'positive' then
		color = cc.c3b(248, 0, 0);
	else
		color = cc.c3b(0, 248, 0);
	end
	--local power_desc = sprite:getChildByTag(TAG_POWER);	
	--tolua.cast(power_desc, 'CCLabelBMFont');
	local power = tonumber(power_desc:getString()) + card_action.offset;
	if power < 0 then
		power = 0;
	end
	power_desc:setString(power);
	local is_out = false;
	local time = 0.1;
	if 0 < anim.eff_power_count then
		anim.eff_power_count = anim.eff_power_count - 1;
		if 0 == anim.eff_power_count then
			time = DURATION_NUM_EFF;
		end
		is_out = true;
	end
	if card_action.tar_index == anim.last_rm_attach_index then
		anim.last_rm_attach_index = 0;
		is_out = true;
	end
	if true == is_out then
		anim_eff_numpop(layer, sprite, power_desc, offset, color);
		action = cc.DelayTime:create(time);
		if nil ~= parray then
			table.insert(parray, action);
		end
		return action;
	end

	anim_eff_numpop(layer, sprite, power_desc, offset, color);
	-- the damage anim length is 0.5s, add 1s delayTime to wait damage anim finish
	action = cc.DelayTime:create(DURATION_NUM_EFF);

	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_hpanim(card_action, anim_one, parray)
	local action = nil;
	local sprite = anim_one.sprite;
	-- light animation
	--local sprite_width = sprite:getContentSize().width * sprite:getScaleX();
	--local sprite_height = sprite:getContentSize().height * sprite:getScaleY();
	local sx = sprite:getPositionX();
	local sy = sprite:getPositionY();

	--[[
	local layer = sprite:getParent();
	local pos = ccp(sx, sy);
	local rotation = sprite:getRotation();
	local scale = sprite:getScaleX();
	local callback = callback_play_eff;
	local action_sprite, time = anim_play_frame(layer, 'hp_1', pos, rotation, scale, callback, 0.3);
	]]--
	time = 0;

	action = cc.DelayTime:create(time);

	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;

end

function a_action_hpnumchange(card_action, anim_one, parray)
	local action = nil;
	local sprite = anim_one.sprite;
	local layer = sprite:getParent();
	local offset = card_action.offset;
	local no_eff = card_action.no_eff;
	if true == no_eff then
		local info = anim_one.info;
		if nil ~= info then
			if nil ~= info.data then
				if nil ~= info.data.right_bottom then
					info.data.right_bottom = info.data.right_bottom + offset;
				end
			end
		end
		action = cc.DelayTime:create(0.1);
		if nil ~= parray then
			table.insert(parray, action);
		end
		return action;
	end
	local hp_desc = sprite:getChildByTag(TAG_HP);	
	tolua.cast(hp_desc, "cc.Label");
	if nil == hp_desc then
		alog('ERROR hp_desc == nil');
		action = cc.DelayTime:create(0.2);
		if nil ~= parray then
			table.insert(parray, action);
		end
		return action;
	end

	local color;
	if card_action.flag == 'positive' then
		color = cc.c3b(0, 248, 0);
	else
		color = cc.c3b(248, 0, 0);
	end
	-- reset the sprite's hp
	--local hp_desc = sprite:getChildByTag(TAG_HP);	
	--tolua.cast(hp_desc, 'CCLabelBMFont');
	local hp = tonumber(hp_desc:getString()) + card_action.offset;
	if hp < 0 then
		hp = 0;
	end
	hp_desc:setString(hp);
	local is_out = false;
	local time = 0.1;
	if 0 < anim.eff_hp_count then
		anim.eff_hp_count = anim.eff_hp_count - 1;
		if 0 == anim.eff_hp_count then
			time = DURATION_NUM_EFF;
		end
		is_out = true;
	end
	if card_action.tar_index == anim.last_rm_attach_index then
		anim.last_rm_attach_index = 0;
		is_out = true;
	end
	if true == is_out then
		anim_eff_numpop(layer, sprite, hp_desc, offset, color);
		action = cc.DelayTime:create(time);
		if nil ~= parray then
			table.insert(parray, action);
		end
		return action;
	end

	anim_eff_numpop(layer, sprite, hp_desc, offset, color);
	-- the damage anim length is 0.5s, add 1s delayTime to wait damage anim finish
	action = cc.DelayTime:create(DURATION_NUM_EFF);

	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_resnumchange(card_action, anim_one, parray)
	local action = nil;
	local sprite = anim_one.sprite;
	local layer = layer_anim.layer;
	local offset = card_action.offset;
	local fullpath = util.get_fullpath(F_FONT, FNT_CARD);
	local pos = cc.p(sprite:getPositionX(), sprite:getPositionY());
	local size = sprite:getContentSize();
	local scale = sprite:getScaleX();
	local label = util.add_labelbmf(layer, offset, fullpath, pos, ANCHOR_CENTER_CENTER, ZORDER_EFFECT);
	if offset < 0 then
		label:setColor(cc.c3b(248, 0, 0));
	else
		label:setColor(cc.c3b(0, 248, 0));
	end
	pos.y = pos.y + 40;
	local actions = {};
	table.insert(actions, cc.EaseOut:create(cc.MoveTo:create(0.5, pos), 0.5));
	table.insert(actions, cc.CallFunc:create(anim_sprite_clean));
	label:runAction(cc.Sequence:create(actions));

	-- the damage anim length is 0.5s, add 1s delayTime to wait damage anim finish
	action = cc.DelayTime:create(0.5);

	-- reset the res label
	local new_res = tonumber(sprite:getString()) + offset;
	if new_res < 0 then
		new_res = 0;
	end
	sprite:setString(new_res);

	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_resnumassign(card_action, anim_one, parray)
	local action = nil;
	local sprite = anim_one.sprite;
	local layer = layer_anim.layer;
	local value = card_action.value;
	local fullpath = util.get_fullpath(F_FONT, FNT_CARD);
	local pos = cc.p(sprite:getPositionX(), sprite:getPositionY());
	local size = sprite:getContentSize();
	local scale = sprite:getScaleX();
	local label = util.add_labelbmf(layer, value, fullpath, pos, ANCHOR_CENTER_CENTER, ZORDER_EFFECT);
	if value < 0 then
		label:setColor(cc.c3b(248, 0, 0));
	else
		label:setColor(cc.c3b(0, 248, 0));
	end
	pos.y = pos.y + 40;
	local actions = {};
	table.insert(actions, cc.EaseOut:create(cc.MoveTo:create(0.5, pos), 0.5));
	table.insert(actions, cc.CallFunc:create(anim_sprite_clean));
	label:runAction(cc.Sequence:create(actions));

	-- the damage anim length is 0.5s, add 1s delayTime to wait damage anim finish
	action = cc.DelayTime:create(0.5);

	-- reset the res label
	sprite:setString(value);

	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_abli(card_action, anim_one, parray)
	local action = nil;
	local sprite = anim_one.sprite;
	--[[
	local sx = sprite:getPositionX();
	local sy = sprite:getPositionY();

	local layer = sprite:getParent();
	local pos = ccp(sx, sy);
	local rotation = sprite:getRotation();
	local scale = sprite:getScaleX();
	local callback = callback_play_eff;
	local acton_sprite, time = anim_play_frame(layer, 'attack_4', pos, rotation, scale, callback, 0.1);

	]]--
	local time = 0;
	action = cc.DelayTime:create(time);

	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;

end

function a_action_atnormal(card_action, anim_one, parray)
	local action = nil;
	local time = 0;
	local attacker = anim_one.att_sprite;
	local defender = anim_one.def_sprite;
	local layer = layer_anim.layer;
	local dtype = card_action.dtype;
	local sframe = card_action.sframe;
	local tframe = card_action.tframe;
	local svv = 1;
	if sframe.y > HALF_HEIGHT then
		svv = -1;
	end

	if 1 == dtype or 4 == dtype then
		if true == USE_FLASH then
			time = play_flash(layer, 0, attacker, defender, 0, false);
		else
			local esprite;
			esprite,time = attack_eff(layer, attacker, defender, sframe, tframe,time);
		end
		time = time + 0.2;
	end
	local action = cc.DelayTime:create(time);

	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_damageanim(card_action, anim_one, parray)
	local action = nil;
	local time = 0;
	local att_sprite = anim_one.att_sprite;
	local sprite = anim_one.sprite;
	local layer = layer_anim.layer;
	local atype = card_action.atype or 0;
	local dtype = card_action.dtype;
	local eff = card_action.eff;

	--[[
	if atype == 3 then -- laser
		-- also relative to anim_action_damage_map
		local time = action_skill(layer, att_sprite, sprite, 1.0);
		local action = cc.DelayTime:create(time);

		if nil ~= parray then
			table.insert(parray, action);
		end
		return action;
	elseif atype > 0 then
	]]--
	if atype > 0 then
		local step = card_action.step;
		if true == USE_FLASH then
			time = play_flash(layer, atype, att_sprite, sprite, step, eff);
		else
			time = play_eff(layer, atype, att_sprite, sprite, step, eff);
		end
		action = cc.DelayTime:create(time);
		if nil ~= parray then
			table.insert(parray, action);
		end
		return action;
	end

	if 1 == dtype then
		--[[
		--local asprite = anim_one.att_sprite;
		local f = card_action.f;
		local eff_name = 'attack_1';
		local dlu = 0.06; -- delay_per_unit;
		local time = action_fight(layer, att_sprite, sprite, f, eff_name, dlu);
		]]--
		local time = 0;
		local action = cc.DelayTime:create(time);
		if nil ~= parray then
			table.insert(parray, action);
		end
		return action;
	end
	
	local sx = sprite:getPositionX();
	local sy = sprite:getPositionY();

	local eff_name = nil;
	local delay_per_unit = 0;
	if 1 == dtype then
		eff_name = 'attack_1';
		delay_per_unit = 0.07;

	--[[
	elseif 8 == dtype then
		eff_name = 'attack_3';
		delay_per_unit = 0.1;
	]]--

	--elseif 7 == dtype or 6 == dtype or 9 == dtype then
	--else
		--eff_name = 'attack_2';
		--delay_per_unit = 0.1;
	
	else
		local action = cc.DelayTime:create(0.01);
		if nil ~= parray then
			table.insert(parray, action);
		end
		return action;
	end
	if nil ~= eff_name then
		local pos = ccp(sx, sy);
		local rotation = sprite:getRotation();
		local scale = sprite:getScaleX();
		local callback = callback_play_eff;
		local sprite, time = anim_play_frame(layer, eff_name, pos, rotation, scale, callback, delay_per_unit);

		action = cc.DelayTime:create(time);
		if nil ~= parray then
			table.insert(parray, action);
		end
		return action;
	end

	action = cc.DelayTime:create(0.1);
	if nil ~= parray then
		table.insert(parray, action);
	end

	return action;
end

function a_action_efflayer(card_action, anim_one, parray)
	local action = nil;
	local time = 0;
	local layer_anim = anim_one.layer_anim;
	local layer_card = anim_one.layer_card;
	local etype = card_action.etype;

	if 'shake' == etype then
		if nil ~= layer_anim then
			layer_anim:shake(0.2, 6, 0);
		end
		if nil ~= layer_card then
			layer_card:shake(0.2, 6, 0);
		end
	end

	action = cc.DelayTime:create(0.1);
	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_effsprite(card_action, anim_one, parray)
	local action = nil;
	local time = 0;
	local sprite = anim_one.sprite;
	local etype = card_action.etype;
	local duration = card_action.duration;
	local radius = card_action.radius;
	local delay = card_action.delay;

	if nil ~= sprite then
		if 'shake' == etype then
			sprite:shake(duration, radius, delay);
		end
	end

	action = cc.DelayTime:create(0.1);
	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_tofront(card_action, anim_one, parray)
	local action = nil;
	local sprite = anim_one.sprite;
	action = cc.CallFunc:create(callback_front);
	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_toback(card_action, anim_one, parray)
	local action = nil;
	local sprite = anim_one.sprite;
	action = cc.CallFunc:create(callback_table);
	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_tozorder(card_action, anim_one, parray)
	local action = nil;
	local sprite = anim_one.sprite;
	local zorder = card_action.zorder;
	local function cb()
		local layer = sprite:getParent();
		layer:reorderChild(sprite, zorder);
	end
	action = cc.CallFunc:create(cb);
	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end


function a_action_remove(card_action, anim_one, parray)
	local action = nil;
	local sprite = anim_one.sprite;
	local card = anim_one.info.card;
	g_sprite_cache[card] = nil;
	anim.cache[card] = nil;
	action = cc.CallFunc:create(anim_callback_remove);
	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_showfullcard(card_action, anim_one, parray)
	local action = nil;
	local card_info = anim_one.card_info;
	local osprite = anim_one.sprite;
	local time = card_action.time;
	local owidth = osprite:getContentSize().width * osprite:getScaleX();

	local sprite = card_info:get_action_sprite(layer_anim.layer, cc.p(HALF_WIDTH, HALF_HEIGHT), 0, 1);
	local scale = owidth/sprite:getContentSize().width;
	sprite:setScale(scale);
	local scale_time = 0.1;
	local cwidth = FULL_WIDTH - wfix(50);
	local cheight = FULL_HEIGHT - hfix(300);
	local scale_to = get_card_scale(cwidth, cheight, CARD_SIZE);

	local array = {};
	table.insert(array, cc.ScaleTo:create(scale_time, scale_to));
	table.insert(array, cc.DelayTime:create(time));
	table.insert(array, cc.ScaleTo:create(scale_time, scale));
	table.insert(array, cc.CallFunc:create(callback_remove_sprite));
	sprite:runAction(cc.Sequence:create(array));

	--sprite:flip_to_front();
	action = cc.DelayTime:create(time+scale_time*2);
	if nil ~= parray and nil ~= action then
		table.insert(parray, action);
	end
	return action;
end

function a_action_flipcard(card_action, anim_one, parray)
	local action = nil;
	local sprite = anim_one.sprite;
	local card_info = anim_one.card_info;
	local orient = card_action.orient;

	local function callback_to_front()
		alog('DEBUG action_flipcard callback_front');
		card_info:flip_to_front();
		return;
	end

	local function callback_to_back()
		card_info:flip_to_cover();
	end

	local orbit_time = 0.3;
	local anims_array = {};
	local orbit1 = cc.OrbitCamera:create(orbit_time, 1, 0, 0, -90, 0, 0);
	local orbit2 = cc.OrbitCamera:create(orbit_time, 1, 0, 90, -90, 0, 0);
	table.insert(anims_array, orbit1);
	if orient == 'back' then
		table.insert(anims_array, cc.CallFunc:create(callback_to_back));
	else
		table.insert(anims_array, cc.CallFunc:create(callback_to_front));
	end
	table.insert(anims_array, orbit2);

	action = cc.Sequence:create(anims_array);

	--sprite:flip_to_front();
	if nil ~= parray and nil ~= action then
		table.insert(parray, action);
	end
	return action;
end

function a_action_particle(card_action, anim_one, parray)
	local action = nil;
	if 'sac' == card_action.ptype then
		local function show_tail(...)
			local args = { ... };
			local sprite = args[1];
			local x, y = sprite:getPosition();
			local res;
			if y > HALF_HEIGHT then
				res = g_ui_table.label_res_max[SIDE_UP];
			else
				res = g_ui_table.label_res_max[SIDE_DOWN];
			end
			local tx, ty = res:getPosition();
			local parent = sprite:getParent();
			local path = util.get_path('sac_eff.plist');
			local tail = util.add_particle(parent, path, cc.p(x, y), 64);
			local tlist = {};
			table.insert(tlist, cc.MoveTo:create(0.5, cc.p(tx, ty)));
			tail.batch:runAction(cc.Sequence:create(tlist));
		end
		local alist = {};
		table.insert(alist, cc.CallFunc:create(show_tail));
		table.insert(alist, cc.DelayTime:create(0.8));
		action = cc.Spawn:create(alist);
		--action = cc.CallFunc:create(a_particle_sac);
		if nil ~= parray and nil ~= action then
			table.insert(parray, action);
		end
		return action;
	end
	if 'ab_tail' == card_action.ptype then
		action = a_particle_shoot(card_action, anim_one, parray);
		return action;
	end
	local sprite = anim_one.sprite;
	local scale = card_action.scale or 1;
	local pname = card_action.pname .. '.plist';
	local fullpath;
	local layer = sprite:getParent();
	local pos = cc.p(sprite:getPositionX(), sprite:getPositionY());
	local zorder = sprite:getLocalZOrder();

	fullpath = util.get_fullpath(F_PARTICLE, pname);
	local info = util.add_particle(layer, fullpath, pos, zorder-1);
	scale = sprite:getScale();
	info.batch:setScale(scale);

	action = cc.DelayTime:create(0.5);
	if nil ~= parray and nil ~= action then
		table.insert(parray, action);
	end
	return action;
end

function a_action_hide(card_action, anim_one, parray)
	local sprite = anim_one.sprite;
	action = cc.Hide:create();
	if nil ~= parray and nil ~= action then
		table.insert(parray, action);
	end
	return action;
end

function a_action_show(card_action, anim_one, parray)
	local sprite = anim_one.sprite;
	action = cc.Show:create();
	if nil ~= parray and nil ~= action then
		table.insert(parray, action);
	end
	return action;
end

function a_action_fade(card_action, anim_one, parray)
	--local sprite = anim_one.sprite;
	local f_to = card_action.f_to;
	local time = card_action.time or 0.3;

	action = cc.FadeTo:create(time, f_to);
	if nil ~= parray and nil ~= action then
		table.insert(parray, action);
	end
	return action;
end

function a_action_decktohand(card_action, anim_one, parray)
	local sprite = anim_one.sprite;
	local dpos = cc.p(sprite:getPositionX(), sprite:getPositionY());
	local hpos = card_action.end_pos;
	local scale = card_action.scale;
	local tar_side = card_action.tar_side;

	local factor = 1;
	if tar_side ~= g_euser.side then
		factor = -1;
	end
	local farray, array, action, x, y;
	farray = {};
	array = {};

	local end_point, control_point_1, control_point_2;
	spos = dpos;
	epos = hpos;
	end_point = epos;
	--conf.controlPoint_1 = ccp(dpos.x+(hpos.x-dpos.x)/2, spos.y-50);
	--conf.controlPoint_2 = ccp(epos.x-10, epos.y-40);
	--conf.controlPoint_1 = ccp(dpos.x+(hpos.x-dpos.x)/2, spos.y+50*factor);
	--conf.controlPoint_2 = ccp(epos.x-10, epos.y+40*factor);
	x = dpos.x + (hpos.x - dpos.x) / 2;
	y = spos.y + hfix(50) * factor;
	control_point_1 = cc.p(x, y);
	x = epos.x - wfix(10);
	y = epos.y + hfix(40) * factor;
	control_point_2 = cc.p(x, y);
	local bezier = { control_point_1, control_point_2, end_point };
	action = cc.BezierTo:create(0.5, bezier);
	action = cc.EaseOut:create(action, 0.5);
	table.insert(array, action);

	action = cc.Sequence:create(array);
	array = {};
	table.insert(array, action);

	action = cc.ScaleTo:create(0.5, scale);
	table.insert(array, action);

	action = CCSpawn:create(array);
	table.insert(farray, action);

	action = cc.Sequence:create(farray);
	if nil ~= parray and nil ~= action then
		table.insert(parray, action);
	end

	return action;
end

function a_action_fromgrave(card_action, anim_one, parray)
	local info = card_action.info;
	local ui_table = card_action.ui_table;
	local index = card_action.index;
	local side = anim_index_side(index);
	local t = anim_index_table_num(index);
	if true == data_handler.show_all_card then
		info:get_front();
	elseif side ~= g_euser.side and (t == T_HAND or t == T_DECK) then
		info:get_cover();
	else
		info:get_front();
	end

	action = cc.DelayTime:create(0.1);
	if nil ~= parray and nil ~= action then
		table.insert(parray, action);
	end

	return action;
end

function a_action_tograve(card_action, anim_one, parray)
	local info = card_action.info;
	local ui_table = card_action.ui_table;
	local index = card_action.index;
	local pos = info:get_grave_pos(ui_table, index);
	local sprite = info:change_grave(pos, ui_table.pic_scale);

	action = cc.DelayTime:create(0.1);
	if nil ~= parray and nil ~= action then
		table.insert(parray, action);
	end

	return action;
end

function a_action_removecsprite(card_action, anim_one, parray)
	local action = nil;
	local obj = card_action.obj;
	obj:remove_sprite();

	action = cc.DelayTime:create(0.1);
	if nil ~= parray and nil ~= action then
		table.insert(parray, action);
	end
	return action;
end
--------------- ACTION END   ------------

-- data is the whole info, include sprite, layer or sth
-- sdata is sub data, just list[i]
function anim_get_action(sdata, data, array) -- {
	local action = nil;
	local tname = sdata.anim_name;
	-- just for spawn, should remove
	if nil == sdata.anim_name and nil ~= sdata.anim_part then
		tname = sdata.anim_part;
	end
	--------
	if tname == 'delay' then
		action = a_action_delay(sdata, data, array);

	elseif tname == 'scale_front' then
		action = a_action_scalefront(sdata, data, array);

	elseif tname == 'scale_back' then
		action = a_action_scaleback(sdata, data, array);
	
	elseif tname == 'spawn' then
		action = a_action_spawn(sdata, data, array);
	
	elseif tname == 'move' then
		action = a_action_move(sdata, data, array);

	elseif tname == 'bezier_move' then
		action = a_action_beziermove(sdata, data, array);

	elseif tname == 'scale' then
		action = a_action_scale(sdata, data, array);

	elseif tname == 'rotate' then
		action = a_action_rotate(sdata, data, array);

	elseif tname == 'bezier' then
		action = a_action_bezier(sdata, data, array);
		
	elseif tname == 'attach' then
		action = a_action_attach(sdata, data, array);

	elseif tname == 'power_anim' then
		action = a_action_poweranim(sdata, data, array);

	elseif tname == 'power_num_change' then
		action = a_action_powernumchange(sdata, data, array);

	elseif tname == 'hp_anim' then
		action = a_action_hpanim(sdata, data, array);
	
	elseif tname == 'hp_num_change' then
		action = a_action_hpnumchange(sdata, data, array);

	elseif tname == 'res_num_change' then
		action = a_action_resnumchange(sdata, data, array);

	elseif tname == 'res_num_assign' then
		action = a_action_resnumassign(sdata, data, array);

	-- let the card shine
	elseif tname == 'abli' then
		action = a_action_abli(sdata, data, array);

	elseif tname == 'at_normal' then
		action = a_action_atnormal(sdata, data, array);

	elseif tname == 'damage_anim' then
		action = a_action_damageanim(sdata, data, array);

	elseif tname == 'eff_layer' then
		action = a_action_efflayer(sdata, data, array);

	elseif tname == 'eff_sprite' then
		action = a_action_effsprite(sdata, data, array);

	-- change zorder, move the card to top
	elseif tname == 'to_front' then
		action = a_action_tofront(sdata, data, array);
	
	-- change zorder, move the card to table
	elseif tname == 'to_back' then
		action = a_action_toback(sdata, data, array);

	elseif tname == 'to_zorder' then
		action = a_action_tozorder(sdata, data, array);

	elseif tname == 'remove' then
		action = a_action_remove(sdata, data, array);

	elseif tname == 'show_full_card' then
		action = a_action_showfullcard(sdata, data, array);

	elseif tname == 'flip_card' then
		action = a_action_flipcard(sdata, data, array);

	elseif tname == 'particle' then
		action = a_action_particle(sdata, data, array);

	elseif tname == 'hide' then
		action = a_action_hide(sdata, data, array);

	elseif tname == 'show' then
		action = a_action_show(sdata, data, array);

	elseif tname == 'fade' then
		action = a_action_fade(sdata, data, array);

	elseif tname == 'deck_to_hand' then
		action = a_action_decktohand(sdata, data, array);

	elseif tname == 'from_grave' then
		action = a_action_fromgrave(sdata, data, array);

	elseif tname == 'to_grave' then
		action = a_action_tograve(sdata, data, array);

	elseif tname == 'remove_cpsrite' then
		action = a_action_removecsprite(sdata, data, array);
	end

	return action;
end -- anim_get_action end }

function anim_call_next()
	--alog('DEBUG do anim_call_next counter, length: ', anim.anim_list_counter, anim.anim_list_length);
	anim.anim_list_counter = anim.anim_list_counter + 1;
	if anim.anim_list_counter >= anim.anim_list_length then
		if nil == anim.anim_list then
			alog('DEBUG anim_call_next anim.anim_list == nil');
			anim_run_efflist(anim.eff_list);
			return;
		end
		if 0 == #anim.anim_list then
			alog('DEBUG anim_call_next #anim.anim_list == 0');
			anim_run_efflist(anim.eff_list);
			return;
		end
		run_anim(anim.anim_list[1], anim.anim_list);
	end
end

function run_sprite_actions(anim_one) -- {
	--alog('DBEUG run_sprite_actions() start');
	if nil == anim_one.anims then 
		--print('run_sprite_actions nil == anim_one.anims');
		return; 
	end
	
	-- can nil, just set layer visible
	if nil == anim_one.sprite then
		-- if no sprite actions, use the hero sprite run the callback_next
		--alog('DEBUG run_sprite_actions sprite is nil');
		anim_one.sprite = anim_get_sprite(g_ui_table[g_current_side][T_HERO][1]);
	end
	
	local anims_array = {};
	local callFunc = nil;
	
	local reorder_list = {};
	local card_actions = anim_one.anims;
	
	-- make real sprite action
	--alog('DEBUG #card_actions: ', #card_actions);
	local action = nil;
	for i = 1, #card_actions do
		--alog('DBEUG card_actions[i].anim_name: ', i, card_actions[i].anim_name);
		anim_get_action(card_actions[i], anim_one, anims_array);
	end

	--table.insert(anims_array, cc.DelayTime:create(0.5)); 
	table.insert(anims_array, cc.CallFunc:create(anim_call_next));
	--alog('DEBUG run_sprite_actions arraycount: ', anims_array:count());
	if nil ~= anim_one.sprite then
		anim_one.sprite:runAction(cc.Sequence:create(anims_array));
	else
		alog('ERROR anim_one.sprite is nil !!!');
	end
end   -- run_sprite_actions end }

function anim_get_sprite(cinfo, pos, scale)
	if nil == cinfo then
		alog('BUG anim_get_sprite cinfo == nil');
		anim_end();
		return;
	end
	local sprite = nil;
	local card = cinfo.card;
	sprite = anim.cache[card];
	if nil ~= sprite then
		return sprite;
	end
	sprite = cinfo.sprite;
	sprite = switch_layer(sprite, layer_anim.layer);
	-- because attachment add to layer from sprite, position will be wrong,
	-- so should set it
	if nil ~= pos then
		sprite:setPosition(pos);
	end
	if nil ~= scale then
		sprite:setScale(scale);
	end
	-- in case: card from deck maybe invisible
	-- because: if pos in deck more than 4, card will be set to invisible
	sprite:setVisible(true);
	anim.cache[card] = sprite;
	return sprite;
end

function anim_run_efflist(list)
	--alog('DEBUG do run_efflist #list: ', #list);
	-- 1.has anim == {true, {{anim}, {anim}}}
	-- 2.all eff_list finish == {false, {}}
	-- 3.error == {false, nil}
	local anim_info = efflist_to_anim(list);
	--local has_anim = anim_info[1];
	--local anim_group = anim_info[2];
	local has_anim = anim_info.has_anim;
	local anim_group = anim_info.anim_group;

	if nil == anim_group then
		alog('DEBUG run_efflist anim_group == nil'); 
		anim_return('run_efflist nil==anim_group');
		return;
	end

	if false == has_anim then
		alog('DEBUG run_efflist has_anim == false'); 
		anim_return();
		return;
	end

	if 0 == #anim_group then
		anim_run_efflist(list);
	else
		anim.anim_list = anim_group;
		run_anim(anim_group[1], anim_group);
	end
	return;
end

function anim_sprite_clean(...)
	local arg = {...}
	local sprite = arg[1];
	if nil == sprite then
		alog('BUG nil == sprite');
		return nil;
	end
	sprite:stopAllActions();
	sprite:setVisible(false);
	sprite:removeFromParentAndCleanup(true);
end

function anim_return(err)
	alog('DEBUG do anim_return');
	if nil ~= err then
		alog('ERROR ' .. err);
	end
	anim_end();
end

function anim_start(q)
	disable_touch();
	
	kdebug("----------vvvvvvv START ANIM MAIN!!!!! vvvvvvv----------");
	g_scene:add_layer(ZORDER_LAYER_ANIM, layer_anim:create());

	-- init to {};
	anim.eff_list = {};
	anim.anim_list = {};
	-- g_callback_list write here only!
	anim.callback_list = q.callback_list;

	--alog('DBEUG anim_start #eff_list, front_card_index: ', #q.eff_list, q.front_card_index);
	anim.eff_list = anim_preprocess_efflist(q.eff_list, q.front_card_index);
	if 0 == #anim.eff_list then
		anim_end();
		return;
	end
	anim_run_efflist(anim.eff_list);
	return;
end

function anim_end(force_quit)

	if true == force_quit then
		for k, v in pairs(anim.cache) do
			g_sprite_cache[k] = nil;
		end
	else
		for k, v in pairs(anim.cache) do
			--alog('anim_end stopAllActons ', k.id, k.name);
			v:stopAllActions();
			v = switch_layer(v, layer_card.layer);
			g_sprite_cache[k] = v;
		end
	end

	anim.cache = {};
	anim_remove_tlist(nil, true); 
	anim.eff_hp_count = 0;
	anim.eff_power_count = 0;
	anim.last_rm_attach_index = 0;

	layer_anim:remove();
	if true == force_quit then
		anim.queue = {};
	else
		--alog('DEBUG anim_end queue before remove: ', #anim.queue);
		table.remove(anim.queue, 1);
		--alog('DEBUG anim_end queue after remove: ', #anim.queue);
	end

	enable_touch();

	print('----------^^^^^^ END ANIM MAIN!!!!! ^^^^^^----------');

	if #anim.queue > 0 then
		--alog('DEBUG anim_end #anim.queue: ', #anim.queue);
		local q = anim.queue[1];
		anim_start(q);
		return;
	end

	alog(' >>>>>>>>>> ANIM QUEUE EMPTY <<<<<<<<<<<<<');
	
	-- callback to deck, anim is done
	anim.callback_list = anim.callback_list or {};

	for i = 1, #anim.callback_list do
		local callback = anim.callback_list[i];
		if nil ~= callback then
			callback();
		end
	end
end

function anim.main(eff_list, callback_list, front_card_index)
	local list = {
		eff_list = eff_list,
		callback_list = callback_list,
		front_card_index = front_card_index,
	};
	alog('DEBUG anim.main queue before insert: ', #anim.queue);
	local is_empty = false;
	if 0 == #(anim.queue or {}) then
		is_empty = true;
	end
	table.insert(anim.queue, list);
	--alog('DEBUG anim.main queue after insert: ', #anim.queue);
	if true == is_empty then
		local q = anim.queue[1];
		anim_start(q);
	end
end
-- /////////////////////// ANIM END   ///////////////////////////

-- /////////////////////// NETWORK START ///////////////////////////
function pop_chat(parent, pos, alias, time, str, is_vip)
	if nil == parent then
		return;
	end
	alias = alias or '';
	str = str or '';
	time = time or '';
	alias = alias or '';
	is_vip = is_vip or 0;
	--local fullrect = cc.rect(0, 0, 176, 91);
	--local insetrect = cc.rect(85, 42, 6, 4);
	--local size = cc.size(176, 91);
	--local fullpath = util.get_fullpath(F_IMAGE, 'bg_99.png');
	local fullrect = cc.rect(0, 0, 78, 78);
	local insetrect = cc.rect(35, 35, 8, 8);
	local size = cc.size(176, 91);
	local fullpath = util.get_path('bg_13.png');
	local sprite = util.add_scale9sprite(parent, fullpath, pos, ANCHOR_CENTER_DOWN, fullrect, insetrect, size); 

	local width = 0;
	local height = 0;

	local pos;
	local icon_vip = nil;
	local icon_width = 0;
	if is_vip == 1 then
		local fpath = util.get_fullpath(F_IMAGE, 'icon_vip2.png');
		pos = ccp(0, 3);
		icon_vip = util.add_sprite(sprite, fpath, pos, ANCHOR_LEFT_UP, 100);
		icon_vip:setScale(.8);
		icon_width = icon_vip:getContentSize().width * .8;
		pos = cc.p(icon_width + 3, 0);
	else
		pos = cc.p(0, 0);
	end
	local tlabel = util.add_label(sprite, alias, 23, pos, util.c_red, ANCHOR_LEFT_UP, 100);
	local theight = tlabel:getContentSize().height;
	local rlabel = util.add_label(sprite, str, 23, cc.p(0, 0), util.c_black, ANCHOR_LEFT_UP, 100);
	if rlabel:getContentSize().width > wfix(400) then
		rlabel:removeFromParentAndCleanup(true);
		rlabel = util.add_label(sprite, str, 23, cc.p(0, 0), util.c_black, ANCHOR_LEFT_UP, 100, cc.size(wfix(400), 70), cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_TOP);
	end
	local rwidth = rlabel:getContentSize().width;
	if tlabel:getContentSize().width + icon_width > rwidth then
		rwidth = tlabel:getContentSize().width + icon_width;
	end
	local rheight = rlabel:getContentSize().height;
	width = rwidth + 32;
	height = theight + rheight + 50;
	if width < 176 then width = 176; end
	if height < 91 then height = 91; end
	sprite:setContentSize(width, height);
	tlabel:setPosition(cc.p(20, height - 15));
	rlabel:setPosition(cc.p(20, height - 45));
	if nil ~= icon_vip then
		icon_vip:setPosition(cc.p(15, height - 12));
--		icon_vip:setPosition(cc.p(0,0));
		tlabel:setPosition(cc.p(20 + icon_width + 3, height - 15));
	end

	--util.add_labeloutline(sprite, str, nil, 25, cc.p(size.width/2, size.height/2), util.c4b_white, util.c4b_black, 1, ANCHOR_CENTER_CENTER, 1, size, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);

	local actions = {};
	table.insert(actions, cc.DelayTime:create(2));
	table.insert(actions, cc.CallFunc:create(callback_remove_sprite));

	sprite:runAction(cc.Sequence:create(actions));
end

-- channel: C_WORLD, C_ROOM, C_LOG
-- fid: from_id
-- fname: from_name
-- msg: message
function add_chat_msg(channel, eid, alias, msg, time, is_vip)
	if channel ~= C_LOG then
		msg = util.string_cut_by_size(msg, nil);
	end
	local list = g_chat_list[channel];
	if nil == list then
		kerror("channel[%d] not exist", channel);
		return;
	end
	local info;
	info = {channel = channel, eid = eid, alias = alias, msg = msg, time = time, is_vip = is_vip or 0 }; 
	table.insert(list, info);
	list = g_chat_list[C_ALL];
	if nil ~= list and channel ~= C_LOG then
		table.insert(list, info);
	end
	layer_chat:refresh();
	if g_scene:is_battle() and eid ~= g_euser.eid and layer_chat.layer == nil and (channel == C_ROOM or channel == C_PRIVATE) then
		if nil ~= layer_table.btn_chat then
			--local s = layer_table.btn_chat;
			--local x, y = s:getPosition();
			--local size = s:getContentSize();
			--local pos = cc.p(x+size.width/2*s:getScaleX(),y+size.height/2*s:getScaleY());
			local pos = cc.p(HALF_WIDTH, HALF_HEIGHT+50);
			pop_chat(layer_touch.layer, pos, alias, time, msg, is_vip);
		end
	end
end

function show_loading(text)
	if nil ~= layer_loading.layer then
		return;
	end
	g_scene:add_layer(ZORDER_LAYER_LOADING, layer_loading:create(text));
end

function hide_loading()
	layer_loading:remove();
end

function show_netloading()
	local str = '联网中...';
	show_loading(str);
end

function hide_netloading()
	hide_loading();
end

function net_show_err(input_list, err)
	hide_netloading();
	g_scene:add_layer(ZORDER_LAYER_MSG, layer_msg:create(err));
end

function net_greconn(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
end

function net_gerr(input_list, str, check)
	if check == -99 then
		local layer, name = layer_msg:create(input_list[3],logout);
		layer:setTag(TAG_MSG_OTHER_LOGIN);
		g_scene:add_layer(ZORDER_LAYER_MSG, layer, name);
		return;
	end
	show_err(str);
	if g_scene:is_stage(STAGE_PVP) then
		net_send("ginfo");
		return;
	end
	if g_scene:is_stage(STAGE_PVE) then
		refresh_layer_card();
		return;
	end
end

function net_reconn(input_list, str, check)
	if nil ~= g_scene:getChildByTag(TAG_MSG_OTHER_LOGIN) then
		return;
	end
	if true == g_scene:is_online() then
		local msg = '连接错误,点击重连[' .. str .. ']';
		g_scene:add_layer(ZORDER_LAYER_MSG,layer_msg:create(msg,callback_reconn));
	end
end

function show_err(str)
	add_chat_msg(C_LOG, 1, '系统', str, get_time());
	show_msg(str);
end

function show_msg(str)
	local layer, sprite, pos, size, path;
	layer = layer_touch.layer;
	pos = cc.p(HALF_WIDTH, FULL_HEIGHT/4*3);
	local fullrect = cc.rect(0, 0, 64, 64);
	local insetrect = cc.rect(30, 30, 4, 4);
	size = cc.size(wfix(512), hfix(128));
	path = util.get_path('pop_up.png');
	sprite = util.add_scale9sprite(layer, path, pos, ANCHOR_CENTER_CENTER, fullrect, insetrect, size); 

	util.add_labeloutline(sprite, str, nil, 25, cc.p(size.width/2, size.height/2), util.c4b_white, util.c4b_black, 1, ANCHOR_CENTER_CENTER, 1, size, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);

	local animation = {};
	local action = cc.MoveBy:create(0.7, cc.p(wfix(0), hfix(50)));
	table.insert(animation, cc.EaseIn:create(action, 0.7));
	table.insert(animation, cc.FadeTo:create(0.5, 158));

	local action_final = {};
	table.insert(action_final, cc.Sequence:create(animation));
	table.insert(action_final, cc.CallFunc:create(callback_remove_sprite));

	sprite:runAction( cc.Sequence:create( action_final ) );
end

function callback_reconn()
	if g_scene:is_stage(STAGE_LOGIN) then
		return;
	end
	g_scene:connect_to_net();
	local u = util.load_rms('username', 'string');
	local p = util.load_rms('password', 'string');
	--print('DEBUG net_reconn u, p', u, p);
	if nil == u or nil == p then
		g_scene:login();
		return;
	end
	net_cmd_log(u, p);
end

-- CMD getsite type
-- type: 0 DEVICE_UNKNOWN 1 DEVICE_IOS 2 DEVICE_ANDROID
-- RET getsite type url
function net_getsite(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local dtype = check;
	local url = input_list[3];
	if nil == url then return; end
	util.open_url(url);
end

function go_download_client()
	local dtype = DEVICE_UNKNOWN;
	local platform = cc.Application:getInstance():getTargetPlatform();
	if platform == cc.PLATFORM_OS_IPHONE or platform==cc.PLATFORM_OS_IPAD then
		dtype = DEVICE_IOS;
	elseif platform == cc.PLATFORM_OS_ANDROID then
		dtype = DEVICE_ANDROID;
	elseif platform == cc.PLATFORM_OS_WINDOWS then
	end
	local cmd = 'getsite ' .. dtype;
	net_send(cmd);
end

-- CMD log [username] [password] [platform] [channel]
-- platform/channel is optional
-- RET log [eid] [st] [alias] [icon] [gid] [gpos] [gname] [level] [exp] [exp_next]
--        [exp_this] [logic_ver] [client_ver]
-- gpos see in GUILD_POS
-- if no guild gid 0  gpos 0 gname _no_guild
function net_log(input_list, str, check)
	if check <= 0 then -- eid cannot be 0 either
		g_euser.username = '';
		show_err(str);
		return;
	end
	local logic_version = tonumber(input_list[13]);
	local game_version = tonumber(input_list[14]);
	local client_version = tonumber(input_list[15]);
	--kdebug("version: client[%d]game[%d]logic[%d]", client_version, game_version, logic_version);
	if client_version > CLIENT_VERSION then
		local t = '客户端版本过旧，请点击确认下载安装新版本';
		local c = go_download_client;
		g_scene:add_layer(ZORDER_LAYER_MSG,layer_msg:create(t, c));
		return;
	end
	if game_version > tonumber(GAME_VERSION) then
		local t = '资源版本过旧，请点击确认进行更新';
		local c = util.relaunch_game;
		g_scene:add_layer(ZORDER_LAYER_MSG,layer_msg:create(t, c));
		return;
	end
	if logic_version > tonumber(LOGIC_VERSION) then
		local t = '资源版本过旧，请点击确认进行更新';
		local c = util.relaunch_game;
		g_scene:add_layer(ZORDER_LAYER_MSG,layer_msg:create(t, c));
		return;
	end
	g_euser.eid      = check;
	g_euser.st       = tonumber(input_list[3]);
	g_euser.alias    = input_list[4];
	g_euser.icon     = input_list[5];
	g_euser.gid      = tonumber(input_list[6]);
	g_euser.gpos     = tonumber(input_list[7]);
	g_euser.gname    = input_list[8];
	g_euser.level    = tonumber(input_list[9]);
	g_euser.exp      = tonumber(input_list[10]);
	g_euser.exp_next = tonumber(input_list[11]);
	g_euser.exp_this = tonumber(input_list[12]);

	util.save_rms('last_eid', g_euser.eid, 'string');
	if is_ver(VER_UCSDK) then
		uc_submit_data("RoleLog");
	end
	if is_ver(VER_LJSDK) then
		ljsdk_submit_data("enterServer");
	end

	if g_scene:is_stage(STAGE_LOGIN) then
		layer_login:save_info();
	end

	local cmd;
	if g_euser.st >= ST_ROOM then
		cmd = 'room';
	else
		-- send lcard , if return err, means did not pick hero
		cmd = 'lcard';
	end
	net_send(cmd);
	--net_send('lmerge');
	--net_send('lconstant');
	--net_send('course');
end

-- CMD room   -- list the room info 
-- room_id 0 means create room
-- CMD room [channel]  -- create a room in channel
-- CMD room [channel] [room_id] -- join a room with channel and room_id
-- create room with channel and room_id and password
-- CMD room [channel] [room_id] [passowrd] 
-- join room with channel and room_id and password
-- CMD room [channel] [room_id] [passowrd] 
-- RET room [channel] [room_id] [st] [password] [guest[0]_info] [guest[1]_info] ..
-- guset_info == [eid] [alias] [icon]
-- only CMD3 will broadcast
function net_room(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local channel = check;
	local room_id = tonumber(input_list[3]);
	local st = tonumber(input_list[4]);
	local pwd = input_list[5];
	local glist_num = 0;
	if nil ~= g_euser.room_data then
		local l = g_euser.room_data.guest_list or {};
		glist_num = #l;
	end
		
	local guest_list = {};
	local index = 6;
	while nil ~= input_list[index] do
		local l = {};
		l.eid = tonumber(input_list[index]);
		index = index + 1;
		l.alias = input_list[index];
		index = index + 1;
		l.icon = input_list[index];
		index = index + 1;
		table.insert(guest_list, l);
	end
	g_euser.room_data = {
		channel = channel,
		room_id = room_id,
		st = st,
		guest_list = guest_list,
	};

	--[[
	if g_scene:is_stage(STAGE_PVP) then
		layer_card:update_player_info(g_euser.room_data);
	end
	]]--

	if (g_scene:is_stage(STAGE_PVP) or g_scene:is_stage(STAGE_PVG)) and st >= g_euser.st then
		-- if a guest come in while battling, no need to do_greconn
		if st > g_euser.st then
			do_greconn();
			return;
		end
		if glist_num ~= #(g_euser.room_data.guest_list) then
			return;
		end
		if true ~= layer_result.is_done and st == ST_GAME then
			g_euser.st = st;
			layer_card:set_wait_result();
			return;
		end
		if nil ~= layer_result.layer and st == ST_GAME then -- start new game
			g_euser.st = st;
			local cmd = 'ginfo';
			net_send(cmd);
			return;
		end
	end
	g_euser.st = st;
	if ST_GAME == g_euser.st then
		local cmd = 'ginfo';
		net_send(cmd);
		return;
	end
	if not g_scene:is_stage(STAGE_MAP) then
		g_scene:map();
	end

	if nil == layer_room.layer then
		g_scene:add_layer(ZORDER_LAYER_ROOM, layer_room:create(channel, room_id, guest_list[1]));
	end
	if #guest_list > 1 then
		layer_room:insert_player(guest_list[#guest_list]);
		if guest_list[1].eid == g_euser.eid then
			layer_room:show_start();
		end
	end
end

-- CMD lmerge
-- RET lmerge AABBCC...(CARD_ARRAY_LIST*2 char)
-- list require
function net_lmerge(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local str = input_list[2];
	g_euser.merge_str = str;
end

-- CMD lconstant
-- RET lconstant key=value key=value ...
function net_lconstant(input_list, str, check)
	for i = 1, #input_list do
		local m = input_list[i];
		local ms = csplit(m, "=");
		local key = ms[1];
		local value = ms[2];
		g_constant[key] = value;
	end
end

function save_for_collection(input_list)
	local from_id = tonumber(input_list[3]);
	local cards = input_list[4];
	local num = 0;
	local len = string.len(cards);
	for i = 1, len do
		local t = string.sub(cards, i, i);
		t = tonumber(t);
		if nil ~= t and t > 0 then
			num = num + 1;
		end
	end
	g_euser.collection = num;
	if 0 < len then
		g_euser.collection_rate = num / len;
	else
		g_euser.collection_rate = 0;
	end
end

-- CMD lcard [in_total] [from_id]  -- array mode in_total = 400 , from_id = 1
--                                 -- from_id is optional, default = 1
-- CMD lcard                       -- load all cards
-- RET lcard [total] [from_id] 3056...98            -- array mode
-- RET lcard [total] [from_id = 0] 8 22 22 23 23 26 ... -- list mode
function net_lcard(input_list, str, check)
	save_for_collection(input_list);
	--if g_scene:is_stage(STAGE_LOGIN)  and -6 == check then
	if -6 == check then -- anysdk switch account to a new reg account, no lcard
		g_scene:role();
	elseif check < 0 then
		show_err(str);
	elseif g_scene:is_stage(STAGE_LOGIN) or g_scene:is_stage(STAGE_ROLE) then

		local total = check;
		local from_id = tonumber(input_list[3]);
		local cards = input_list[4];
		g_euser.all_str = cards;
		g_scene:map();
		net_send('lconstant');
		net_send('course');
		if g_euser.level > 5 then
			show_notice();
		end
	elseif g_scene:is_stage(STAGE_DECK) then
		local total = check;
		local from_id = tonumber(input_list[3]);
		local cards = input_list[4];
		g_euser.all_str = cards;
		g_euser.slot_str = c_get_slot_str(g_euser.deck_str, g_euser.all_str);
		local slot_array = c_str_array(g_euser.slot_str);	
		layer_deck:set_slot_cards(slot_array, 1);
		if g_tutor_wait_net == tutor_deck_2 then
			g_tutor_wait_net();
			util.set_tutor(TUTOR_DECK, true, true);
		end
	elseif g_scene:is_stage(STAGE_SHOP) then
		local total = check;
		local from_id = tonumber(input_list[3]);
		local cards = input_list[4];
		g_euser.all_str = cards;
	else
		g_scene:map();
	end
end

-- CMD sta 
-- RET sta [eid] [level] [rating] [gold] [crystal] [game_count]
--         [win] [lose] [draw] [run] [icon] [alias] [gid] [gpos] [gname]
--         [exp] [exp_next] [exp_this] [sex] [signature] [unread_msg_count]
--         [power] [power_last_refresh_time] [monthly_end_date] [solo_pos]
-- five minutes add one power
function net_sta(input_list, str, check)
	if check < 0 then
		show_err(str);
	else
		local eid = check;
		if eid ~= g_euser.eid then
			return;
		end
		g_euser.level      = tonumber(input_list[3]);
		g_euser.rating     = tonumber(input_list[4]);
		g_euser.gold       = tonumber(input_list[5]);
		g_euser.crystal    = tonumber(input_list[6]);
		g_euser.game_count = tonumber(input_list[7]);
		g_euser.win        = tonumber(input_list[8]);
		g_euser.lose       = tonumber(input_list[9]);
		g_euser.draw       = tonumber(input_list[10]);
		g_euser.run        = tonumber(input_list[11]);
		g_euser.icon       = input_list[12];
		g_euser.alias      = input_list[13];
		g_euser.gid        = tonumber(input_list[14]);
		g_euser.gpos       = tonumber(input_list[15]);
		g_euser.gname      = input_list[16];
		g_euser.exp        = tonumber(input_list[17]);
		g_euser.exp_next   = tonumber(input_list[18]);
		g_euser.exp_this   = tonumber(input_list[19]);
		g_euser.sex        = tonumber(input_list[20]);
		g_euser.signature  = input_list[21];
		g_euser.un_read_msg_count = tonumber(input_list[22]);
		g_euser.power      = tonumber(input_list[23]);
		g_euser.power_last_refresh_time = tonumber(input_list[24]);
		if #input_list >= 26 then
			g_euser.monthly_end_date = tonumber(input_list[25]);
			local t = os.date("*t", g_euser.monthly_end_date);
			local str = string.format("%d年%02d月%02d日 %02d时%02d分%02d秒", t.year, t.month, t.day, t.hour, t.min, t.sec);
			print('str: ', str);

			g_euser.solo_pos		= tonumber(input_list[26]);
		end

		layer_chat:show_vip(is_vip_member(g_euser));
		--local t = os.date("*t", g_euser.power_last_refresh_time);
		--local str = string.format("%d年%02d月%02d日 %02d时%02d分%02d秒", t.year, t.month, t.day, t.hour, t.min, t.sec);
		--print('str: ', str);
		--[[
		local str = '';
		for i = 21, #input_list do
			str = str .. input_list[i];
			if i < #input_list then
				str = str .. ' ';
			end
		end
		g_euser.signature = str;
		]]--

		if g_scene:is_stage(STAGE_MAP) then
			layer_infobar:update_info();
			layer_chat:update_info();
		end
		if g_scene:is_stage(STAGE_SHOP) then
			layer_infobar:update_info();
			layer_chat:update_info();
		end
	end
end

-- CMD wchat [msg]
-- 2 return;
-- RET 1  wchat 0  -- 0 means send success -- <0 means fail (only sender get)
-- RET 2  wchat [eid] [alias] [is_vip] [msg]
function net_wchat(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	-- check == 0 means ok
	if 0 == check then
		-- send success;
		return;
	end
	local eid = check;
	local alias = input_list[3];
	local is_vip = tonumber(input_list[4]);
	local msg = '';
	for i = 5, #input_list do
		msg = msg .. input_list[i] .. ' ';
	end
	local time = get_time();
	add_chat_msg(C_WORLD, eid, alias, msg, time, is_vip);

	--show_lamp(msg, 1);
end

-- CMD rchat [msg]
-- RET rchat [eid] [alias] [is_vip] [msg]
function net_rchat(input_list, str, check)
	if check <= 0 then
		show_err(str);
	else
		local eid = check;
		local alias = input_list[3];
		local is_vip = tonumber(input_list[4]);
		--local msg = input_list[4];
		local msg = '';
		for i = 5, #input_list do
			msg = msg .. input_list[i] .. ' ';
		end
		local time = get_time();
		--print('time: ', time);
		add_chat_msg(C_ROOM, eid, alias, msg, time, is_vip);
	end
end

-- CMD gchat [msg]
-- RET gchat [eid] [alias] [is_vip] [msg]
function net_gchat(input_list, str, check)
	if check <= 0 then
		show_err(str);
	else
		local eid = check;
		local alias = input_list[3];
		local is_vip = tonumber(input_list[4]);
		--local msg = input_list[4];
		local msg = '';
		for i = 5, #input_list do
			msg = msg .. input_list[i] .. ' ';
		end
		local time = get_time();
		--print('time: ', time);
		add_chat_msg(C_GUILD, eid, alias, msg, time, is_vip);
	end
end

-- CMD fchat [eid] [msg]
-- RET fchat [eid] [alias] [is_vip] [msg]
function net_fchat(input_list, str, check)
	if check <= 0 then
		show_err(str);
	else
		local eid = check;
		local alias = input_list[3];
		local is_vip = tonumber(input_list[4]);
		--local msg = input_list[4];
		local msg = '';
		for i = 5, #input_list do
			msg = msg .. input_list[i] .. ' ';
		end
		local time = get_time();
		--print('time: ', time);
		add_chat_msg(C_PRIVATE, eid, alias, msg, time, is_vip);
	end
end

function init_net_play()
	g_net_play_cache = {};
end
--init_net_play(); -- do in do_game
-- cmd index .....
function do_greconn()
	local last_index = #g_net_play_cache;
	local cmd = 'greconn ' .. last_index;
	net_send(cmd);
end
function check_miss_cmd(index, str, input_list)
	local cmd = g_net_play_cache[index];
	if true == LOCAL_CMD then
		if nil ~= cmd then
			if str == cmd then
				--print('========= has play local: ', str);
			elseif 'n' == input_list[2] then
				--print('========= has play local n : ', str);
				layer_card:handle_next_timeout(input_list[3]);
			else
				local cmd = 'ginfo';
				net_send(cmd);
			end
			return false;
		end
	end
	local last_index = #g_net_play_cache;
	if index < last_index + 1 then
		return false;
	end
	if index > last_index + 1 then
		do_greconn();
		return false;
	end
	-- when cmd to efflist get error, should remove it from g_net_play_cache
	-- @see in cmd_game_to_logic
	table.insert(g_net_play_cache, str);
	return true;
end

function str_cut_num(num, str)
	local len = string.len(num);
	len = len + 2; -- one space and start from next one character
	str = string.sub(str, len);
	return str;
end

function cut_cmd_num(input_list, str)
	local index = tonumber(input_list[1]);
	if nil == index then
		return nil;
	end
	if false == check_miss_cmd(index, str, input_list) then
		return nil;
	end
	str = str_cut_num(input_list[1], str);
	return str;
end
function net_play(input_list, str)
	str = cut_cmd_num(input_list, str); 	
	if nil == str then
		return;
	end
	table.remove(input_list, 1);
	local eff_list = nil; 
	local err = nil;
	if g_net_cmdsize > 0 then
		g_net_cmdsize = g_net_cmdsize - 1;
		table.insert(g_game_play_list, str);
		if 1 >= g_net_cmdsize then
			g_net_cmdsize = 0;
			layer_preload:start();
		end
		return;
	end
	if not g_scene:is_stage(STAGE_PVP) and not g_scene:is_stage(STAGE_PVG) then
		table.insert(g_game_play_list, str);
		return;
	end
	push_cmd_list(str, { refresh_layer_card }, nil);
end

function local_play(cmd)
	local total = #g_net_play_cache + 1;
	cmd = string.format("%d %s", total, cmd);
	local input_list = csplit(cmd, ' ');
	net_play(input_list, cmd);
end

function do_ai()
	local cmd = 'local_ai';
	play_game_cmd(cmd);
end

function cb_net_game()
	local side = g_game_info.side;
	local cmd_size = g_game_info.cmd_size;
	local seed = g_game_info.seed;
	local deck1_array = g_game_info.deck1_array;
	local deck2_array = g_game_info.deck2_array;
	local timeout = g_game_info.timeout;
	local game_type = g_game_info.game_type;
	local solo_data = g_game_info.solo_data;
	local robot_data = g_game_info.robot_data;
	g_scene:pvp(side, seed, deck1_array, deck2_array, timeout, solo_data, robot_data);
	if nil ~= g_euser.room_data then
		g_euser.room_data.game_type = game_type;
	end
	if cmd_size > 0 then
		if g_scene:is_stage(STAGE_PVP) then
			layer_card:hide_all_btn();
		end
		for i = 1, #g_game_play_list do
			local play_str = g_game_play_list[i];
			local eff_list = nil; 
			local err = nil;
			eff_list, err = cmd_game_to_logic(play_str, true);
		end
		g_game_play_list = {};
		data_handler:clean_ui_table();
		layer_card:init_cards();
		refresh_layer_card();
		layer_card:handle_next_timeout(timeout);
		layer_table:change_side(g_current_side);
		return;
	end
	if 0 < #g_game_play_list then
		for i = 1, #g_game_play_list do
			local str = g_game_play_list[i];
			push_cmd_list(str, { refresh_layer_card }, nil);
		end
		layer_card:handle_next_timeout(timeout);
		layer_table:change_side(g_current_side);
		return;
	end
	layer_card:handle_next_timeout(timeout);
	layer_table:change_side(g_current_side);
end

-- CMD game
-- RET game [side] [cmd_size] [seed] [timeout] [game_type] [deck_400_1] [deck_400_2]
-- where side = 1, 2 or 99, 1, 2 are players, 99 is wathcer
-- start_side = 1 or 2
function net_game(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	data_handler:cleanup();
	local side = check;
	local cmd_size = tonumber(input_list[3]);
	local seed = tonumber(input_list[4]);
	local timeout = tonumber(input_list[5]);
	local game_type = tonumber(input_list[6]);
	local deck1_array = input_list[7];
	local deck2_array = input_list[8];
	g_game_info = {
		side = side,
		cmd_size = cmd_size,
		seed = seed,
		deck1_array = deck1_array,
		deck2_array = deck2_array,
		timeout = timeout,
		game_type = game_type,
	};
	g_game_play_list = {};
	init_net_play();
	if cmd_size > 0 then
		g_scene:preload(cb_net_game, layer_preload.WAIT, STAGE_PVP);
		g_net_cmdsize = cmd_size + 1;
		return;
	end
	g_scene:preload(cb_net_game, layer_preload.START, STAGE_PVP);
end

function cb_net_gate()
	local side = g_game_info.side;
	local cmd_size = g_game_info.cmd_size;
	local seed = g_game_info.seed;
	local deck1_array = g_game_info.deck1_array;
	local gate_list = g_game_info.gate_list;
	local gate_id = g_game_info.gate_id;
	local gr = g_game_info.gr;
	g_scene:pvg(side, seed, deck1_array, gate_list, gr, gate_id);
	if cmd_size > 0 then
		if g_scene:is_stage(STAGE_PVG) then
			layer_card:hide_all_btn();
		end
		for i = 1, #g_game_play_list do
			local play_str = g_game_play_list[i];
			local eff_list = nil; 
			local err = nil;
			eff_list, err = cmd_game_to_logic(play_str, true);
		end
		g_game_play_list = {};
		data_handler:clean_ui_table();
		layer_card:init_cards();
		refresh_layer_card();
		layer_card:handle_next_timeout(timeout);
		layer_table:change_side(g_current_side);
		return;
	end
	if 0 < #g_game_play_list then
		for i = 1, #g_game_play_list do
			local str = g_game_play_list[i];
			push_cmd_list(str, { refresh_layer_card }, nil);
		end
		layer_card:handle_next_timeout(timeout);
		layer_table:change_side(g_current_side);
		return;
	end
	layer_card:handle_next_timeout(timeout);
	layer_table:change_side(g_current_side);
end

-- CMD gate gate_id
-- gate_id get in a gate game
-- RET gate [gate_id] [side] [cmd_size] [seed] [deck_400_1] [gate_count] [r1] [c1] .. [rn] [cn]
-- n == gate_count
-- where side = 1, 2 or 99, 1, 2 are players, 99 is wathcer
-- start_side = 1 or 2
function net_gate(input_list, str, check)
	if check < 0 then
		if -6 == check then
			str = "体力不足\n（体力每5分钟回复1点）";
		end
		if -99 == check then
			show_gate();
			return;
		end
		show_err(str);
		return;
	end
	local gate_id = check;
	local side = tonumber(input_list[3]);
	data_handler:cleanup();
	local cmd_size = tonumber(input_list[4]);
	local seed = tonumber(input_list[5]);
	local deck1_array = input_list[6];
	local gate_count = tonumber(input_list[7]);
	local gate_list = {};
	local index = 8;
	for i = 1, gate_count do
		local r = tonumber(input_list[index]);
		index = index + 1;
		local c = tonumber(input_list[index]);
		index = index + 1;
		gate_list[r] = gate_list[r] or {};
		table.insert(gate_list[r], c);
	end
	local gr = {}; -- round number to add ally
	for k, _ in pairs(gate_list) do
		local r = tonumber(k);
		if nil ~= r then
			table.insert(gr, k);
		end
	end
	table.sort(gr, function(a, b)
		return a < b;
	end);
	g_game_info = {
		side = side,
		cmd_size = cmd_size,
		seed = seed,
		deck1_array = deck1_array,
		gate_list = gate_list,
		gate_id = gate_id,
		gr = gr,
	};
	g_game_play_list = {};
	init_net_play();
	if cmd_size > 0 then
		g_scene:preload(cb_net_gate, layer_preload.WAIT, STAGE_PVG);
		g_net_cmdsize = cmd_size + 1;
		return;
	end
	g_scene:preload(cb_net_gate, layer_preload.START, STAGE_PVG);
end

-- CMD gate_msg gate_id
-- RET gate_msg gate_id size info1 ... infon
-- info: round card_id msg
function net_gate_msg(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local gate_id = check;
	local size = tonumber(input_list[3]);
	local list = {};
	local index = 4;
	for i = 1, size do
		local l = {};
		l.round = tonumber(input_list[index]);
		index = index + 1;
		l.card_id = tonumber(input_list[index]);
		index = index + 1;
		l.msg = input_list[index];
		index = index + 1;
		table.insert(list, l);
	end
	layer_table:add_gate_msg(list);
end

-- CMD lgate
-- RET lgate my_gate_pos total_size page_size info1 info2 ... infon
-- info = gate_id title gold crystal exp focus_card power
function net_lgate(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local my_gate_pos = check;
	local total_size = tonumber(input_list[3]);
	local start_id = tonumber(input_list[4]);
	local page_size = tonumber(input_list[5]);
	local list = {};
	local index = 6;
	local size = page_size;
	local is_full = false;
	for i = 1, size do
		local l = {};
		l.gate_id = tonumber(input_list[index]);
		index = index + 1;
		l.title = input_list[index];
		index = index + 1;
		l.gold = tonumber(input_list[index]);
		index = index + 1;
		l.crystal = tonumber(input_list[index]);
		index = index + 1;
		l.exp = tonumber(input_list[index]);
		index = index + 1;
		l.focus_card = tonumber(input_list[index]);
		index = index + 1;
		l.power = tonumber(input_list[index]);
		index = index + 1;
		if l.gate_id > my_gate_pos then
			is_full = true;
		else
			table.insert(list, l);
		end
	end
	layer_gate:add_list(list, start_id, total_size, is_full);
	if g_tutor_wait_net == show_tutor_do_gate then
		g_tutor_wait_net();
	end
end

-- CMD gift key_code
-- RET gift eid gold crystal card_count card_id_1 .. card_id_n
function net_gift(input_list, str, check)
	if check < 0 then
		if -6 == check then
			show_err("兑换码不存在");
		elseif -16 == check then
			show_err("兑换码已使用");
		elseif -26 == check then
			show_err("兑换码已过期");
		elseif -36 == check then
			show_err("兑换码无效");-- diffrent channel
		elseif -46 == check then
			show_err("该账号已经兑换过同类型的礼包");
		else
			show_err(str);
		end
		layer_code:clean_input();
		return;
	end
	if nil ~= layer_code.layer then
		layer_code:remove();
	end
	local eid = check;
	local gold_offset = tonumber(input_list[3]);
	local crystal_offset = tonumber(input_list[4]);
	g_euser.gold = g_euser.gold + gold_offset;
	g_euser.crystal = g_euser.crystal + crystal_offset;
	layer_infobar:update_info();
	local card_count = tonumber(input_list[5]);
	local index = 6;
	local list = {};
	for i = 1, card_count do
		local cid = tonumber(input_list[index]);
		local rc = g_card_list[cid];
		if nil == rc then
			rc = hero_list[cid];
		end
		local card = clone(rc);
		table.insert(list, card);
		index = index + 1;
	end
	g_scene:add_layer(ZORDER_LAYER_POPCLIST, layer_popclist:create(list));
	if 0 >= gold_offset and 0 >= crystal_offset then return; end
	local msg = '恭喜获得';
	if gold_offset > 0 then
		msg = msg .. string.format("\n[%d]金币", gold_offset);
	end
	if crystal_offset > 0 then
		msg = msg .. string.format("\n[%d]水晶", crystal_offset);
	end
	g_scene:add_layer(ZORDER_LAYER_MSG,layer_msg:create(msg,nil));
end

-- CMD fdata
-- RET fdata pve_time pve_gold_reward pve_gold_cost 
--           pvp_gold_time pvp_gold_reward pvp_gold_cost
--           pvp_crystal_time pvp_crystal_reward pvp_crystal_cost
--           pvp_free_reward pvp_free_lose
--           pve_free_reward pve_free_lose
--           pve_status pvp_gold_status pvp_crystal_status
--           pve_free_status pvp_free_status
--           pvp_gold_start_time pvp_gold_end_time
--           pvp_crystal_start_time pvp_crystal_end_time
-- status 1 open 2 close
function net_fdata(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local data = {};
	data.pve_time = check;
	data.pve_gold_reward = tonumber(input_list[3]);
	data.pve_gold_cost = tonumber(input_list[4]);
	data.pvp_gold_time = tonumber(input_list[5]);
	data.pvp_gold_reward = tonumber(input_list[6]);
	data.pvp_gold_cost = tonumber(input_list[7]);
	data.pvp_crystal_time = tonumber(input_list[8]);
	data.pvp_crystal_reward = tonumber(input_list[9]);
	data.pvp_crystal_cost = tonumber(input_list[10]);
	data.pvp_free_reward = tonumber(input_list[11]);
	data.pvp_free_lose = tonumber(input_list[12]);
	data.pve_free_reward = tonumber(input_list[13]);
	data.pve_free_lose = tonumber(input_list[14]);
	data.pve_status = tonumber(input_list[15]);
	data.pvp_gold_status = tonumber(input_list[16]);
	data.pvp_crystal_status = tonumber(input_list[17]);
	data.pve_free_status = tonumber(input_list[18]);
	data.pvp_free_status = tonumber(input_list[19]);
	data.pvp_gold_start_time = tonumber(input_list[20]);
	data.pvp_gold_end_time = tonumber(input_list[21]);
	data.pvp_crystal_start_time = tonumber(input_list[22]);
	data.pvp_crystal_end_time = tonumber(input_list[23]);
	if nil ~= layer_service.layer then
		layer_service:add_info(data);
	end
end

-- CMD fight game_type
-- if game_type == GAME_SOLO_GOLD or GAME_SOLO_FREE
-- RET room ...
-- if game_type == GAME_VS_GOLD or GAME_VS_CRYSTAL or GAME_VS_FREE
function net_fight(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
end

function net_cancel(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if 0 == check then
		layer_quick:stop_waiting();
	end
end

function reset_win_data()
	g_net_win_data = nil;
end

function get_winner_name(wside)
	local data = g_euser.room_data;
	local list = data.guest_list;
	local name = nil;
	local info = list[wside];
	if nil == info then
		return name;
	end
	name = info.alias;
	return name;
end

function show_layer_result(win_tag, info)
	local layer, name = layer_result:create(win_tag, info);
	g_scene:add_layer(ZORDER_LAYER_RESULT, layer, name);
end

function callback_net_win()
	local wside = g_net_win_data.wside;
	local wtype = g_net_win_data.wtype;
	local offset_rating = g_net_win_data.rating; 
	local offset_gold = g_net_win_data.gold; 
	local offset_exp = g_net_win_data.exp;
	local offset_crystal = g_net_win_data.crystal;
	local level = g_net_win_data.level;
	local exp_next = g_net_win_data.exp_next;
	-- for replay
	local is_replay = g_net_win_data.is_replay;
	--
	if true == is_replay then
		local name = g_net_win_data.name;
		g_net_win_data.winnername = name;
	else
		g_net_win_data.winnername = get_winner_name(g_net_win_data.wside);
	end
	local flag;
	if true == is_replay then
		flag = layer_result.TAG_GUEST;
	elseif SIDE_GUEST == g_euser.side then
		flag = layer_result.TAG_GUEST;
	elseif wside == g_euser.side then
		flag = layer_result.TAG_WIN;
	elseif 9 == wside then
		flag = layer_result.TAG_DRAW;
	else
		flag = layer_result.TAG_LOSE;
	end
	show_layer_result(flag, g_net_win_data);
	reset_win_data();
end

-- CMD fold
-- RET win win_side win_type rating gold exp level next_exp player_exp card_id
-- exp is offset
-- for win_side 1 or 2 win_type 1(surrender) or 0(normal)
-- win_side == 9 means draw
-- card_id > 0 ---> has prize card
function net_win(input_list, str, check)
	if check < 0 then
		if -8 == check then
			callback_reconn();
			return;
		end
		show_err(str);
		return;
	end
	g_net_win_data = {}; -- also reset to nil in data_handler.cleanup
	g_net_win_data.wside = check;
	g_net_win_data.wtype = tonumber(input_list[3]);
	g_net_win_data.rating = tonumber(input_list[4]); -- offset
	g_net_win_data.gold = tonumber(input_list[5]); -- offset
	g_net_win_data.exp = tonumber(input_list[6]); -- offset
	-- add offset_exp to g_euser.exp in layer_result show_level_up
	g_net_win_data.level = tonumber(input_list[7]); 
	g_net_win_data.exp_next = tonumber(input_list[8]);
	g_net_win_data.exp_player = tonumber(input_list[9]); -- exp after add
	g_net_win_data.card_id = tonumber(input_list[10]);
	g_net_win_data.crystal = tonumber(input_list[11]);
	check_cmd_finish();
end

-- CMD fold
function net_fold(input_list, str, check)
	if check < 0 then
		if -8 == check then
			callback_reconn();
			return;
		end
		show_err(str);
	else
	end
end

function dl_res_pic(filename)
    local flag = util.check_file(filename);
	if false == flag then
		return;
	end   
	local list = {}; 
	local fullpath = util.get_fullpath(F_RES, filename); 
	local file = io.open(fullpath, "r"); 
	if nil ~= file then
		local data = file:read("*all");
		local lines = csplit(data, "[\n\r]");
		for i = 1, #lines do
			--print('line: ', i, lines[i]);
			table.insert(list, lines[i]);
		end   
		io.close(file);
	end   

	for i = 1, #list do
		local fname = list[i];
		local is_exist = util.check_file(fname);
		--print('fname, exist: ', fname, is_exist);
		if true ~= is_exist then
			--print('card is_exist: ', i, is_exist);
			send_dres(fname);
		end   
	end   
end

function send_dres(filename)
	if nil == filename then return; end
	LayerSocket:dlRes(filename);
end

function net_dres(input_list, str, check)
	if check < 0 then
		--show_err(str);
		return;
	end
	local filename = input_list[3];
	if 'cardlist.log' == filename then
		dl_res_pic(filename);
	end
	-- in Android, fopen cannot read file in resource because resource is in apk
	-- so must unzip the apk first
	--local fullpath = util.get_fullpath(F_PIC, 'card0.png');
	--local md5 = MD5Checksum:GetMD5(fullpath);
	--print('fullpath, md5: ', fullpath, md5);
	-- done
end

-- CMD lai
-- RET lai total [ai_info1] [ai_info2] ...
-- ai_info: eid, alias, icon, rating, exp, gold, present_card, level
function net_lai(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if nil == layer_solo.layer then return; end
	local total = check;
	local list_ai = {};
	local index = 3;
	for i = 1, total do
		local list = {};
		list.eid = tonumber(input_list[index]);
		index = index + 1;
		list.alias = input_list[index];
		index = index + 1;
		list.icon = input_list[index];
		index = index + 1;
		list.rating = tonumber(input_list[index]);
		index = index + 1;
		list.exp = tonumber(input_list[index]);
		index = index + 1;
		list.gold = tonumber(input_list[index]);
		index = index + 1;
		list.present_card = input_list[index];
		index = index + 1;
		list.level = tonumber(input_list[index]);
		index = index + 1;
		table.insert(list_ai, list);
	end
	layer_solo:add_list(list_ai);
	--util.trigger_tutor(TUTOR_SOLO);
	--util.upload_tutor();
end

-- CMD ldeck                  -- load all cards
-- RET ldeck [slot_id] [slot_name] [deck400] -- array mode
function net_ldeck(input_list, str, check)
	if check < 0 then
		show_err(str);
	else
		local slot_id = check;
		local slot_name = input_list[3];
		local cards = input_list[4];
		g_euser.deck_str = cards;
		if g_scene:is_stage(STAGE_DECK) then
			--layer_deck.deck_sid = slot_id;
			local deck_array = c_str_array(cards);	
			layer_deck:set_deck_cards(deck_array, 1);
			layer_deck:change_to_slot(nil, slot_id, slot_name);
		end
	end
end

-- CMD slotlist
-- RET slotlist [count] [slot_info1] [slot_info2] [slot_info3] ... 
-- [slot_info] = [slot_id] [slot_name]
function net_slotlist(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local count = check;
	local index = 3;
	local list = {};
	for i = 1, count do
		local l = {};
		l.tag = tonumber(input_list[index]);
		index = index + 1;
		l.title = input_list[index];
		index = index + 1;
		table.insert(list, l);
	end
	if g_scene:is_stage(STAGE_DECK) then
		layer_deck:set_slot_list(list);
	end
end

-- CMD lslot id
-- RET lslot [slot_id] [slot_name] [deck400]
function net_lslot(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local slot_id = check;
	local slot_name = input_list[3];
	local cards = input_list[4];
	local slot_array = c_str_array(cards);	
	if g_scene:is_stage(STAGE_DECK) then
		layer_deck:change_to_slot(slot_array, slot_id, slot_name);
	end
end

-- CMD rslot slot_id slot_name
-- RET rslot [slot_id] [slot_name]
function net_rslot(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	--[[
	local eid = check;
	local sid = tonumber(input_list[3]);
	local name = input_list[4];
	]]--
end

-- CMD bslot flag id
--     flag: ==0 get slot price; ==1 buy slot by gold; ==2 buy slot by crystal
--    if flag==0:
-- RET bslot [flag] [id] [gold] [crystal]
--    if flag == 1 or 2:
-- RET bslot [flag] [id] [gold] [crystal]
function net_bslot(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local flag = check;
	local sid = tonumber(input_list[3]);
	local gold = tonumber(input_list[4]);
	local crystal = tonumber(input_list[5]);
	if 0 == flag then
		if g_scene:is_stage(STAGE_DECK) then
			layer_deck:set_buy_slot_btn(sid, gold, crystal);
		end
		return;
	end
	if 1 == flag or 2 == flag then
		if g_scene:is_stage(STAGE_DECK) then
			show_msg('购买成功');
			if nil ~= layer_pick.layer then
				layer_pick:remove();
			end
			layer_deck:pick_deck();
		end
		return;
	end
end

-- CMD reg [username] [password] [platform] [channel] 
-- platform/channel is optional
-- RET reg [eid] [alias]
function net_reg(input_list, str, check)
	if check <= 0 then -- eid cannot be 0
		g_euser.username = '';
		show_err(str);
	else
		g_euser.eid = check;
		g_euser.alias = input_list[3];
		g_euser.level      = tonumber(input_list[4]);
		g_euser.exp        = tonumber(input_list[5]);
		g_euser.exp_next   = tonumber(input_list[6]);
		g_euser.exp_this   = tonumber(input_list[7]);
		g_euser.st = ST_NULL;
		-- send lcard , if return err, means did not pick hero
		if is_ver(VER_UCSDK) then
			uc_submit_data("RoleReg");
		end
		if is_ver(VER_LJSDK) then
			ljsdk_submit_data("createRole");
		end
		local cmd = 'lcard';
		net_send(cmd);
	end
end

-- CMD alias [alias]
-- RET alias 0 [alias] -- 0 means success
-- -16 alias:already_set
function net_alias(input_list, str, check)
	if check < 0 then 
		if -16 ~= check then
			g_euser.alias = '';
			show_err(str);
			return;
		end
	else
		g_euser.alias = input_list[3];
	end
	if g_scene:is_stage(STAGE_ROLE) then
		layer_role:pick_level();
	end
end

-- CMD ralias [type]
-- type: 0 for male, 1 for female
-- RET ralias [type] [alias]
function net_ralias(input_list, str, check)
	if check < 0 then 
		return;
	end
	if g_scene:is_stage(STAGE_ROLE) then
		local alias = input_list[3];
		layer_role:get_new_alias(alias);
	end
end

-- CMD job [hero_id] [level] -- 1 ~ 5 default 1
-- RET job [hero_id] [level]
function net_job(input_list, str, check)
	if check < 0 then
		show_err(str);
	else
		g_euser.hero_id = check;
		g_euser.game_level = tonumber(input_list[3]);

		local cmd = 'lcard';
		net_send(cmd);

		if is_ver(VER_LJSDK) then
			ljsdk_submit_data("createRole");
		end
	end
end

-- CMD ljob
-- RET ljob total hero_id1 hero_id2 ...
function net_ljob(input_list, str, check)
	if check < 0 then
		show_err(str);
	else
		local total = check;
		local list = {};
		local index = 3;
		for i = 1, total do
			local hid = tonumber(input_list[index]);
			index = index + 1;
			table.insert(list, hid);
		end
		if g_scene:is_stage(STAGE_ROLE) then
			layer_role:init_list(list);
		end
	end
end

-- CMD sprofile [icon] [sex] [signature]
-- RET sprofile [eid] [icon] [sex] [signature] 
function net_sprofile(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local eid = check;
	if eid ~= g_euser.eid then
		return;
	end
	g_euser.icon = input_list[3];
	g_euser.sex = tonumber(input_list[4]);
	local str = '';
	for i = 5, #input_list do
		str = str .. input_list[i];
		if i ~= #input_list then
			str = str .. ' ';
		end
	end
	g_euser.signature = str;
	if nil == layer_info.layer then
		return;
	end
	g_scene:add_layer(ZORDER_LAYER_INFO, layer_info:create(g_euser));
end

-- CMD lreplay 
-- RET lreplay [eid] [total] [replay_info1] [replay_info2] .. 
-- replay_info: gameid, winner, version, eid1, eid2, lv1, lv2, icon1, icon2, alias1, alias2
function net_lreplay(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local eid = check;
	local total = tonumber(input_list[3]);
	local list_replay = {}
	local index = 4;
	for i = 1, total do
		local l = {};
		l.gameid = input_list[index];
		index = index + 1;
		local winner = tonumber(input_list[index]);
		index = index + 1;
		l.version = input_list[index];
		index = index + 1;
		local eid1 = tonumber(input_list[index]);
		index = index + 1;
		local eid2 = tonumber(input_list[index]);
		index = index + 1;
		local lv1 = tonumber(input_list[index]);
		index = index + 1;
		local lv2 = tonumber(input_list[index]);
		index = index + 1;
		local icon1 = input_list[index];
		index = index + 1;
		local icon2 = input_list[index];
		index = index + 1;
		local alias1 = input_list[index];
		index = index + 1;
		local alias2 = input_list[index];
		index = index + 1;
		local einfo = nil;
		if eid1 ~= eid then
			einfo = { eid = eid1, icon = icon1, alias = alias1, lv = lv1 };	
		else
			einfo = { eid = eid2, icon = icon2, alias = alias2, lv = lv2 };	
		end
		l.einfo = einfo;
		local is_win = false;
		if (1 == winner and eid1 == eid) or 
		   (2 == winner and eid2 == eid) then
			is_win = true;
		end
		l.is_win = is_win;
		table.insert(list_replay, l);
	end
	if nil ~= layer_info.layer then
		g_scene:add_layer(ZORDER_LAYER_VIDEO,layer_video:create(eid,list_replay));
	end
end

-- CMD replay gameid
-- RET replay [code] [gameid] [winner] [seed] [start_side] [ver] [eid1] [eid2]
--            [lv1] [lv2] [icon1] [icon2] [alias1] [alias2] [deck1] [deck2] [cmd]
function net_replay(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local gameid = input_list[3];
	local winner = tonumber(input_list[4]);
	local seed = tonumber(input_list[5]);
	local start_side = tonumber(input_list[6]);
	local ver = tonumber(input_list[7]);
	local eid1 = tonumber(input_list[8]);
	local eid2 = tonumber(input_list[9]);
	local lv1 = tonumber(input_list[10]);
	local lv2 = tonumber(input_list[11]);
	local icon1 = input_list[12];
	local icon2 = input_list[13];
	local alias1 = input_list[14];
	local alias2 = input_list[15];
	local deck1 = input_list[16];
	local deck2 = input_list[17];
	local temp = '';
	for i = 1, 17 do
		temp = temp .. input_list[i] .. ' ';
	end
	local spos = string.len(temp) + 1;
	str = string.sub(str, spos);
	local myside = SIDE_GUEST;
	if eid1 == g_euser.eid then
		myside = 1;
	elseif eid2 == g_euser.eid then
		myside = 2;
	end
	g_euser.room_data = {
		guest_list = {
			{ eid = eid1, alias = alias1, icon = 0, },
			{ eid = eid2, alias = alias2, icon = 0, },
		},
	};

	if true == DEBUG_MODE then
		-- set stage here is for set all hand card to front in init
		-- see in add_ui_card, when hand card init in layer_card
		g_scene.this_stage = STAGE_REPLAY;
		------------
	end
	g_scene:replay(myside, seed, deck1, deck2);
	local list_cmd = csplit(str, ';');
	for i = 1, #(list_cmd or {}) do
		local cmd = list_cmd[i];
		local ilist = csplit(cmd, ' ');
		if 'fold' ~= ilist[2] and '@win' ~= ilist[2] then
			local len = string.len(ilist[1]);
			len = len + 2; -- one space and start from next one character
			cmd = string.sub(cmd, len);
			local eff_list = nil;
			local err = nil;
			push_cmd_list(cmd, { refresh_layer_card }, nil);
		end
	end
	local name;
	if 1 == winner then
		name = alias1;
	else
		name = alias2;
	end
	g_net_win_data = { name = name, is_replay = true };
	check_cmd_finish();
end

-- CMD sdeck [slot_id] [deck400]
-- RET sdeck [slot_id]
function net_sdeck(input_list, str, check)
	if check < 0 then
		show_err(str);
		if g_scene:is_stage(STAGE_DECK) then
			if true == layer_deck.is_should_quit then
				layer_deck.is_should_quit = false;
			end
		end
		return;
	end
	show_msg(t_lang("SAVE_SUCCESS"));
	-- check == 0 means ok
	if g_scene:is_stage(STAGE_DECK) then
		if true == layer_deck.is_should_quit then
			layer_deck.callback_return(0);
			return;
		end
		g_scene:deck();
	end
end

-- CMD quick 9(optional)
-- RET quick flag
-- flag : 0 ok
--        9 cancel quick ok
function net_quick(input_list, str, check)
	if check < 0 then
		show_err(str);
	else
		if 0 == check then
			--layer_quick:start_waiting();
		elseif 9 == check then
			layer_quick:stop_waiting();
		end
	end
end

-- CMD leave
-- RET leave [eid] [st]
-- for leaver , st == ST_LOGIN
-- for other  , st is the room.state, client should double check it
function net_leave(input_list, str, check)
	if check < 0 then
		show_err(str);
	else
		reset_win_data();
		local eid = check;
		local st = tonumber(input_list[3]);
		if eid == g_euser.eid then
			g_euser.st = st;
		else
			if nil ~= layer_room.layer then
				layer_room:hide_start(eid);
			end
			if nil ~= g_euser.room_data then
				local l = g_euser.room_data.guest_list or {};
				for i = 1, #l do
					local info = l[i];
					if eid == info.eid then
						table.remove(l, i);
						break;
					end
				end
			end
			
			return;
		end
		if not g_scene:is_stage(STAGE_MAP) then
			g_scene:map();
		end
	end
end

-- CMD lchan
-- RET lchan [channel[0].info] [channel[1].info] ...
-- where channel[x].info = channel_id, channel_title
function net_lchan(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if not g_scene:is_stage(STAGE_MAP) then return; end
	if nil == layer_lroom.layer then return; end
	local list = {};
	local index = 2;
	while nil ~= input_list[index] do
		local cid = input_list[index];
		local ctitle = input_list[index+1];
		local l = { id = cid, title = ctitle };
		table.insert(list, l);
		index = index + 2;
	end
	for i = 1, #list do
		local info = list[i];
		if '2' == info.id then
			table.remove(list, 3);
			table.insert(list, 1, info);
			break;
		end
	end
	layer_lroom:set_list_channel(list);
end

-- CMD lroom [channel] 
-- RET lrrom [channel] [room[0].info] [room[1].info] ...
-- where room[x].info = room_id, num_guest, pwd_flag, room_title
-- pwd_flag 0==no password, 1==has password
function net_lroom(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if nil == layer_lroom.layer then return; end
	local channel = check;
	local list = {};
	local index = 3;
	while nil ~= input_list[index] do
		local l = {};
		l.id = input_list[index];
		index = index + 1;
		l.num_guest = tonumber(input_list[index]);
		index = index + 1;
		l.pwd_flag = tonumber(input_list[index]);
		index = index + 1;
		l.title = input_list[index];
		index = index + 1;
		l.channel = channel;
		table.insert(list, l);
	end
	layer_lroom:refresh_list(channel, list);
end

function shop_list_check_exist(id)
	local list = g_list_shop or {};
	for i = 1, #list do
		local info = list[i];
		local cid = info.cid;
		if cid == id then
			return true;
		end
	end
	return false;
end
-- CMD shop [card_id] [size]
-- RET shop [count] loop( [card_id] [card_buy_gold] [card_sell_gold] [card_buy_crystal] [card_sell_crystal] [piece_buy_gold] [piece_sell_gold] [piece_buy_crystal] [piece_sell_crystal]  )
-- RET shop [err_code] [err_msg]
function net_shop(input_list, str, check)
	if check < 0 then
		show_err(str);
	else
		local count = check;
		local list = {};
		local last_id = -1;
		local index = 3;
		for i = 1, count do
			local l = {};
			l.cid = tonumber(input_list[index]);
			if i == count then
				last_id = l.cid;
			end
			index = index + 1;
			l.c_buygold = tonumber(input_list[index]);
			index = index + 1;
			l.c_sellgold = tonumber(input_list[index]);
			index = index + 1;
			l.c_buycrystal = tonumber(input_list[index]);
			index = index + 1;
			l.c_sellcrystal = tonumber(input_list[index]);
			index = index + 1;
			l.p_buygold = tonumber(input_list[index]);
			index = index + 1;
			l.p_sellgold = tonumber(input_list[index]);
			index = index + 1;
			l.p_buycrystal = tonumber(input_list[index]);
			index = index + 1;
			l.p_sellcrystal = tonumber(input_list[index]);
			index = index + 1;
			l.card = clone_card_by_id(l.cid);
			if nil ~= l.card then
				if true ~= SHOP_PAGE then
					if false == shop_list_check_exist(l.cid) then
						table.insert(list, l);
					end
				else
					table.insert(list, l);
				end
			end
		end
		for i = 1, #list do
			table.insert(g_list_shop, list[i]);
		end
		for i = 1, #g_list_shop do
			local d1 = g_list_shop[i];
			if d1.card.id > 20 then
				local c1 = d1.card.cost;
				for j = 1, i do
					local d2 = g_list_shop[j];
					if d2.card.id > 20 then
						local c2 = d2.card.cost;
						if c1 <= c2 then
							table.remove(g_list_shop, i);
							table.insert(g_list_shop, j, d1);
							break;
						end
					end
				end
			end
		end
		if true ~= SHOP_PAGE then
			g_list_shop.last_id = g_list_shop.last_id - 1;
			if 0 == count and 0 >= g_list_shop.last_id then
				if g_scene:is_stage(STAGE_SHOP) then
					--print(' shop list size: ', #g_list_shop);
					layer_shop:add_to_list(g_list_shop);
				elseif g_scene:is_stage(STAGE_DECK) and nil~=layer_book.layer then
					layer_book:add_to_list(g_list_shop);
				end
			end
		else
			if g_scene:is_stage(STAGE_SHOP) then
				layer_shop:add_to_list(list, last_id);
			end
		end
	end
end

-- card_type: 0 card, 1 piece
-- CMD buy [card_id] [card_type] [money_type] [buy_count]
-- RET buy [eid] [card_id] [card_type] [money_type] [buy_count] [gold_offset] [crystal_offset]
-- RET buy [err_code] [err_msg]
-- fyi: money_type 0--gold 1--crystal
function net_buy(input_list, str, check)
	if check < 0 then
		show_err(str);
	else
		local eid = check;
		local card_id = tonumber(input_list[3]);
		local card_type = tonumber(input_list[4]);
		local money_type = tonumber(input_list[5]);
		local buy_count = tonumber(input_list[6]);
		local gold_offset = tonumber(input_list[7]);
		local crystal_offset = tonumber(input_list[8]);
		g_euser.gold = g_euser.gold + gold_offset;
		g_euser.crystal = g_euser.crystal + crystal_offset;
		if g_scene:is_stage(STAGE_SHOP) then
			net_send('lcard');
			layer_infobar:update_info();
			layer_shop:update_my_cards(card_id, buy_count);
			layer_shoppop:update_count();
		end
		show_msg('买入成功');
	end
end

-- CMD sell [card_id] [card_type] [money_type] [sell_count]
-- RET sell [eid] [card_id] [card_type] [money_type] [sell_count] [gold_offset] [crystal_offset]
-- RET sell [err_code] [err_msg]
-- fyi: money_type 0--gold 1--crystal
function net_sell(input_list, str, check)
	if check < 0 then
		show_err(str);
	else
		local eid = check;
		local card_id = tonumber(input_list[3]);
		local card_type = tonumber(input_list[4]);
		local money_type = tonumber(input_list[5]);
		local sell_count = tonumber(input_list[6]);
		local gold_offset = tonumber(input_list[7]);
		local crystal_offset = tonumber(input_list[8]);
		g_euser.gold = g_euser.gold + gold_offset;
		g_euser.crystal = g_euser.crystal + crystal_offset;
		if g_scene:is_stage(STAGE_SHOP) then
			net_send('lcard');
			layer_infobar:update_info();
			layer_shop:update_my_cards(card_id, -sell_count);
			layer_shoppop:update_count();
		end
		show_msg('卖出成功');
	end
end

-- CMD ladder ladder_type
-- RET ladder ladder_type total [info1] [info2] ...
-- info:
--    LADDER_RATING  --> [eid] [rank] [rating] [alias] [icon]
--    LADDER_LEVEL   --> [eid] [rank] [level]  [alias] [icon]
--    LADDER_GUILD   --> [gid] [rank] [level]  [gname] [icon]
--    LADDER_COLLECT --> [eid] [rank] [count]  [gname] [icon]
--    LADDER_GOLD    --> [eid] [rank] [gold]   [gname] [icon]
-- last info is self info, e.g: total 11, so 11 is mine, check eid
function net_ladder(input_list, str, check)
	if check < 0 then
		show_err(str);
		if g_scene:is_stage(STAGE_RANK) then
			layer_rank:set_list({});
		end
		return;
	end
	local ladder_type = check;
	local list_ladder = {};
	local total = tonumber(input_list[3]);
	local index = 4;
	for i = 1, total do
		local info = {};
		table.insert(info, tonumber(input_list[index])); -- eid or gid
		info.info_id = tonumber(input_list[index]); -- eid or gid
		index = index + 1;
		info.rank = tonumber(input_list[index]); -- rank
		index = index + 1;
		info.point = tonumber(input_list[index]); --rating,level,count,gold
		index = index + 1;
		info.name = input_list[index]; -- alias or gname
		index = index + 1;
		info.icon = input_list[index]; -- icon
		index = index + 1;
		info.ladder_type = ladder_type;
		table.insert(list_ladder, info);
	end
	if g_scene:is_stage(STAGE_RANK) then
		layer_rank:set_list(list_ladder);
	end
end

-- CMD notice type
-- if 0 == type
-- RET notice type count title1 title2 title3 ...
-- if 0 < type
-- RET notice type title
function net_notice(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if nil == layer_notice.layer then return; end
	if 0 == check then
		local count = tonumber(input_list[3]);
		local list = {};
		local index = 4;
		for i = 1, count do
			local title = input_list[index];
			if not is_ver(VER_UCSDK) or string.find(title, "Q群") == nil then
				table.insert(list, { t = i, title = title });
			end
			index = index + 1;
		end
		layer_notice:add_list(list);
		return;
	end
	-- 0 < check
	local detail = '';
	for i = 3, #input_list do
		detail = detail .. input_list[i];
		if i ~= #input_list then
			detail = detail .. ' ';
		end
	end
	--print(string.format("\nbefore[\n%s\n]", detail));
	detail = string.gsub(detail, "(^)", '\n');
	--print(string.format("\nafter[\n%s\n]", detail));
	layer_notice:set_detail(check, detail);
end

-- CMD flist start_num page_size
-- RET flist eid total [friend_info1] [friend_info2] ...
-- friend_info: eid is_online alias icon
-- is_online: 0==offline  1==online
function net_flist(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if nil == layer_friend.layer then return; end
	local teid = check;
	if teid ~= g_euser.eid then return; end
	local list = {};
	local total = tonumber(input_list[3]);
	local start_num = tonumber(input_list[4]);
	local num_row = tonumber(input_list[5]);
	local index = 6;
	for i = 1, num_row do
		local l = {};
		l.eid = tonumber(input_list[index]);
		index = index + 1;
		l.is_online = tonumber(input_list[index]);
		index = index + 1;
		l.alias = input_list[index];
		index = index + 1;
		l.icon = input_list[index];
		index = index + 1;
		if 1 == l.is_online then
			table.insert(list, 1, l);
		else
			table.insert(list, l);
		end
	end
	layer_friend:add_list(list, 1, total, start_num);
end

-- CMD fsta eid
-- RET fsta eid alias lv rating gold crystal gid gpos count win lose draw run
--          icon exp sex friend_flag signature
-- friend_flag --> 0 not friend, 1 is friend
function net_fsta(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local info = {};
	info.eid = check;
	info.alias = input_list[3];
	info.lv = tonumber(input_list[4]);
	info.rating = tonumber(input_list[5]);
	info.gold = tonumber(input_list[6]);
	info.crystal = tonumber(input_list[7]);
	info.gid = tonumber(input_list[8]);
	info.gpos = tonumber(input_list[9]);
	info.gname = input_list[10];
	info.game_count = tonumber(input_list[11]);
	info.win = tonumber(input_list[12]);
	info.lose = tonumber(input_list[13]);
	info.draw = tonumber(input_list[14]);
	info.run = tonumber(input_list[15]);
	info.icon = input_list[16];
	info.exp = tonumber(input_list[17]);
	info.exp_next = tonumber(input_list[18]);
	info.exp_this = tonumber(input_list[19]);
	info.sex = tonumber(input_list[20]);
	info.is_frd = tonumber(input_list[21]);
	info.signature = input_list[22];

	g_scene:add_layer(ZORDER_LAYER_INFO, layer_info:create(info));
end

-- CMD fsearch alias
-- RET fsearch total info1 info2 ...
-- info: eid, alias, icon, lv
function net_fsearch(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local total = check;
	local index = 3;
	local list = {};
	for i = 1, total do
		local l = {};
		l.eid = tonumber(input_list[index]);
		index = index + 1;
		l.alias = input_list[index];
		index = index + 1;
		l.icon = input_list[index];
		index = index + 1;
		l.level = tonumber(input_list[index]);
		index = index + 1;
		table.insert(list, l);
	end
	layer_findfrd:remove();
	layer_friend:remove();
	local layer, name = layer_friend:create();
	g_scene:add_layer(ZORDER_LAYER_FRIEND, layer, name, true);
	layer_friend:add_list(list, 2);
end

-- CMD fadd friend_eid
-- RET fadd my_eid friend_eid
function net_fadd(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local eid = check;
	--local feid = tonumber(input_list[
	if eid == g_euser.eid then
		show_msg('添加成功');
		if nil ~= layer_friend.layer then
			layer_friend:remove();
			get_friend_list();
		end
		if nil ~= layer_chatpop.layer then
			layer_chatpop:remove();
		end
		return;
	end
end

-- CMD fdel friend_eid
-- RET fdel my_eid friend_eid
function net_fdel(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local eid = check;
	--local feid = tonumber(input_list[
	if eid ~= g_euser.eid then
		return;
	end
	show_msg('删除成功');
	if nil ~= layer_friend.layer then
		layer_friend:remove();
		get_friend_list();
	end
end

-- CMD course
-- RET course eid course
function net_course(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local eid = check;
	if eid ~= g_euser.eid then
		return;
	end
	set_value_for_g_tutor(input_list[3]);
	g_tutor_change = nil;
	--[[
	if true == util.trigger_tutor(TUTOR_STORY) then
		return;
	end
	]]--

	if nil == layer_dragstory.layer and 5 == g_euser.level then
		local flag = util.trigger_tutor(TUTOR_PAY_AD);
		if true == flag then
			local btn = layer_chat.btn_mission;
			if nil ~= btn then
				local finger = btn:getChildByTag(TAG_MISSION_FINGER);
				if nil ~= finger then
					finger:removeFromParent(true);
				end
			end
		end
	end
end

-- CMD scourse
-- RET scourse eid course
function net_scourse(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local eid = check;
	if eid ~= g_euser.eid then
		return;
	end
	set_value_for_g_tutor(input_list[3]);
	g_tutor_change = nil;
		
end

-- CMD lpay pay_type
-- RET lpay pay_type count pay_info
-- pay_info = [pay_code] [pay_price] [money_type] [money] [title] [description]
-- pay_price: double, real rmb
-- pay_type 1:支付宝 2:快钱 3:app store 4:allinpay 6:anysdk 7:ucsdk
-- money_type 0:gold 1:crystal
function net_lpay(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if nil == layer_pay.layer then return; end
	local pay_type = check;
	local count = tonumber(input_list[3]) or 0;
	local list = {};
	index = 4;
	for i = 1, count do
		local l = {};
		l.pay_code = tonumber(input_list[index]) or 0;
		index = index + 1;
		l.pay_price = tonumber(input_list[index]) or 0;
		index = index + 1;
		l.money_type = tonumber(input_list[index]) or 0;
		index = index + 1;
		l.money = tonumber(input_list[index]) or 0;
		index = index + 1;
		l.title = input_list[index];
		index = index + 1;
		l.description = input_list[index];
		index = index + 1;
		if l.pay_price >= 600 or true == DEBUG_MODE then
			table.insert(list, l);
		end
	end
	layer_pay:add_list(pay_type, list);
	util.trigger_tutor(TUTOR_PAY);
end

-- RET @pay order_no player_id game_money_type game_money channel price
-- game_money_type 0 gold 1 crystal
-- channel 1:支付宝 2:快钱 3:app store 4:allinpay
function net_atpay(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local order_no = input_list[2];
	local player_id = input_list[3];
	local game_money_type = input_list[4];
	local game_money = input_list[5];
	local channel = input_list[6];
	local price = input_list[7];
	local nn = tonumber(game_money_type)==1 and '水晶' or '金币';
	local tip = string.format("充值 %d %s成功", tonumber(game_money), nn);
	local size = cc.size(wfix(505), hfix(302));--realsize
	if #input_list >= 10 then
		local extra_gold = tonumber(input_list[8]);
		local extra_crystal = tonumber(input_list[9]);
		local monthly_end_date = tonumber(input_list[10]);
		if g_euser.monthly_end_date < monthly_end_date then
			local end_time = os.date("*t", monthly_end_date);
			tip = tip .. string.format("\n获得至 %d 年 %d 月 %d 日的月卡特权"
			, end_time.year, end_time.month, end_time.day);
			g_euser.monthly_end_date = monthly_end_date;
		end
		if extra_gold > 0 or extra_crystal > 0 then
			size.height = size.height + hfix(26);
			tip = tip .. "\n\n首次充值,额外获得:";
			if extra_gold > 0 then
				tip = tip .. string.format("\n%d 金币", extra_gold);
				size.height = size.height + hfix(13);
			end
			if extra_crystal > 0 then
				tip = tip .. string.format("\n%d 水晶", extra_crystal);
				size.height = size.height + hfix(13);
			end
			-- TODO: hard code for first pay
			tip = tip .. "\n英雄 宙斯[1]";
			tip = tip .. "\n魔法 火球[4]";
			size.height = size.height + hfix(26);
		end
	end
	g_scene:add_layer(ZORDER_LAYER_MSG, layer_msg:create(tip, nil, size));
	net_send('sta', true);
end

-- CMD lguild [start_id] [page_size] [key]
-- start_id start from 0
-- RET lguild [start_id] [size] [g_info1] [g_info2]...
-- size <= page_size
-- g_info = gid total_member glevel gold crystal gname
function net_lguild(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local start_id = check;
	local size = tonumber(input_list[3]);
	local index = 4;
	local list_guild = {};
	for i = 1, size do
		local gid = tonumber(input_list[index]);
		index = index + 1;
		local total_member = tonumber(input_list[index]);
		index = index + 1;
		local glevel = tonumber(input_list[index]);
		index = index + 1;
		local gold = tonumber(input_list[index]);
		index = index + 1;
		local crystal = tonumber(input_list[index]);
		index = index + 1;
		local gname = input_list[index];
		index = index + 1;
		local l = { gid = gid, total_member = total_member, glevel = glevel, 
					gold = gold, crystal = crystal, gname = gname };
		table.insert(list_guild, l);
	end
	if g_scene:is_stage(STAGE_LGUILD) then
		layer_lguild:add_list(list_guild, start_id);
		return;
	end
end

-- CMD gapply [gid]
-- RET gapply [eid] [gid] [gpos] [gname]
function net_gapply(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local eid = check;
	local gid = tonumber(input_list[3]);
	local gpos = tonumber(input_list[4]);
	local gname = input_list[5];
	if eid == g_euser.eid then
		g_euser.gid = gid;
		g_euser.gpos = gpos;
		g_euser.gname = gname;
	end
	if g_scene:is_stage(STAGE_LGUILD) then
		layer_lguild:reload_data();
		return;
	end
end

-- CMD gquit [eid_optional:for_kick]
-- for normal quit: just quit
-- for master kick member: gquit [member_eid]
-- RET gquit [eid]
function net_gquit(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local eid = check;
	if eid == g_euser.eid then
		g_euser.gid = 0;
		g_euser.gpos = GUILD_POS_NONE;
		g_euser.gname = get_guild_name();
		g_euser.guild_data = nil;
		show_msg("你被踢出公会了");
		if g_scene:is_stage(STAGE_LGUILD) then
			g_scene:lguild();
		elseif g_scene:is_stage(STAGE_GUILD) or g_scene:is_stage(STAGE_WELFARE) 
		 or g_scene:is_stage(STAGE_LMEMBER) or g_scene:is_stage(STAGE_LSTOCK) then
			g_scene:map();
		end
	end
	if g_scene:is_stage(STAGE_LMEMBER) then
		layer_lmember:remove_member(eid);
		return;
	end
	if g_scene:is_stage(STAGE_LAPPLY) then
		layer_lapply:remove_apply(eid);
		return;
	end
end

-- CMD cguild
-- RET cguild 0 [create_guild_gold] [create_guild_crystal]
-- CMD cguild [gname]
-- RET cguild [gid] [gname]
function net_cguild(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if 0 == check then
		local gold = tonumber(input_list[3]);
		local crystal = tonumber(input_list[4]);
		scene:add_layer(ZORDER_LAYER_CGUILD, layer_cguild:create(gold, crystal));
		return;
	end
	local gid = check;
	local gname = input_list[3];
	g_euser.gid = gid;
	g_euser.gpos = GUILD_POS_MASTER;
	g_euser.gname = gname;
	if g_scene:is_stage(STAGE_LGUILD) then
		net_send('guild');
		return;
	end
end

-- CMD guild [gid_optional] [notice_optional]
-- note: empty gid means my guild
-- RET guild gid total_member max_member glevel gold crystal consume master_alias 
--     master_icon gname notice
function net_guild(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local l = {};
	l.gid = check;
	l.total_member = tonumber(input_list[3]);
	l.max_member = tonumber(input_list[4]);
	l.glevel = tonumber(input_list[5]);
	l.gold = tonumber(input_list[6]);
	l.crytal = tonumber(input_list[7]);
	l.consume = tonumber(input_list[8]);
	l.master_alias = input_list[9];
	l.master_icon = input_list[10];
	l.gname = input_list[11];
	l.notice = input_list[12];
	g_scene:guild(l);
end

-- CMD gbonus [get_flag]
-- get_flag==0 means only check, but not really get the bonus
-- get_flag==1 means get bonus
-- RET gbonus eid check_flag guild_gold rate gshare bonus_gold 
--     last_bonus_time(sec)
-- e.g. guild_gold=10000 rate=0.05(5%) gshare=0.1(10%) so bonus_gold=50(int)
-- ERR gbonus -6 already_get_bonus
function net_gbonus(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local eid = check;
	if eid ~= g_euser.eid then
		return;
	end
	local l = {};
	l.check_flag = tonumber(input_list[3]);
	l.guild_gold = tonumber(input_list[4]);
	l.rate = tonumber(input_list[5]);
	l.gshare = tonumber(input_list[6]);
	l.bonus_gold = tonumber(input_list[7]);
	l.last_bonus_time = tonumber(input_list[8]);
	if g_scene:is_stage(STAGE_WELFARE) then
		layer_welfare:set_data(l);
	end
end

-- CMD glv [gid_optional]
-- RET glv gid current_level current_gold current_member_max current_consume_gold
--     next_level levelup_gold next_member_max next_consume_gold
function net_glv(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local gid = check;
	local current_lv = tonumber(input_list[3]);
	local current_gold = tonumber(input_list[4]);
	local current_mb_max = tonumber(input_list[5]);
	local current_cs_gold = tonumber(input_list[6]);
	local next_lv = tonumber(input_list[7]);
	local levelup_gold = tonumber(input_list[8]);
	local next_mb_max = tonumber(input_list[9]);
	local next_cs_gold = tonumber(input_list[10]);
	local tip = string.format("升到%d级(人数上限[%d],每日消耗[%d])需要%d金币,确定升级?", next_lv, next_mb_max, next_cs_gold, levelup_gold);
	layer_guild:ask_levelup_guild(tip, levelup_gold);
end

-- CMD glevelup
-- RET glevelup gid new_level gold_reduce(-negative) new_member_max new_consume
function net_glevelup(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local gid = check;
	local current_lv = tonumber(input_list[3]);
	local gold_reduce = tonumber(input_list[4]);
	local current_mb_max = tonumber(input_list[5]);
	local current_cs_gold = tonumber(input_list[6]);
	net_send('guild');
	show_msg('升级成功');
end

-- CMD dguild 
-- only master can do
-- RET dguild [gid]
function net_dguild(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local gid = check;
	if gid == g_euser.gid then
		g_euser.gid = 0;
		g_euser.gpos = GUILD_POS_NONE;
		g_euser.gname = get_guild_name();
		g_euser.guild_data = nil;
	end
	g_scene:lguild();
end

-- CMD glist [flag] [start_id] [page_size] [gid_optional]
-- flag: 0 = all member include apply
--       1 = all member without apply
--       9 = apply
-- optional: gid , to check other guild's list
-- RET glist [flag] [start_id] [total_member] [member_info1] [member_info2] ...
-- member_info: eid gpos alias icon rating last_login gshare level
function net_glist(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local flag = check;
	local start_id = tonumber(input_list[3]);
	local size = tonumber(input_list[4]);
	local index = 5;
	local list_member = {};
	for i = 1, size do
		local l = {};
		l.eid = tonumber(input_list[index]);
		index = index + 1;
		l.gpos = tonumber(input_list[index]);
		index = index + 1;
		l.alias = input_list[index];
		index = index + 1;
		l.icon = input_list[index];
		index = index + 1;
		l.rating = input_list[index];
		index = index + 1;
		l.last_login = tonumber(input_list[index]);
		index = index + 1;
		l.gshare = input_list[index];
		index = index + 1;
		l.level = tonumber(input_list[index]);
		index = index + 1;
		table.insert(list_member, l);
	end
	table.sort(list_member, function(a, b)
		return ((tonumber(a.gshare) or 0) > (tonumber(b.gshare) or 0));
	end);
	if g_scene:is_stage(STAGE_LMEMBER) then
		layer_lmember:add_list(list_member, start_id);
	elseif g_scene:is_stage(STAGE_LAPPLY) then
		layer_lapply:add_list(list_member, start_id);
	elseif g_scene:is_stage(STAGE_LSTOCK) then
		layer_lstock:add_list(list_member, start_id);
	end
end

-- CMD gpos [gid] [pos]
-- pos = 1 is invalid
-- RET gpos [eid] [pos] [gid]
function net_gpos(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local eid = check;
	local pos = tonumber(input_list[3]);
	local gid = tonumber(input_list[4]);
	if eid == g_euser.eid then
		g_euser.gid = gid;
		g_euser.gpos = pos;
		if g_scene:is_stage(STAGE_LGUILD) then
			layer_lguild:reload_data();
			net_send('guild');
			return;
		end
	end
	if g_scene:is_stage(STAGE_LAPPLY) then
		layer_lapply:remove_apply(eid);
		return;
	end
	if g_scene:is_stage(STAGE_LMEMBER) then
		layer_lmember:update_pos(eid, pos);
		return;
	end
	--[[
	if g_scene:is_stage(g_scene.LPOS) then
		g_layer_lpos:update_pos(eid, pos);
		return;
	end
	]]--
end

-- CMD deposit 
-- RET deposit eid gid my_deposit_gold my_deposit_crystal gshare 
--     guild_deposit_gold guild_deposit_crystal
function net_deposit(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local eid = check;
	if eid ~= g_euser.eid then
		return;
	end
	local info = {};
	info.gid = tonumber(input_list[3]);
	info.my_gold = tonumber(input_list[4]);
	info.my_crystal = tonumber(input_list[5]);
	info.gshare = tonumber(input_list[6]);
	info.guild_gold = tonumber(input_list[7]);
	info.guild_crystal = tonumber(input_list[8]);
	if g_scene:is_stage(STAGE_INVEST) then
		layer_invest:set_data(info);
	end
end

-- CMD gdeposit gold
-- RET gdeposit eid gid gold
function net_gdeposit(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local eid = check;
	local gid = tonumber(input_list[3]);
	local gold = tonumber(input_list[4]);
	g_euser.gold = g_euser.gold - gold;
	if nil ~= g_euser.guild_data then
		g_euser.guild_data.gold = g_euser.guild_data.gold + gold;
	end
	if g_scene:is_stage(STAGE_INVEST) then
		layer_infobar:update_info();
		g_scene:invest();
		local str = string.format("成功捐献%d金币", gold);
		show_msg(str);
		return;
	end
end

-- CMD ldeposit start_id page_size
-- RET ldeposit start_id page_size [deposit_info1] [deposit_info2] ...
-- deposit_info = deposit_date eid alias icon gold crystal
function net_ldeposit(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local start_id = check;
	local page_size = tonumber(input_list[3]);
	local index = 4;
	local list = {};
	for i = 1, page_size do
		local l = {};
		l.deposit_date = tonumber(input_list[index]);
		index = index + 1;
		l.eid = tonumber(input_list[index]);
		index = index + 1;
		l.alias = input_list[index];
		index = index + 1;
		l.icon = input_list[index];
		index = index + 1;
		l.gold = tonumber(input_list[index]);
		index = index + 1;
		l.crystal = tonumber(input_list[index]);
		index = index + 1;
		l.gpos = tonumber(input_list[index]);
		index = index + 1;
		table.insert(list, l);
	end
	if g_scene:is_stage(STAGE_LDEPOSIT) then
		layer_ldeposit:add_list(list, start_id);
	end
end

-- CMD challenge type eid
-- RET challenge type flag eid alias
--  type == 0: challenge someone
--  type == 1: challenge cancel
--  type == 2: challenge accept
--  type == 3: challenge refuse
--  flag == 0:sender
--  flag == 1:receiver
function net_challenge(input_list, str, check)
	if check < 0 then
		if -36 == check then
			if nil ~= layer_fight.layer then
				layer_fight:remove();
			end
		end
		show_err(str);
		return;
	end
	local ctype = check;
	local flag = input_list[3];
	local eid = tonumber(input_list[4]);
	local alias = input_list[5];
	if 0 == ctype and '1' == flag then -- receiver
		pop_answer_fight(eid, alias);
	end
	if (1 == ctype or 2 == ctype or 3 == ctype) and '1' == flag then --receiver
		if nil ~= layer_fight.layer then
			layer_fight:remove();
		end
	end
end

-- mtype:  1=MISSION_LEVEL,  2=AI, 3=VS,  4=CHALLENGE,  5=BEI_CHALLENG
-- 6=REPLAY,  7=CHAT,  8=FRIEND,  9=SHOP,  10=CARD,  11=COLLECTION
-- 13=VIEW, 16=gate
-- status: 0=cannot accept, 1=accepted and not finish, 2=finished and not reward
-- 3=got reward
-- daily: 0=not show reset time, 1=show reset time
-- CMD mlist [start_id]
-- RET mlist [start_id] [total] [mission1] [mission2] ...
-- mission = [mid] [status] [mtype] [n1] [p1] [p2] [p3] [reward_card] [exp] 
--		     [gold] [crystal] [daily] [reset_time] [mtext]
-- start_id: ==0 first page
-- total: == 10, may has next page
function net_mlist(input_list, str, check)
	if check < 0 then
		return;
	end
	if nil == layer_mission.layer then return; end
	local start_id = check;
	local total = tonumber(input_list[3]);
	local index = 4;
	local list = {};
	for i = 1, total do
		local l = {};
		l.mid = tonumber(input_list[index]);
		index = index + 1;
		l.status = tonumber(input_list[index]);
		index = index + 1;
		l.mtype = tonumber(input_list[index]);
		index = index + 1;
		l.n1 = tonumber(input_list[index]);
		index = index + 1;
		l.p1 = tonumber(input_list[index]);
		index = index + 1;
		l.p2 = tonumber(input_list[index]);
		index = index + 1;
		l.p3 = tonumber(input_list[index]);
		index = index + 1;
		l.reward_card = tonumber(input_list[index]);
		index = index + 1;
		l.exp = tonumber(input_list[index]);
		index = index + 1;
		l.gold = tonumber(input_list[index]);
		index = index + 1;
		l.crystal = tonumber(input_list[index]);
		index = index + 1;
		l.daily = tonumber(input_list[index]);
		index = index + 1;
		l.reset_time = input_list[index];
		index = index + 1;
		local mtext = input_list[index];
		index = index + 1;
		mtext = string.gsub(mtext, "n1", l.n1);
		mtext = string.gsub(mtext, "p1", l.p1);
		local tl = csplit(mtext, "(^)");
		local tl2 = {};
		for i = 1, #tl do
			local m = tl[i];
			m = string.gsub(m, "_", ' ');
			table.insert(tl2, m);
		end
		local title = tl2[1] or '';
		local detail = '';
		for i = 2, #tl2 do
			m = tl2[i];
			detail = detail .. m;
			if i < #tl2 then
				detail = detail .. '\n';
			end
		end
		if 1 == l.daily then
			title = '(每日)' .. title;
		end
		l.title = title;
		l.detail = detail;
		if g_euser.level < 5 and 16 == l.mtype and l.mid > 100 then
			table.insert(list, 1, l);
		else
			table.insert(list, l);
		end
	end
	local has_more = false;
	if #list >= 10 then
		has_more = true;
	end
	if nil == layer_mission.layer then return; end
	layer_mission:add_list(list, has_more);
	if g_tutor_wait_net == show_tutor_do_mission then
		g_tutor_wait_net();
	end
end

-- CMD mreward [mid]
-- RET mreward [mid] [reward_card] [reward_exp] [gold] [crystal] [lv_offset]
function net_mreward(input_list, str, check)
	if check < 0 then
		return;
	end
	local mid = check;
	local reward_card = tonumber(input_list[3]);
	-- all below is offset
	local reward_exp = tonumber(input_list[4]);
	local gold = tonumber(input_list[5]);
	local crystal = tonumber(input_list[6]);
	local lv_offset = tonumber(input_list[7]);
--	if 2 == (g_euser.level + lv_offset) then
--		g_euser.level = g_euser.level + lv_offset;
--		g_scene:map();
--	end
	if 0 < reward_card then
		local rc = g_card_list[reward_card];
		if nil == rc then
			rc = hero_list[reward_card];
		end
		local card = clone(rc);
		if nil ~= card then
			local layer, name = layer_mispop:create(card);
			layer_mispop:show_eff1();
			local tip = "获得新卡牌！快去牌堆上阵新卡吧！";
			util.add_labelttf(layer, tip, nil, 27, cc.p(HALF_WIDTH, FULL_HEIGHT), util.c4b_white, ANCHOR_CENTER_UP, 100, cc.size(FULL_WIDTH, 100), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
			g_scene:add_layer(ZORDER_LAYER_MISPOP, layer, name);
		end
	end
	show_msg('领取成功');
	net_send('sta', true);
	if g_euser.level < 5 then
		g_tutor_wait_net = show_tutor_do_mission;
	end
	show_mission_list();
	net_send('course', true);
end

-- only server send to client
-- RET mchange [flag]
-- flag: 1 = has new mission
--       2 = has target ok mission
--       3 = has new mission and target ok mission
function net_mchange(input_list, str, check)
	if check < 0 then
		return;
	end
	local flag = check;
	g_mission_tip = flag;
	if g_scene:is_stage(STAGE_MAP) then
		layer_chat:tip_btn_mission();

	end
end

-- CMD kick eid
-- RET kick eid room.state
function net_kick(input_list, str, check)
	if check < 0 then
		return;
	end
	local eid = check;
	local rstate = tonumber(input_list[3]);
	if nil ~= layer_room.layer then
		if eid == g_euser.eid then
			layer_room:remove();
			return;
		end
		layer_room:hide_start(eid);
	end
end

-- CMD match_cancel match_id
-- RET match_cancel match_id max_player current_player
function net_match_cancel(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local match_id = input_list[2];
	local max_player = tonumber(input_list[3]);
	local current_player = tonumber(input_list[4]);
	show_msg('退赛成功');
	if nil ~= layer_lmatch.layer then
		layer_lmatch:refresh_my_status(match_id, max_player, current_player);
	end
end

-- CMD player_data eid_option
-- RET player_data match_data round_date my_info oppo_info
-- match_data = match_id status round title max_player start_time MATCH_ROUND_TIME
-- 				MAX_DAILY_ROUND t1 t2 t3 t4 tn
-- player_info = eid round team_id win lose draw tid point alias icon
-- oppo_info and round_date may null if match.status == MATCH_STATUS_READY
-- match status
-- see in MATCH STATUS DEFINE
function net_player_data(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local index = 2
	local mdata = {}; -- match data
	mdata.match_id = input_list[index];
	index = index + 1;
	mdata.match_status = tonumber(input_list[index]);
	index = index + 1;
	mdata.round = tonumber(input_list[index]);
	index = index + 1;
	mdata.title = input_list[index];
	index = index + 1;
	mdata.max_player = tonumber(input_list[index]);
	index = index + 1;
	mdata.start_time = tonumber(input_list[index]);
	index = index + 1;
	mdata.match_round_time = tonumber(input_list[index]);
	index = index + 1;
	local max_daily_round = tonumber(input_list[index]);
	index = index + 1;
	local daily_info = {};
	for i = 1, max_daily_round do
		local t = tonumber(input_list[index]);
		index = index + 1;
		if t > 0 then
			table.insert(daily_info, t);
		end
	end
	mdata.daily_info = daily_info;

	local round_date = tonumber(input_list[index]);
	index = index + 1;

	local player_info = {};
	player_info.eid = tonumber(input_list[index]);
	index = index + 1;
	player_info.round = tonumber(input_list[index]);
	index = index + 1;
	player_info.team_id = tonumber(input_list[index]);
	index = index + 1;
	player_info.win = tonumber(input_list[index]);
	index = index + 1;
	player_info.lose = tonumber(input_list[index]);
	index = index + 1;
	player_info.draw = tonumber(input_list[index]);
	index = index + 1;
	player_info.tid = tonumber(input_list[index]);
	index = index + 1;
	player_info.point = tonumber(input_list[index]);
	index = index + 1;
	player_info.icon = tonumber(input_list[index]);
	index = index + 1;
	player_info.alias = input_list[index];
	index = index + 1;

	local oppo_info = nil;
	if MATCH_STATUS_READY < mdata.match_status then 
		oppo_info = {};
		oppo_info.eid = tonumber(input_list[index]);
		index = index + 1;
		oppo_info.round = tonumber(input_list[index]);
		index = index + 1;
		oppo_info.team_id = tonumber(input_list[index]);
		index = index + 1;
		oppo_info.win = tonumber(input_list[index]);
		index = index + 1;
		oppo_info.lose = tonumber(input_list[index]);
		index = index + 1;
		oppo_info.draw = tonumber(input_list[index]);
		index = index + 1;
		oppo_info.tid = tonumber(input_list[index]);
		index = index + 1;
		oppo_info.point = tonumber(input_list[index]);
		index = index + 1;
		oppo_info.icon = tonumber(input_list[index]);
		index = index + 1;
		oppo_info.alias = input_list[index];
		index = index + 1;
	end
	local layer, name = layer_matchdata:create(mdata, player_info, oppo_info, round_date);
	g_scene:add_layer(ZORDER_LAYER_MATCHDATA, layer, name, true);
end

-- get to 50 ranking list
-- CMD rlist
-- RET rlist gold crystal remain_time rank challenge_time row_num info1 info2 ...
-- info = eid, rank, icon, rating, alias
function net_rlist(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local gold = check;
	local crystal = tonumber(input_list[3]);
	local remain_time = tonumber(input_list[4]);
	local rank = tonumber(input_list[5]);
	local challenge_time = tonumber(input_list[6]);
	local row_num = tonumber(input_list[7]);
	local index = 8;
	local list = {};
	for i = 1, row_num do
		local l = {};
		l.eid = tonumber(input_list[index]);
		index = index + 1;
		l.level = tonumber(input_list[index]);
		index = index + 1;
		l.rank = tonumber(input_list[index]);
		index = index + 1;
		l.icon = input_list[index];
		index = index + 1;
		l.rating = input_list[index];
		index = index + 1;
		l.alias = input_list[index];
		index = index + 1;
		table.insert(list, l);
	end
	layer_prank:show_rank(list, gold, crystal, remain_time, rank, challenge_time);
end

-- get rank target list could be challenged
-- CMD rtarlist
-- RET rtarlist gold crystal remain_time rank challenge_time row_num info1 info2 ...
-- info = eid, rank, icon, rating, alias
function net_rtarlist(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local gold = check;
	local crystal = tonumber(input_list[3]);
	local remain_time = tonumber(input_list[4]);
	local rank = tonumber(input_list[5]);
	local challenge_time = tonumber(input_list[6]);
	local row_num = tonumber(input_list[7]);
	local index = 8;
	local list = {};
	for i = 1, row_num do
		local l = {};
		l.eid = tonumber(input_list[index]);
		index = index + 1;
		l.level = tonumber(input_list[index]);
		index = index + 1;
		l.rank = tonumber(input_list[index]);
		index = index + 1;
		l.icon = input_list[index];
		index = index + 1;
		l.rating = input_list[index];
		index = index + 1;
		l.alias = input_list[index];
		index = index + 1;
		table.insert(list, l);
	end
	layer_prank:show_challenge(list, gold, crystal, remain_time, rank, challenge_time);
end

-- if everything normal and target is offline, will ret to room
-- RET: * if target player online
-- rgame [eid] [target_eid] [icon] [target_icon] [alias] [target_alias] [challenge_time]
-- >>> please show a dialog in client for player to send CMD rcancel for cancel the challenge
-- and target player will receive RET
-- rchallenge [eid] [icon] [alias]
-- >>> please show a count-down 10 second dialog in client for player to send CMD rresp for accept/refuse the challenge, after 10 second, auto close the dialog
-- * else
-- room ...    -- normally start a battle
-- @Notice if [target_eid] is not in target list, it will send back
-- rgame -1 rank_has_changed
-- please resend CMD: rtarlist to refresh target list
-- CMD rgame [target_eid] [target_rank]
-- RET rgame [eid] [target_eid] [icon] [target_icon] [alias] [target_alias] [challenge_time]
function net_rgame(input_list, str, check)
	if check < 0 then
		if -1 == check then
			g_scene:prank();
			return; 
		end
		show_err(str);
		return;
	end
	local target_eid = tonumber(input_list[3]);
	local target_alias = input_list[7];
	local s = string.format("正向[%s]发出挑战，等待对方回应", target_alias);
	g_scene:add_layer(ZORDER_LAYER_PRANK_TIP,layer_prank_tip:create(s, layer_prank_tip.TYPE_WAIT, {eid=target_eid}));
end

-- RET rchallenge eid icon alias
function net_rchallenge(input_list, str, check)
	if check < 0 then
		if -1 == check then
			g_scene:prank();
			return; 
		end
		show_err(str);
		return;
	end
	local target_eid = tonumber(input_list[2]);
	local target_icon = input_list[3];
	local target_alias = input_list[4];
	local s = string.format("[%s]向你发出挑战", target_alias);
	g_scene:add_layer(ZORDER_LAYER_PRANK_TIP,layer_prank_tip:create(s, layer_prank_tip.TYPE_REPLY, {eid=target_eid}));
end

-- CMD rcancel target_eid
-- RET rcancel 0
function net_rcancel(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if nil ~= layer_prank_tip.layer then
		layer_prank_tip:remove();
	end
end

-- CMD rresp eid resp
-- RET if accept challenge ( resp = 1 )
--        room .. -- normally start battle
--     else
--        rgame_resp 0 ( resp = 0)
-- @Notice it will leave 10 second to accept to accept challenge, if overtime, challenger will auto enter a battle with ai, player be challenged need not send this cmd
function net_rresp(input_list, str, check)
	if nil ~= layer_prank_tip.layer then
		layer_prank_tip:remove();
	end
	if check < 0 then
		-- rresp -6 resp_ranking_game:not_be_challenged eid[1074
		if -6 == check then return; end
		show_err(str);
		return;
	end
end

-- CMD list_message [start_num] [page_size]
-- RET list_message [eid] [start_num] [page_size] [total_message_num] [real_page_n     um] [message_info1] [message_info2] ...
-- message_info: [message_id] [send_eid] [send_alias] [time] [unread] [title]
-- unread: 1 == unread, 0 == readed
function net_list_message(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local eid = check;
	local start_num = tonumber(input_list[3]);
	local page_size = tonumber(input_list[4]);
	local total_message_num = tonumber(input_list[5]);
	local real_page_num = tonumber(input_list[6]);
	local list = {};
	local index = 7;
	for i = 1, real_page_num do
		local l = {};
		l.message_id = tonumber(input_list[index]);
		index = index + 1;
		l.send_id = tonumber(input_list[index]);
		index = index + 1;
		l.send_alias = input_list[index];
		index = index + 1;
		l.time = tonumber(input_list[index]);
		index = index + 1;
		l.read_flag = tonumber(input_list[index]);
		index = index + 1;
		l.title = input_list[index];
		index = index + 1;
		table.insert(list, l);
	end
	if nil == layer_mail_box.layer then
		layer_mail:show_mailbox();
	end
	layer_mail_box:add_list(list, start_num, total_message_num);
end

-- CMD read_message [message_id]
-- RET read_message [eid] [message_id] [recv_eid] [send_eid] [send_alias] [time] [     unread] [title] [message]
function net_read_message(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local time = input_list[7];
	local title = input_list[9];
	local message = input_list[10];
	local t = os.date("*t", time);
	local str = string.format("%d年%02d月%02d日 %02d时%02d分%02d秒", t.year, t.month, t.day, t.hour, t.min, t.sec);
	message = string.format("收件时间:[%s]\n\n%s", str, message);
	layer_mail_box:delete_read_cell();
	g_scene:add_layer(ZORDER_LAYER_TEXT, layer_text:create(title, message));
end

-- CMD match_apply match_id
-- RET match_apply match_id max_player current_player
function net_match_apply(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local match_id = input_list[2];
	local max_player = tonumber(input_list[3]);
	local current_player = tonumber(input_list[4]);
	show_msg('参赛成功');
	if nil ~= layer_lmatch.layer then
		layer_lmatch:refresh_my_status(match_id, max_player, current_player,true);
	end
end

-- CMD @match_delete match_id
-- RET @match_delete match_id ok
function net_atmatch_delete(input_list, str, check)
	if check < 0 then
		return;
	end
	local match_id = check;
	show_msg('删除成功');
	if nil ~= layer_cmatch.layer then
		layer_cmatch:remove();
	end
end

-- CMD @match_add max_player start_date t1 t2 t3 t4 title
-- RET @match_add match_id
-- start_date = yyyyMMdd
-- t1, t2, t3, t4 = HHii
function net_atmatch_add(input_list, str, check)
	if check < 0 then
		return;
	end
	local match_id = check;
	show_msg('创建成功');
	if nil ~= layer_cmatch.layer then
		layer_cmatch:remove();
	end
end

-- CMD @match_init match_id
-- RET @match_add match_id ok
function net_atmatch_init(input_list, str, check)
	if check < 0 then
		return;
	end
	local match_id = check;
	show_msg('准备比赛成功');
end

-- CMD lmatch
-- RET lmatch [my_match_id] [match_count] [match_info]
-- match_info: match_id match_status round title max_player current_player
--             start_time match_round_time daily_info
-- my_match_id: the match which I took part in
-- start_time: yyyymmdd
-- match_round_time: sec
-- daily_info: max_daily_round t1 t2 ... tn (n=max_daily_round)
-- t1, t2 ... tn = time_t, base 1970-01-01, 0 <= ti < 24 * 60 * 60
-- match status
-- see in MATCH STATUS DEFINE
function net_lmatch(input_list, str, check)
	if check < 0 then
		return;
	end
	local my_match_id = input_list[2];
	local match_count = tonumber(input_list[3]);
	local list = {};
	local index = 4;
	for i = 1, match_count do
		local l = {};
		l.match_id = input_list[index];
		index = index + 1;
		l.match_status = tonumber(input_list[index]);
		index = index + 1;
		l.round = tonumber(input_list[index]);
		index = index + 1;
		l.title = input_list[index];
		index = index + 1;
		l.max_player = tonumber(input_list[index]);
		index = index + 1;
		l.current_player = tonumber(input_list[index]);
		index = index + 1;
		l.start_time = tonumber(input_list[index]);
		index = index + 1;
		l.match_round_time = tonumber(input_list[index]);
		index = index + 1;
		local daily_info = {};
		local max_daily_round = tonumber(input_list[index]);
		index = index + 1;
		for i = 1, max_daily_round do
			local t = tonumber(input_list[index]);
			index = index + 1;
			if t > 0 then
				table.insert(daily_info, t);
			end
		end
		l.daily_info = daily_info;
		table.insert(list, l);
	end
	layer_lmatch:add_list(list, my_match_id);
end


-- CMD: list_solo [solo_id]
-- RET: list_solo [solo_id] [num] [info1] [info2] ...
-- info: [id] [hero_id] [alias]
function net_list_solo(input_list, str, check)
	if check < 0 then
		show_msg(str);
		return;
	end
	if nil == layer_solo_plus.layer then return; end
	local solo_id	= tonumber(input_list[2]);
	local num		= tonumber(input_list[3]);
	local list		= {};
	local index		= 4;
	for i = 1, num do
		local info = {};
		info.id			= tonumber(input_list[index]);
		index			= index + 1;
		info.hero_id	= tonumber(input_list[index]);
		index			= index + 1;
		info.alias		= input_list[index];
		index			= index + 1;
		table.insert(list, info);
	end
	layer_solo_plus:add_list(list);
end

-- CMD: solo_plus [solo_id]
-- RET: room ...
-- CMD: ginfo
-- RET: solo_plus [side] [cmd_size] [seed] [timeout] [deck1] [solo_hero] [solo_type] [solo_max_ally] [solo_type_list] [c1] [c2] ... [cn]
function net_solo_plus(input_list, str, check)
	if check < 0 then
		show_msg(str);
		return;
	end
	data_handler:cleanup();
	local side			= check;
	local cmd_size		= tonumber(input_list[3]);
	local seed			= tonumber(input_list[4]);
	local timeout		= tonumber(input_list[5]);
	local deck1_array	= input_list[6];

	local solo_data			= {};
	solo_data.hero			= tonumber(input_list[7]);
	solo_data.type_flag		= tonumber(input_list[8]);
	solo_data.max_ally		= tonumber(input_list[9]);
	solo_data.type_list		= input_list[10];
	solo_data.deck2_list	= input_list[11];
	for i = 12, #input_list do
		solo_data.deck2_list = solo_data.deck2_list .. ' ' .. input_list[i];
	end

	g_game_info = {
		side = side,
		cmd_size = cmd_size,
		seed		= seed,
		deck1_array	= deck1_array,
		timeout		= timeout,
		solo_data	= solo_data,
	};
	g_game_play_list = {};
	init_net_play();
	if cmd_size > 0 then
		g_scene:preload(cb_net_game, layer_preload.WAIT, STAGE_PVP);
		g_net_cmdsize = cmd_size + 1;
		return;
	end
	g_scene:preload(cb_net_game, layer_preload.START, STAGE_PVP);
end

-- CMD: ginfo
-- RET: robot_game [side] [cmd_size] [seed] [timeout] [game_type] [deck1] [solo_hero] [c1] [c2] ... [cn]
function net_robot_game(input_list, str, check)
	if check < 0 then
		show_msg(str);
		return;
	end
	data_handler:cleanup();
	local side			= check;
	local cmd_size		= tonumber(input_list[3]);
	local seed			= tonumber(input_list[4]);
	local timeout		= tonumber(input_list[5]);
	local game_type		= tonumber(input_list[6]);
	local deck1_array	= input_list[7];

	local robot_data		= {};
	robot_data.hero			= tonumber(input_list[8]);
	robot_data.deck2_list	= input_list[9];
	for i = 10, #input_list do
		robot_data.deck2_list = robot_data.deck2_list .. ' ' .. input_list[i];
	end

	g_game_info = {
		side = side,
		cmd_size = cmd_size,
		seed		= seed,
		deck1_array	= deck1_array,
		timeout		= timeout,
		game_type	= game_type,
		robot_data	= robot_data,
	};
	g_game_play_list = {};
	init_net_play();
	if cmd_size > 0 then
		g_scene:preload(cb_net_game, layer_preload.WAIT, STAGE_PVP);
		g_net_cmdsize = cmd_size + 1;
		return;
	end
	g_scene:preload(cb_net_game, layer_preload.START, STAGE_PVP);
end


-- no use
function net_atwin(input_list, str, check)
	if check < 0 then
		if true == DEBUG_MODE then
			show_msg(str);
		end
		return;
	end
end

-- CMD lottery [type] [times]
-- if type == 0, get lottery price, times maybe empty
-- RET lottery eid 0 lottery_one_gold lottery_one_crystal lottery_ten_gold 
--     lottery_ten_crystal
-- if type == 1, gold lottery; type == 2, crystal lottery
-- times == 1 or 10, define lottery price and cid count
-- RET lottery eid type gold crystal 1 cid1
-- RET lottery eid type gold crystal 10 cid1 cid2 ... cid10
function net_lottery(input_list, str, check)
	if check < 0 then
		show_msg(str);
		return;
	end
	local eid = check;
	local ltype = tonumber(input_list[3]);
	if 0 == ltype then
		local one_gold = math.abs(tonumber(input_list[4]) or 0);
		local one_crystal = math.abs(tonumber(input_list[5]) or 0);
		local ten_gold = math.abs(tonumber(input_list[6]) or 0);
		local ten_crystal = math.abs(tonumber(input_list[7]) or 0);
		if nil == layer_lottery.layer then return; end
		layer_lottery:add_price(one_gold, ten_gold, one_crystal, ten_crystal);
		if g_tutor_wait_net == tutor_pay_ad_2 then
			g_tutor_wait_net();
		end
		return;
	end
	local gold_offset = tonumber(input_list[4]) or 0;
	local crystal_offset = tonumber(input_list[5]) or 0;
	g_euser.gold = g_euser.gold + gold_offset;
	g_euser.crystal = g_euser.crystal + crystal_offset;
	layer_infobar:update_info();
	local count = tonumber(input_list[6]) or 0;
	local list = {};
	local index = 7;
	for i = 1, count do
		local cid = tonumber(input_list[index]);
		local rc = g_card_list[cid];
		if nil == rc then
			rc = hero_list[cid];
		end
		local card = clone(rc);
		table.insert(list, card);
		index = index + 1;
	end
	--[[
	if 1 == #list then
		local card = list[1];
		local layer, name = layer_mispop:create(card);
		layer_mispop:show_eff1();
		local tip = "获得新卡牌！快去牌堆上阵新卡吧！";
		util.add_labelttf(layer, tip, nil, 27, cc.p(HALF_WIDTH, FULL_HEIGHT), util.c4b_white, ANCHOR_CENTER_UP, 100, cc.size(FULL_WIDTH, 100), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
		g_scene:add_layer(ZORDER_LAYER_MISPOP, layer, name);
		return;
	end
	]]--
	g_scene:add_layer(ZORDER_LAYER_POPCLIST, layer_popclist:create(list, true));
end

function net_ljsdk(input_list, str, check)
	local event = input_list[2];
	--print("ljsdk event: " .. event);
	if event == "log_fail" then
		local reason = input_list[3];
		local customParams = input_list[4];
		show_msg("ljsdk login fail: " .. reason);
		g_euser.lj_userid = 0;
		return;
	end
	if event == "log_succ" then
		local uid			= input_list[3];
		local product_code	= input_list[4];
		local channel_id	= input_list[5];
		local token			= input_list[6];
--		show_msg("ljsdk login uid: " .. uid);
		g_euser.lj_userid = uid;
		--show_msg("sid: " .. sid);
		show_netloading();
		local xhr = cc.XMLHttpRequest:new();
		xhr.responseType = cc.XMLHTTPREQUEST_RESPONSE_STRING;
		local r = string.format("http://%s:8899/pay_server/ljsdklogin?userId=%s&productCode=%s&channel=%s&token=%s", IP_ADDR, uid, product_code, channel_id, token);
		xhr:open("GET", r);
		local function callback_xhr()
			hide_netloading();
			--local status = "Http Status Code:" .. xhr.statusText;
			local ret = xhr.response;
			--show_msg(ret);
			--print(ret);
			local function parse_json_str(jstr, key)
				local p1, p2 = string.find(jstr, key);
				if nil == p1 then
					return nil;
				end
				local pstart = p2 + 4;
				local pend = pstart;
				for i = pstart, string.len(jstr) do
					local c = string.sub(jstr, i, i);
					if '"' == c then
						pend = i;
						break;
					end
				end
				if pend <= pstart then
					return nil;
				end
				local ret = string.sub(jstr, pstart, pend-1);
				return ret;
			end
			local status = parse_json_str(ret, "status");
			if "0" ~= status then
				show_msg("登录验证失败");
				return;
			end
			local password = parse_json_str(ret, "password");
			local username = parse_json_str(ret, "username");
			--print('username:' .. username);
			--print('password:' .. password);
			--print('status:' .. status);
			layer_login:cb_login_for_ucsdk(username, password);
		end
		xhr:registerScriptHandler(callback_xhr);
		xhr:send();
		return;
	end
	if event == "log_out" then
		if stage ~= STAGE_LOGIN then
			g_scene:close_connect();
			g_euser.lj_userid = 0;
			g_scene:login();
		end
		return;
	end
	if event == "exit" then
		local s = '是否要退出游戏';
		g_scene:add_layer(ZORDER_LAYER_TIP,layer_tip:create(s,exit_game));
		return;
	end
	if event == "force_exit" then
		exit_game();
		return;
	end
end

function net_ucsdk(input_list, str, check)
	local event = input_list[2];
	--print("ljsdk event: " .. event);
	if event == "sdkinit" then
		--[[
		local ret = input_list[3];
		if ret == "succ" then
			show_msg("初始化成功");
			return;
		end
		if ret == "fail" then
			show_msg("初始化失败");
			return;
		end
		]]--
		return;
	end
	if event == "log_succ" then
		local sid = input_list[3];
		--show_msg("sid: " .. sid);
		show_netloading();
		local xhr = cc.XMLHttpRequest:new();
		xhr.responseType = cc.XMLHTTPREQUEST_RESPONSE_STRING;
		local r = string.format("http://%s:8899/pay_server/uclogin?sid=%s", IP_ADDR, sid);
		xhr:open("GET", r);
		local function callback_xhr()
			hide_netloading();
			--local status = "Http Status Code:" .. xhr.statusText;
			local ret = xhr.response;
			--show_msg(ret);
			--print(ret);
			local function parse_json_str(jstr, key)
				local p1, p2 = string.find(jstr, key);
				if nil == p1 then
					return nil;
				end
				local pstart = p2 + 4;
				local pend = pstart;
				for i = pstart, string.len(jstr) do
					local c = string.sub(jstr, i, i);
					if '"' == c then
						pend = i;
						break;
					end
				end
				if pend <= pstart then
					return nil;
				end
				local ret = string.sub(jstr, pstart, pend-1);
				return ret;
			end
			local status = parse_json_str(ret, "status");
			if "0" ~= status then
				show_msg("登录验证失败");
				return;
			end
			local password = parse_json_str(ret, "password");
			local username = parse_json_str(ret, "username");
			--print('username:' .. username);
			--print('password:' .. password);
			--print('status:' .. status);
			layer_login:cb_login_for_ucsdk(username, password);
		end
		xhr:registerScriptHandler(callback_xhr);
		xhr:send();
		return;
	end
	if event == "log_fail" then
		local code = input_list[3];
		local pszmsg = input_list[4];
		show_msg("log fail: (" .. code .. ") msg:" .. pszmsg);
		return;
	end
	if event == "log_cancel" then return; end
	if event == "pay_succ" then return; end
	if event == "pay_succ" then
		show_msg("调用成功");
		return;
	end
	if event == "pay_close" then return; end
	if event == "pay_fail" then
		show_msg("调用失败");
		return;
	end
end

g_net_command_list = {
	['log'] = net_log,
	['getsite'] = net_getsite,
	['room'] = net_room,
	['lmerge'] = net_lmerge,
	['lconstant'] = net_lconstant,
	['lcard'] = net_lcard,
	['sta'] = net_sta,
	['wchat'] = net_wchat,
	['rchat'] = net_rchat,
	['gchat'] = net_gchat,
	['fchat'] = net_fchat,
	['s'] = net_play,
	['t'] = net_play,
	['b'] = net_play,
	['n'] = net_play,
	['game'] = net_game,
	['ginfo'] = net_game,
	['gate'] = net_gate,
	['gate_msg'] = net_gate_msg,
	['lgate'] = net_lgate,
	['gift'] = net_gift,
	['fdata'] = net_fdata,
	['fight'] = net_fight,
	['win'] = net_win,
	['fold'] = net_fold,
	['greconn'] = net_greconn,
	['gerr'] = net_gerr;
	['reconn'] = net_reconn;
	['ERROR'] = net_show_err,
	['dres'] = net_dres,
	['lai'] = net_lai,
	['ldeck'] = net_ldeck,
	['slotlist'] = net_slotlist,
	['lslot'] = net_lslot,
	['rslot'] = net_rslot,
	['bslot'] = net_bslot,
	['reg'] = net_reg,
	['alias'] = net_alias,
	['ralias'] = net_ralias,
	['job'] = net_job,
	['ljob'] = net_ljob,
	['sprofile'] = net_sprofile,
	['lreplay'] = net_lreplay,
	['replay'] = net_replay,
	['sdeck'] = net_sdeck,
	['quick'] = net_quick,
	['leave'] = net_leave,
	['lchan'] = net_lchan,
	['lroom'] = net_lroom,
	['join'] = net_room,  -- should remove later
	['shop'] = net_shop,
	['buy'] = net_buy,
	['sell'] = net_sell,
	['ladder'] = net_ladder,
	['notice'] = net_notice,
	['flist'] = net_flist,
	['fsearch'] = net_fsearch,
	['fadd'] = net_fadd,
	['fdel'] = net_fdel,
	['fsta'] = net_fsta,
	['course'] = net_course,
	['scourse'] = net_scourse,
	['lpay'] = net_lpay,
	['lguild'] = net_lguild,
	['gapply'] = net_gapply,
	['gquit'] = net_gquit,
	['cguild'] = net_cguild,
	['guild'] = net_guild,
	['gbonus'] = net_gbonus,
	['glv'] = net_glv,
	['glevelup'] = net_glevelup,
	['dguild'] = net_dguild,
	['glist'] = net_glist,
	['gpos'] = net_gpos,
	['deposit'] = net_deposit,
	['gdeposit'] = net_gdeposit,
	['ldeposit'] = net_ldeposit,
	['challenge'] = net_challenge,
	['mlist'] = net_mlist,
	['mreward'] = net_mreward,
	['mchange'] = net_mchange,
	['kick'] = net_kick,
	['lmatch'] = net_lmatch,
	['match_apply'] = net_match_apply,
	['match_cancel'] = net_match_cancel,
	['player_data'] = net_player_data,
	['rlist'] = net_rlist,
	['rtarlist'] = net_rtarlist,
	['rgame'] = net_rgame,
	['rchallenge'] = net_rchallenge,
	['rcancel'] = net_rcancel,
	['rresp'] = net_rresp,
	['list_message'] = net_list_message,
	['read_message'] = net_read_message,
	['list_solo'] = net_list_solo,
	['solo_plus'] = net_solo_plus,
	['robot_game'] = net_robot_game,
	['@match_add'] = net_atmatch_add,
	['@match_delete'] = net_atmatch_delete,
	['@match_init'] = net_atmatch_init,
	['@win'] = net_atwin,
	['@pay'] = net_atpay,

	['batch'] = net_batch,
	['lpiece'] = net_lpiece,
	['ppiece'] = net_ppiece,
	['mpiece'] = net_mpiece,
	['xcadd'] = net_xcadd,
	['xcbuy'] = net_xcbuy,
	['xclist'] = net_xclist,
	['pick'] = net_pick,
	['sdebug'] = net_sdebug,
	['ldebug'] = net_ldebug,
	['ljsdk'] = net_ljsdk,
	['ucsdk'] = net_ucsdk,
	['lottery'] = net_lottery,
};

function split_string(str)
	return csplit(str, ' ');
end

function net_listener(str)
	--hide_netloading();
	kdebug("net_receive[%s]", str);
	add_chat_msg(C_LOG, 0, '日志', str, get_time());
	local input_list;
	input_list = split_string(str);
	local check = tonumber(input_list[2]);
	if nil ~= check and -8 == check then
		local current_status = tonumber(input_list[4]) or 0;
		-- -8 not_enough_st 5 < 15
		if current_status == ST_NULL then
			g_scene:login();
		elseif current_status == ST_LOGIN then
			g_scene:map();
		elseif current_status >= ST_ROOM then
			net_send('room');
		end
		return;
	end

	if nil ~= tonumber(input_list[1]) then
		net_play(input_list, str, check);
		return;
	end
	for k, v in pairs(g_net_command_list) do
		if k==input_list[1] then
			hide_netloading(); -- do it here, don't hide when get a unknown cmd
			v(input_list, str, check);
			return; -- early exit
		end
	end

end

function get_platform()
	local p = PLATFORM_UNKNOWN;
	local platform = cc.Application:getInstance():getTargetPlatform();
	if platform == cc.PLATFORM_OS_IPHONE then
		p = PLATFORM_IPHONE;
	elseif platform == cc.PLATFORM_OS_IPAD then
		p = PLATFORM_IPAD;
	elseif platform == cc.PLATFORM_OS_MAC then
		p = PLATFORM_MAC;
	elseif platform == cc.PLATFORM_OS_ANDROID then
		p = PLATFORM_ANDROID;
	elseif platform == cc.PLATFORM_OS_WINDOWS then
		p = PLATFORM_WINDOWS;
	end
	return p;
end

function get_channel()
	--local c = tonumber(CPID) or 0;
	local c = tonumber(CHANNEL_VER) or 0;
	return c;
end

function net_cmd_reg(username, password)
	local p = get_platform();
	local c = get_channel();
	local cmd = string.format("reg %s %s %d %d", username, password, p, c);
	net_send(cmd);
end

function net_cmd_log(username, password)
	local p = get_platform();
	local c = get_channel();
	local cmd = string.format("log %s %s %d %d", username, password, p, c);
	net_send(cmd);
end

function net_send(cmd, no_loading)
	if true ~= g_scene:is_online() then
		return;
	end
	if true ~= no_loading then
		show_netloading();
	end
	kdebug("net_send[%s]", cmd);
	local str = '发送[' .. cmd .. ']';
	add_chat_msg(C_LOG, 0, '日志', str, get_time());
	local ret;
	ret = LayerSocket:sendCmd(cmd .. '\n');
	return ret;
end

function net_send_dres(filename)
	if nil == filename then
		return;
	end
	LayerSocket:dlres(filename .. '\n');
end
-- /////////////////////// NETWORK END  ///////////////////////////

-- /////////////////////// LAYER START ///////////////////////////
layer_net = { -- start
	name = 'layer_net',
	layer = nil,

	cleanup = function(self)
		self.layer = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = LayerSocket:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_NET, self.handler, true);

		self.layer:registerLuaNetHandler(self.net_handler);

		return self.layer, self.name;
	end,

	net_handler = function(cmd)
		if nil == cmd then
			return;
		end
		net_listener(cmd);
	end,

	handler = function(event, x, y)
		local self = layer_net;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
			--util.reg_net(self.layer, self.net_handler);
		elseif "exit" == event then
			--util.unreg_net(self.layer);
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function (self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)

	end,
} -- layer_net end

layer_touch = { -- start
	name = 'layer_touch',
	layer = nil,
	mark_x = 32,
	mark_y = 120,
	btn_debug = nil,
	touch_debug = nil,

	cleanup = function(self)
		self.layer = nil;
		self.btn_debug = nil;
		self.touch_debug = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_TOUCH, self.handler, false);

		if true == DEBUG_MODE then
			self:add_debug();
		end

		return self.layer, self.name;
	end,

	add_debug = function(self)
		if nil == self.layer then
			return;
		end
		local fullpath, pos, sprite;

		fullpath = util.get_fullpath(F_IMAGE, 'icon_debug.png');
		pos = ccp(self.mark_x, self.mark_y);
		sprite = util.add_sprite(self.layer, fullpath, pos, ANCHOR_CENTER_CENTER);
		self.btn_debug = sprite;
	end,

	handler = function(event, x, y)
		local self = layer_touch;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		--kdebug("layer_touch[%f][%f]", x, y);
		self.touch_debug = nil;
		if nil == self.btn_debug then
			return;
		end
		local dx, dy = self.btn_debug:getPosition();
		if math.abs(x-dx) < 40 and math.abs(y-dy) < 40 then
			self.touch_debug = { dx = dx, dy = dy, has_move = false };
		end
		return true;
	end,

	onTouchMoved = function(self, x, y)
		if nil == self.touch_debug then
			return;
		end
		local dx = self.touch_debug.dx;
		local dy = self.touch_debug.dy;
		if math.abs(x-dx) > 40 or math.abs(y-dy) > 40 then
			self.touch_debug.has_move = true;
			self.btn_debug:setPosition(cc.p(x, y));
		end
	end,

	onTouchEnded = function(self, x, y)
		if nil == self.touch_debug then
			return;
		end
		local dx = self.touch_debug.dx;
		local dy = self.touch_debug.dy;
		local has_move = self.touch_debug.has_move;
		self.touch_debug = nil;
		if true == has_move then
			local nx, ny;
			if x > HALF_WIDTH then
				nx = FULL_WIDTH - 32;
			else
				nx = 32;
			end
			if y < 32 then
				ny = 32;
			elseif y > FULL_HEIGHT - 32 then
				ny = FULL_HEIGHT - 32;
			else
				ny = y;
			end
			self.btn_debug:runAction(cc.MoveTo:create(0.1, cc.p(nx, ny)));
			self.mark_x = nx;
			self.mark_y = ny;
			return;
		end
		self.btn_debug:runAction(cc.MoveTo:create(0.1, cc.p(dx, dy)));
		self.mark_x = dx;
		self.mark_y = dy;
		g_scene:add_layer(ZORDER_LAYER_DEBUG, layer_debug:create());
	end,
} -- layer_touch end

layer_msg = {
	name = 'layer_msg',
	layer = nil,
	callback = nil,

	cleanup = function(self)
		self.layer = nil;
		self.callback = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, msg, cb, size)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_MSG, self.handler, true);

		self.callback = cb;
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 200));

		local path = util.get_path('pop_up.png');
		local frect = cc.rect(0, 0, 64, 64); -- fullrect
		local irect = cc.rect(30, 30, 4, 4); -- insetrect
		size = size or cc.size(wfix(505), hfix(302));--realsize
		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		local bg = util.add_scale9sprite(self.layer, path, pos, ANCHOR_CENTER_CENTER, frect, irect, size, 10); 

    	if nil ~= msg then
			pos = cc.p(size.width/2, size.height-50);
			local lsize = cc.size(size.width-40, size.height - 80 - 100);
			util.add_labeloutline(bg, msg, nil, 25, pos, util.c4b_white, util.c4b_black, 1, ANCHOR_CENTER_UP, 1, lsize, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_TOP);
    	end

		local items = {};
		local item, p1, p2;

		pos = ccp(size.width/2, hfix(28));
		add_item_1(items, '确定',nil,30,self.action,ANCHOR_CENTER_DOWN,pos);

		util.add_menu(bg, items, 1);

		return self.layer, self.name;
	end,

	back = function()
		local self = layer_msg;
		self:remove();
	end,

	action = function()
		local self = layer_msg;
		local cb = layer_msg.callback;
		self.back();
		if nil ~= cb then
			cb();
		end
	end,

	handler = function(event, x, y)
		local self = layer_msg;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
	end,
} -- layer_msg end

layer_text = {
	name = 'layer_text',
	layer = nil,

	cleanup = function(self)
		self.layer = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, title, text)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_TEXT, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 50));

		local bgsize = cc.size(wfix(600), hfix(900));
		local bg, rect = init_bg_for_popview(self.layer,title,bgsize,self.back);
		local pos = cc.p(20, 10);
		local size = cc.size(bgsize.width-40, bgsize.height-10-110);
		util.add_labelttf(bg, text, nil, 25, pos, util.c4b_white, ANCHOR_LEFT_DOWN, 40, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_TOP);

		return self.layer, self.name;
	end,

	back = function()
		local self = layer_text;
		self:remove();
	end,

	action = function()
		local self = layer_text;
		self.back();
	end,

	handler = function(event, x, y)
		local self = layer_text;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
	end,
} -- layer_text end

layer_cserver = { -- start
	name = 'layer_cserver',
	layer = nil,
	list = nil,
	cwidth = nil,
	cheight = nil,
	rect = nil,
	callback = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.rect = nil;
		self.callback = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, list, cb)	
		self:remove();

		self.list = list or {};
		self.callback = cb;
		self.layer = cc.Layer:create();

		util.add_layer_color(self.layer, cc.c4b(0, 0, 0, 128), 0);

		util.reg_handler(self.layer, -ZORDER_LAYER_CSERVER, self.handler, true);

		self.cheight = 100;
		local theight = self.cheight * #self.list;
		theight = theight > (FULL_HEIGHT/4*3) and (FULL_HEIGHT/4*3) or theight;
		theight = theight < self.cheight and self.cheight or theight;

		local fullrect = cc.rect(0, 0, 64, 54);
		local insetrect = cc.rect(30, 25, 4, 4);
		local size = cc.size(FULL_WIDTH-50, theight);
		local pos = cc.p((FULL_WIDTH-size.width)/2, (FULL_HEIGHT-size.height)/2);
		local path = util.get_path('title_popup.png');

		util.add_scale9sprite(self.layer, path, pos, ANCHOR_LEFT_DOWN, fullrect, insetrect, size, 1); 
		self.rect = cc.rect(pos.x, pos.y, size.width, size.height);

		self.cwidth = size.width;
		local tsize = cc.size(size.width-10, size.height-10);
		pos = cc.p((FULL_WIDTH-tsize.width)/2, (FULL_HEIGHT-tsize.height)/2);
		util.add_tableview(self.layer, tsize, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, 10);

		return self.layer, self.name;
	end,

	close = function(self)
		play_tap_1();
		self:remove();
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_cserver;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			if nil ~= self.callback then
				self.callback(idx + 1);
			end
			self:close();
			return 0;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local info = self.list[idx + 1];
			local height = self.cheight;
			local width = self.cwidth;
			local name = info.name;
			local state = info.state;
			local str = string.format("%s [ %s ]", name, state);
			local pos = ccp(width/2, height/2);
			util.add_label(cell, str, 30, pos, util.c_white,ANCHOR_CENTER_CENTER);

			local path = util.get_path('line_1.png');
			pos = ccp(width/2, 0);
			local line = util.add_sprite(cell, path, pos, ANCHOR_CENTER_DOWN);
			line:setScaleX((width-40)/line:getContentSize().width);
			return cell;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_cserver;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.close();
		end
	end,

	onTouchBegan = function(self, x, y)
		local r = self.rect;
		if nil == r or x < r.x or x > r.x+r.width or y < r.y or y > r.y+r.height then
			self:close();
		end
		return true;
	end,

	onTouchMoved = function(self, x, y)		

	end,

	onTouchEnded = function(self, x, y)	
	end,
} -- layer_cserver end

layer_more = {
	name = 'layer_more',
	layer = nil,
	rect = nil,
	cwidth = nil,
	cheight = nil,
	tableview = nil,
	list = nil,
	callback = nil,
	callback_delete = nil,

	cleanup = function(self)
		self.layer = nil;
		self.tableview = nil;
		self.rect = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.list = nil;
		self.callback = nil;
		self.callback_delete = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, mtype, list, bpos, bsize, cb, cb2)
		self:remove();

		list = list or {};
		self.callback = cb;
		self.callback_delete = cb2;
		self.list = list;
		self.layer = cc.Layer:create();
		
		util.reg_handler(self.layer, -ZORDER_LAYER_MORE, self.handler, true);

		util.add_layer_color(self.layer, cc.c4b(0, 0, 0, 128), 0);

		self.cheight = 100;
		local theight = self.cheight * #self.list;
		theight = theight > (FULL_HEIGHT/4*3) and (FULL_HEIGHT/4*3) or theight;
		theight = theight < self.cheight and self.cheight or theight;

		local fullrect = cc.rect(0, 0, 64, 54);
		local insetrect = cc.rect(30, 25, 4, 4);
		local size = cc.size(FULL_WIDTH-50, theight);
		local pos = cc.p((FULL_WIDTH-size.width)/2, (FULL_HEIGHT-size.height)/2);
		local path = util.get_path('text_box.png');

		util.add_scale9sprite(self.layer, path, pos, ANCHOR_LEFT_DOWN, fullrect, insetrect, size, 1); 
		self.rect = cc.rect(pos.x, pos.y, size.width, size.height);

		self.cwidth = size.width;
		local tsize = cc.size(size.width-10, size.height-10);
		pos = cc.p((FULL_WIDTH-tsize.width)/2, (FULL_HEIGHT-tsize.height)/2);
		util.add_tableview(self.layer, tsize, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, 10);

		return self.layer, self.name;
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_more;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			self:choose(idx+1);
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local name = self.list[idx + 1];
			
			local width = self.cwidth;
			local height = self.cheight;
			local pos = ccp(50, height/2);
			local label = util.add_label(cell, name, 30, pos, util.c_white, ANCHOR_LEFT_CENTER, nil, cc.size(width, height), cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
			local path = util.get_path('line_1.png');
			pos = ccp(width/2, 0);
			local line = util.add_sprite(cell, path, pos, ANCHOR_CENTER_DOWN);
			line:setScaleX((width-40)/line:getContentSize().width);

			local items = {};
			local item;

			local fname =util.get_fullpath(F_IMAGE,'btn_2.png');
			pos = ccp(width-80, height/2);
			item = util.create_item_image(fname, fname, pos, ANCHOR_LEFT_CENTER, self.delete);
			item:setTag(idx+1);
			table.insert(items, item);

			util.add_menu(cell, items, 1);
			return cell;
		end
	end, -- tableview_handler end }

	choose = function(self, index)
		local str = self.list[index];
		self.callback(str, index);
		self:remove();
	end,

	delete = function(...)
		local self = layer_more;
		if nil == self.callback_delete then
			return;
		end
		local arg = { ... };
		local item = arg[2];
		local index = item:getTag();
		self.callback_delete(index);
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_more;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self:remove();
		end
	end,

	onTouchBegan = function(self, x, y)
		local r = self.rect;
		if nil == r or x < r.x or x > r.x+r.width or y < r.y or y > r.y+r.height then
			self:remove();
		end
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
	end,

} -- layer_more end

layer_login = { -- start
	name = 'layer_login',
	layer = nil,
	username = '',
	password = '',
	toggle_info = nil,
	server_list = nil,
	ip_addr = '',
	btn_cserver = nil,
	is_changed = nil,

	cleanup = function(self)
		self.layer = nil;
		self.username = nil;
		self.password = nil;
		self.toggle_info = nil;
		self.server_list = nil;
		self.ip_addr = nil;
		self.btn_cserver = nil;
		self.is_changed = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_LOGIN, self.handler, true);

		if is_ver(VER_ANYSDK) or is_ver(VER_LJSDK) or is_ver(VER_UCSDK) then
			self:init_for_anysdk();
		else
			self:init_normal();
		end

		return self.layer, self.name;
	end,

	init_normal = function(self)
		self.is_changed = false;
		local data, pos, sprite, size;
		--sprite,data = gui_add_sprite(self.layer, 'board', GUI_LOGIN);
		sprite,data = gui_add_sprite(self.layer, 'bg', GUI_LOGIN);
		if data.width/data.rwidth > data.height/data.rheight then
			sprite:setScale(data.width/data.rwidth);
		else
			sprite:setScale(data.height/data.rheight);
		end
		--sprite, data = gui_add_sprite(self.layer, 'wolf', GUI_LOGIN, ANCHOR_DOWN);
		--self:wolf_effect(data, sprite);
		sprite, data = gui_add_sprite(self.layer, 'fire', GUI_LOGIN, ANCHOR_DOWN);
		sprite, data = gui_add_sprite(self.layer, 'logo', GUI_LOGIN, ANCHOR_UP);
		sprite, data = gui_add_sprite(self.layer, 'frame', GUI_LOGIN, ANCHOR_UP);
		--gui_add_label(self.layer, '登录', 30, 'title', GUI_LOGIN, ANCHOR_UP);
		gui_add_stroke(self.layer,'登录',30,'title',GUI_LOGIN, ANCHOR_UP);

		str = t_lang("USERNAME");
		--gui_add_label(self.layer, str, 30, 't_uname', GUI_LOGIN, ANCHOR_UP);
		gui_add_stroke(self.layer,str,30,'t_uname',GUI_LOGIN, ANCHOR_UP);
		gui_add_sprite(self.layer, 'bg_uname', GUI_LOGIN, ANCHOR_UP);
		gui_add_sprite(self.layer,'bg2_uname',GUI_LOGIN,ANCHOR_UP);

		str = t_lang("PASSWORD");
		--gui_add_label(self.layer, str, 30, 't_pw', GUI_LOGIN, ANCHOR_UP);
		gui_add_stroke(self.layer,str,30,'t_pw',GUI_LOGIN, ANCHOR_UP);
		gui_add_sprite(self.layer, 'bg_pw', GUI_LOGIN, ANCHOR_UP);
		gui_add_sprite(self.layer, 'bg2_pw', GUI_LOGIN, ANCHOR_UP);

		local color;
		data = gui_get_data('uname', GUI_LOGIN, ANCHOR_UP);
		color = cc.c3b(data.r, data.g, data.b);
		-- editbox username
		pos = ccp(data.x, data.y);
		size = cc.size(data.width, data.height);
		self.username = util.add_editbox_blank(self.layer, size, 
			ANCHOR_LEFT_DOWN, pos, util.f_default, 22, color, 
			cc.EDITBOX_INPUT_MODE_SINGLELINE, cc.KEYBOARD_RETURNTYPE_DONE, 
			nil, self.editbox_handler, 30, t_lang("LOG_TIP_UNAME"), util.c_gray, 
			data.zorder);
		local has_u = false;
		local u = util.load_rms('username', 'string');
		if nil ~= u and '' ~= u then
			self.username:setText(u);
			has_u = true;
		end

		-- editbox password
		data = gui_get_data('pw', GUI_LOGIN, ANCHOR_UP);
		color = cc.c3b(data.r, data.g, data.b);
		pos = ccp(data.x, data.y);
		size = cc.size(data.width, data.height);
		self.password = util.add_editbox_blank(self.layer, size, ANCHOR_LEFT_DOWN,
			pos, util.f_default, 22,color,cc.EDITBOX_INPUT_MODE_SINGLELINE,
			cc.KEYBOARD_RETURNTYPE_DONE, cc.EDITBOX_INPUT_FLAG_PASSWORD, 
			self.editbox_handler,30,t_lang("LOG_TIP_PW"),util.c_gray,data.zorder);
		-- TODO fix samsung, do not use kEditBoxInputFlagPassword, 
		-- also: use kEditBoxInputModeSingleLine (so that ENTER button not work)

		local has_p = false;
		local p = util.load_rms('password', 'string');
		if nil ~= p and '' ~= p then
			self.password:setText(p);
			has_p = true;
		end

		str = t_lang("LOG_TIP_SAVE");
		gui_add_label(self.layer, str, 25, 'tip_save', GUI_LOGIN, ANCHOR_UP);

		local items = {};
		local item;

		-- self.toggle_info:getSelectedIndex()  0 : off     1 : on
		item, data = gui_add_item(items, 'toggle', GUI_LOGIN, self.callback_save_info, ANCHOR_UP);
		self.toggle_info = item;
		-- if has_u == false , it means first run this app, so should set toggle
		-- then app will remember username every time
		if false == has_u or true == has_p then
			self.toggle_info:setSelectedIndex(1);
		end

		item,data = gui_add_item(items,'login',GUI_LOGIN,self.cb_login,ANCHOR_UP);
		gui_add_text_on_sprite(item, "登录", 't_login', GUI_LOGIN, ANCHOR_UP, 30);
		
		item,data =gui_add_item(items,'reg',GUI_LOGIN,self.cb_reg,ANCHOR_UP);
		gui_add_text_on_sprite(item, "注册", 't_reg', GUI_LOGIN, ANCHOR_UP, 30);

		item,data = gui_add_item(items,'more',GUI_LOGIN,self.user_list,ANCHOR_UP);

		-- ip info start
		self.server_list = util.load_server();
		local ipstr = util.get_server_name(self.server_list, IP_ADDR);
		item,data=gui_add_item(items,'server',GUI_LOGIN,self.cb_cserver,ANCHOR_UP);
		gui_add_text_on_sprite(item, ipstr, 't_server', GUI_LOGIN, ANCHOR_UP, 30);
		self.btn_cserver = item;
		--local ns = item:getNormalImage();
		--ns:setBlendFunc(gl.DST_COLOR, gl.ONE);
		--local ss = item:getSelectedImage();
		--ss:setBlendFunc(gl.DST_COLOR, gl.ONE);

		util.add_menu(self.layer, items, data.zorder);

		pos = cc.p(0, 0);
		str = get_client_version();
		print('        =========client version : ', str);
		util.add_labelttf(self.layer, str, nil, 30, pos, util.c4b_white, ANCHOR_LEFT_DOWN, 100);
	end,

	init_for_anysdk = function(self)
		self.is_changed = false;
		local data, pos, sprite, size;
		--sprite,data = gui_add_sprite(self.layer, 'board', GUI_LOGIN);
		sprite,data = gui_add_sprite(self.layer, 'bg', GUI_LOGIN);
		if data.width/data.rwidth > data.height/data.rheight then
			sprite:setScale(data.width/data.rwidth);
		else
			sprite:setScale(data.height/data.rheight);
		end
		--sprite, data = gui_add_sprite(self.layer, 'wolf', GUI_LOGIN, ANCHOR_DOWN);
		--self:wolf_effect(data, sprite);
		sprite, data = gui_add_sprite(self.layer, 'fire', GUI_LOGIN, ANCHOR_DOWN);
		sprite, data = gui_add_sprite(self.layer, 'logo', GUI_LOGIN, ANCHOR_UP);
		sprite, data = gui_add_sprite(self.layer, 'frame', GUI_LOGIN, ANCHOR_UP);
		--gui_add_label(self.layer, '登录', 30, 'title', GUI_LOGIN, ANCHOR_UP);
		gui_add_stroke(self.layer,'登录',30,'title',GUI_LOGIN,ANCHOR_UP);

		local items = {};
		local item;

		item,data = gui_add_item(items,'login',GUI_LOGIN,self.cb_login,ANCHOR_UP);
		item:setPositionX(HALF_WIDTH);
		item:setAnchorPoint(ANCHOR_CENTER_DOWN);
		gui_add_text_on_sprite(item, "登录", 't_login', GUI_LOGIN, ANCHOR_UP, 30);
		
		--[[
		item,data =gui_add_item(items,'reg',GUI_LOGIN,self.cb_reg,ANCHOR_UP);
		gui_add_text_on_sprite(item, "注册", 't_reg', GUI_LOGIN, ANCHOR_UP, 30);
		]]--

		-- ip info start
		self.server_list = util.load_server();
		local ipstr = util.get_server_name(self.server_list, IP_ADDR);
		item,data=gui_add_item(items,'server',GUI_LOGIN,self.cb_cserver,ANCHOR_UP);
		gui_add_text_on_sprite(item, ipstr, 't_server', GUI_LOGIN, ANCHOR_UP, 30);
		self.btn_cserver = item;
		--local ns = item:getNormalImage();
		--ns:setBlendFunc(gl.DST_COLOR, gl.ONE);
		--local ss = item:getSelectedImage();
		--ss:setBlendFunc(gl.DST_COLOR, gl.ONE);

		util.add_menu(self.layer, items, data.zorder);

		pos = cc.p(0, 0);
		str = get_client_version();
		print('        =========client version : ', str);
		util.add_labelttf(self.layer, str, nil, 30, pos, util.c4b_white, ANCHOR_LEFT_DOWN, 100);
	end,

	wolf_effect = function(self, data, sprite)
		local action, array;
		array = {};
		action = CCMoveBy:create(5, ccp(0, -hfix(13)));
		table.insert(array, action);
		action = action:reverse();
		table.insert(array, action);
		action = CCSequence:create(array);
		action = CCRepeatForever:create(action);
		sprite:runAction(action);

		local fullpath = util.get_fullpath(F_PARTICLE, 'wolf_smoke.plist');
		util.add_particle(self.layer, fullpath, ccp(HALF_WIDTH, hfix(60)), data.zorder+2);
	end,

	restart = function()
		layer_main.delete();
		util.save_rms('ip_addr', IP_ADDR, 'string');
		g_scene:main();
		--sanbox_test(10); -- not work
	end,

	change_server = function(index)
		local self = layer_login;
		local list = self.server_list or {};
		local info = list[index];
		if nil == info then
			return;
		end
		local item = self.btn_cserver;
		if nil == item then
			return;
		end
		local ip = info.ip;
		local ipstr = util.get_server_name(list, ip);
		util.add_text_to_sprite(item, ipstr, 30, util.c_white);
		if true == g_scene:is_online() then
			g_scene:close_connect();
		end
		IP_ADDR = ip;
		self.is_changed = true;
		self:check_ip();
	end,

	cb_cserver = function()
		play_tap_1();
		local self = layer_login;
		local list = self.server_list or {};
		local cb = self.change_server;
		g_scene:add_layer(ZORDER_LAYER_CSERVER, layer_cserver:create(list, cb));
	end,

	save_ip = function(self)
		util.save_rms('ip_addr', IP_ADDR, 'string');
	end,

	check_ip = function(self)
		local ip = util.load_rms('ip_addr', 'string') or '';
		print('ip, IP: ', ip, IP_ADDR);
		if true == self.is_changed and IP_ADDR ~= ip then
			self:save_ip();
			util.save_rms('re_update_lua', 'yes', 'string');
			util.save_rms(KEY_PATCH_INDEX, CLIENT_PATCH, 'integer');
			util.relaunch_game();
			return false;
		end
		return true;
	end,

	editbox_handler = function(eventname, psender)
		local self = layer_login;
		local edit = tolua.cast(psender, "cc.EditBox");
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
			--str = string.format("editbox %p was returned !",edit)
			--print('DEBUG ', str);
			--[[
			if self.username == edit then
				local s = edit:getText();
				if nil == s or '' == s then
					edit:setPlaceHolder('username');
				end
			elseif self.password == eidt then
				local s = edit:getText();
				if nil == s or '' == s then
					edit:setPlaceHolder('password');
				end
			end
			]]--
			if edit == self.username and nil ~= self.password then
				--self.password:sendActionsForControlEvents(cc.CONTROL_EVENTTYPE_TOUCH_UP_INSIDE);
			end
		elseif eventname == "changed" then
		end

	end,

	user_list = function(...)
		play_tap_1();
		local self = layer_login;
		local arg = { ... };
		local item = arg[2];
		local pos = ccp(item:getPositionX(), item:getPositionY());
		local size = item:getContentSize();
		local str_list = util.load_rms('user_list', 'string');
		local list = split_string(str_list);
		g_scene:add_layer(ZORDER_LAYER_MORE, layer_more:create('username', list, pos, size, self.callback_user, self.callback_del_user));
	end,

	callback_del_user = function(index)
		local self = layer_login;
		local str_list = util.load_rms('user_list', 'string');
		local list = split_string(str_list);
		local username = list[index];
		table.remove(list, index);
		local n_str = '';
		for i = 1, #list do
			n_str = list[i] .. ' ' .. n_str;
		end
		util.save_rms('user_list', n_str, 'string');
		util.remove_rms('username');
		if 0 == #list then
			self.username:setText('');
			self.password:setText('');
			self.toggle_info:setSelectedIndex(1);
		end
		if self.username:getText() == username then
			self.callback_user(username, 1);
		end
	end,

	callback_user = function(str, index)
		local self = layer_login;
		local str_list = util.load_rms('user_list', 'string');
		local list = split_string(str_list);
		local username = list[index];
		if nil == username or '' == username then
			return;
		end
		local password = util.load_rms(username, 'string');
		self.username:setText(username);
		if nil == password or '' == password then
			password = '';
		else
			self.toggle_info:setSelectedIndex(1);
		end
		self.password:setText(password);
	end,

	save_info = function(self)
		play_tap_3();
		local username = g_euser.username;
		--local username = self.username:getText();
		local u = util.load_rms('username', 'string');
		if nil ~= u and '' ~= u and u ~= username then
			-- clean chat msg
			g_chat_list = {
				[C_ALL] = {},
				[C_WORLD] = {},
				[C_ROOM] = {},
				[C_GUILD] = {},
				[C_PRIVATE] = {},
				[C_LOG] = {},
			};
		end
		if is_ver(VER_ANYSDK) or is_ver(VER_LJSDK) or is_ver(VER_UCSDK) then
			util.save_rms('username', username, 'string');
			local password = g_euser.password;
			util.save_rms('password', password, 'string');
		else
			local toggle_index = self.toggle_info:getSelectedIndex();
			--print('selected item: index:%d', toggle_index);
			util.save_rms('username', username, 'string');
			local password = self.password:getText();
			--print('DBEUG username, password: ', username, password);
			if 1 == toggle_index then
				util.save_rms('password', password, 'string');
			end
		end
		-- TODO need optimize
		local str_list = util.load_rms('user_list', 'string');
		--print(' ----- str_list ', str_list);
		local list = split_string(str_list);
		if 0 == #list then
			str_list = username .. ' ';
		else
			local ishas = false;
			for i = 1, #list do
				if username == list[i] then
					ishas = true;
				end
			end
			if false == ishas then
				str_list = username .. ' ' .. str_list;
			end
		end
		util.save_rms('user_list', str_list, 'string');
		if 1 == toggle_index then
			util.save_rms(username, password, 'string');
		end
	end,

	cb_login_for_anysdk = function(self, username, password)
		self:save_ip();
		local ret;
		--print('-2-- u, p: ', username, password);
		ret = g_scene:connect_to_net();
		if ret <= 0 then
			return;
		end
		--print('-3-- u, p: ', username, password);
		g_euser.username = username;
		g_euser.password = password;
		net_cmd_log(username, password);
	end,

	cb_login_for_ljsdk = function(event)
		print("cb_login_for_ljsdk");
		show_msg(event);
	end,

	cb_login_for_ucsdk = function(self, username, password)
		self:save_ip();
		local ret;
		ret = g_scene:connect_to_net();
		if ret <= 0 then
			return;
		end
		g_euser.username = username;
		g_euser.password = password;
		net_cmd_log(username, password);
	end,

	cb_login = function()
		play_tap_1();
		LOCAL_TEST = false;
		local self = layer_login;
		if is_ver(VER_LJSDK) then
			--LJSdkImpl:setUserListener(self.layer, self.cb_login_for_ljsdk);
			if nil ~= layer_net.layer then
				LJSdkImpl:setUserListener(layer_net.layer);
				LJSdkImpl:login("login");
			end
			return;
		end
		if is_ver(VER_UCSDK) then
			UCSdkHandler:login();
			return;
		end
		if is_ver(VER_ANYSDK) then
			local user = AgentManager:getInstance():getUserPlugin();
			if nil == user then
				show_msg("any sdk getUserPlugin is nil");
				return;
			end
			if false == g_anysdk_init_action then
				user:setActionListener(anysdk_action_result);
			end
			user:login();
			show_netloading();
			return;
		end
		--[[ do in change_server
		if false == self:check_ip() then
			return;
		end
		]]--
		self:save_ip();
		--print('DEBUG callback_login');
		-- self.toggle_info:getSelectedIndex()  0 : off     1 : on
		local toggle_index = self.toggle_info:getSelectedIndex();
		local username = self.username:getText();
		local password = self.password:getText();
		if 0 == toggle_index then
			util.remove_rms('password');
		end
		if nil == username or '' == string.gsub(username, "^%s*(.-)%s*$", "%1") then
			g_scene:add_layer(ZORDER_LAYER_MSG, layer_msg:create('ERROR 请填写用户名'));
			return;
		end
		if nil == password or '' == string.gsub(password, "^%s*(.-)%s*$", "%1") then
			g_scene:add_layer(ZORDER_LAYER_MSG, layer_msg:create('ERROR 请填写密码'));
			return;
		end
		local ret;
		ret = g_scene:connect_to_net();
		if ret <= 0 then
			return;
		end
		g_euser.username = username;
		net_cmd_log(username, password);
	end,

	cb_reg = function()
		play_tap_1();
		local self = layer_login;
		if false == self:check_ip() then
			return;
		end
		self:save_ip();
		g_scene:add_layer(ZORDER_LAYER_REGISTER, layer_register:create());
	end,

	callback_save_info = function(tag, sender)
		play_tap_2();
		--print('DEBUG callback_save_info');
		-- self.toggle_info:getSelectedIndex()  0 : off     1 : on
		--print('selected item: tag: %d, index:%d', tag, tolua.cast(sender, "cc.MenuItemToggle"):getSelectedIndex());
	end,
	
	handler = function(event, x, y)
		local self = layer_login;

		if "began" == event then   
			kdebug("touch login %f %f", x, y);
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
			util.free_ram();
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			if nil ~= layer_register.layer then
				layer_register.close();
				return;
			end
			local s = '是否要退出游戏';
			if is_ver(VER_UCSDK) then
				UCSdkHandler:destroyFloatButton();
				UCSdkHandler:exitSDK();
			elseif is_ver(VER_LJSDK) then
				LJSdkImpl:exit(layer_net.layer);
			else
				g_scene:add_layer(ZORDER_LAYER_TIP,layer_tip:create(s,exit_game));
			end
		end
	end,

	onTouchBegan = function (self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)

	end,

} -- layer_login end

layer_map = { -- start    
	name = 'layer_map',
	layer = nil,
	btn_pve = nil,
	btn_lottery = nil,
	btn_deck = nil,

	cleanup = function(self)
		self.layer = nil;
		self.btn_pve = nil;
		self.btn_lottery = nil;
		self.btn_deck = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();
		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_MAP, self.handler, true);

		--self:add_color_layer();
		local pos, sprite, data, scale;

		gui_add_sprite(self.layer, 'board', GUI_MAIN);
		--gui_add_sprite(self.layer, 'light_bottom', GUI_MAIN, ANCHOR_DOWN);
		gui_add_sprite(self.layer,'bg_bottom',GUI_MAIN,ANCHOR_DOWN);
		sprite,data = gui_add_sprite(self.layer, 'bg', GUI_MAIN);
		if data.width/data.rwidth > data.height/data.rheight then
			sprite:setScale(data.width/data.rwidth);
		else
			sprite:setScale(data.height/data.rheight);
		end

		sprite = gui_add_sprite(self.layer, 'bg_main', GUI_MAIN, ANCHOR_DOWN);

		local list = {
			{ key = 'quick', title = '对战', tag = 1, limit = 2 }, -- 对战
			{ key = 'pve', title = '闯关', tag = 2, limit = 1 }, -- 练习
			{ key = 'room', title = '观战', tag = 3, limit = 1 }, -- 竞技
			{ key = 'friend', title = '好友', tag = 4, limit = 1 }, -- 好友
			{ key = 'deck', title = '牌堆', tag = 5, limit = 1 }, -- 牌堆
			{ key = 'shop', title = '抽卡', tag = 6, limit = 1 }, -- 商店
		};
		local items = {};
		local item, data;

		for i = 1, #list do
			local info = list[i];
			local key = 'bg_' .. info.key;
			local tag = info.tag;
			local limit = info.limit;
			item,data=gui_add_item(items,key,GUI_MAIN,self.callback_tap,ANCHOR_DOWN);
			item:setTag(tag);
			local cpos = cc.p(data.width/2, data.height/2);
			if true ~= DEBUG_MODE and g_euser.level < limit then
				--local path = util.get_fullpath(F_IMAGE, 'icon_lock.png');
				local path = util.get_path('icon_2.png');
				--util.change_item_image(item, path, path);
				util.add_sprite(item, path, cpos, ANCHOR_CENTER_CENTER, 20);
				item:registerScriptTapHandler(self.not_enough_level);
				item:setTag(limit);
			else
				local k = 'icon_' .. info.key;
				local d = gui_get_data(k, GUI_MAIN, ANCHOR_DOWN);
				local path = util.get_path(d.fname1);
				util.add_sprite(item, path, cpos, ANCHOR_CENTER_CENTER, 20);
			end
			local tkey = 'text_' .. info.key;
			local td, tscale = gui_get_data(tkey, GUI_MAIN, ANCHOR_DOWN);
			local tpos = cc.p(data.width/2, 0);
			local color = cc.c4b(td.r, td.g, td.b, 255);
			local scolor = cc.c4b(td.sr, td.sg, td.sb, 255);
			local label = util.add_labeloutline(item, info.title, nil, 25, tpos, color, scolor, 2, ANCHOR_CENTER_CENTER, 30);
			label:setScale(tscale);

			if 2 == tag then
				self.btn_pve = item;
			elseif 5 == tag then
				self.btn_deck = item;
			elseif 6 == tag then
				self.btn_lottery = item;
			end

			--[[
			local scale = item:getScaleY();
			local t, s1, s2;
			t = 'label_' .. string.sub(data.fname1, 6, string.len(data.fname1)); 
			local path1 = util.get_fullpath(F_IMAGE, t);
			t = 'label_' .. string.sub(data.fname2, 6, string.len(data.fname2)); 
			local path2 = util.get_fullpath(F_IMAGE, t);
			s1, s2 = util.add_item_label_image(item, path1, path2);
			s1:setPosition(cc.p(data.width/2, scale*12));
			s1:setAnchorPoint(ANCHOR_CENTER_DOWN);
			s2:setPosition(cc.p(data.width/2, scale*12));
			s2:setAnchorPoint(ANCHOR_CENTER_DOWN);
			]]--
		end

		util.add_menu(self.layer, items, data.zorder);

		return self.layer, self.name;

	end,

	add_color_layer = function(self)
		local fullrect = cc.rect(0, 0, 64, 64);
		local insetrect = cc.rect(6, 6, 52, 52);
		local realsize = cc.size(FULL_WIDTH, FULL_HEIGHT);
		local pos = cc.p(0, 0);
		local fullpath = util.get_fullpath(F_IMAGE, 'bg_main_color.png');

		util.add_scale9sprite(self.layer, fullpath, pos, ANCHOR_LEFT_DOWN, fullrect, insetrect, realsize, 0); 

		fullpath = util.get_fullpath(F_PARTICLE, 'bg_main.plist');
		pos = ccp(HALF_WIDTH, HALF_HEIGHT);
		util.add_particle(self.layer, fullpath, pos, 2);
	end,

	not_enough_level = function(...)
		local args = {...};
		local index = args[2]:getTag();
		show_msg(index .. '级开启');
	end,

	callback_tap = function(...)
		local self = layer_map;
		play_tap_3();
		local args = {...};
		local index = args[2]:getTag();
		if 1 == index then
			show_service();
		elseif 2 == index then
			show_gate();
		elseif 3 == index then
			local layer, name = layer_lroom:create();
			g_scene:add_layer(ZORDER_LAYER_LROOM, layer, name, true);
			net_send('lchan', true);
		elseif 4 == index then
			get_friend_list();
		elseif 5 == index then
			g_scene:deck();
		elseif 6 == index then
			--g_scene:shop();
			show_lottery();
		end
	end,

	handler = function(event, x, y)
		local self = layer_map;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
			util.free_ram();
			-- kelton: int win32, cannot add a loading view while onEnter
			net_send('sta', true);
			util.upload_tutor();
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			if nil ~= layer_quick.layer then
				layer_quick.callback_return();
				return;
			end
			if nil ~= layer_solo.layer then
				layer_solo.callback_return();
				return;
			end
			if nil ~= layer_lock.layer then
				layer_lock.close();
				return;
			end
			if nil ~= layer_lroom.layer then
				layer_lroom.callback_return();
				return;
			end
			if nil ~= layer_findfrd.layer then
				layer_findfrd:remove();
				return;
			end
			if nil ~= layer_friend.layer then
				layer_friend.callback_return();
				return;
			end
--			local s = '是否要登出';
--			g_scene:add_layer(ZORDER_LAYER_TIP,layer_tip:create(s, logout));
			local s = '是否要退出游戏';
			if is_ver(VER_UCSDK) then
				UCSdkHandler:destroyFloatButton();
				UCSdkHandler:exitSDK();
			elseif is_ver(VER_LJSDK) then
				LJSdkImpl:exit(layer_net.layer);
			else
				g_scene:add_layer(ZORDER_LAYER_TIP,layer_tip:create(s,exit_game));
			end
		end
	end,

	onTouchBegan = function (self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
	end,
	
	onTouchEnded = function(self, x, y)

	end,

} -- layer_map end

layer_infobar = { -- start
	name = 'layer_infobar',
	layer = nil,
	label_gold = nil,
	label_crystal = nil,
	btn_back = nil,

	cleanup = function(self)
		self.layer = nil;
		self.label_gold = nil;
		self.label_crystal = nil;
		self.btn_back = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();
		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_INFOBAR, self.handler, false);

		local fullpath, sprite, str, pos, data;
		gui_add_sprite(self.layer, 'bg_infobar', GUI_MAIN, ANCHOR_UP);
		gui_add_sprite(self.layer, 'frame_gold', GUI_MAIN, ANCHOR_UP);
		gui_add_sprite(self.layer, 'frame_crystal', GUI_MAIN, ANCHOR_UP);
		gui_add_sprite(self.layer, 'icon_gold', GUI_MAIN, ANCHOR_UP);
		gui_add_sprite(self.layer, 'icon_crystal', GUI_MAIN, ANCHOR_UP);

		str = g_euser.gold;
		self.label_gold = gui_add_label(self.layer, str, 18, 'num_gold', GUI_MAIN, ANCHOR_UP);
		--self.label_gold = gui_add_labeloutline(self.layer, str, 25, util.c4b_gold, util.c4b_black, 2, 'num_gold', GUI_MAIN, ANCHOR_UP);

		str = g_euser.crystal;
		self.label_crystal = gui_add_label(self.layer, str, 18, 'num_crystal', GUI_MAIN, ANCHOR_UP);
		--self.label_crystal = gui_add_labeloutline(self.layer, str, 25, util.c4b_crystal, util.c4b_black, 2, 'num_crystal', GUI_MAIN, ANCHOR_UP);

		return self.layer, self.name;

	end,

	update_info = function(self)
		local gold = g_euser.gold;
		local crystal = g_euser.crystal;
		self.label_gold:setString(gold);
		self.label_crystal:setString(crystal);
	end,
	
	handler = function(event, x, y)
		local self = layer_infobar;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function (self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)

	end,

} -- layer_infobar end

layer_bottombar = { -- start    
	name = 'layer_bottombar',
	layer = nil,
	cwidth = nil,
	chegiht = nil,
	can_touch = nil,
	icon_scale = nil,
	range = nil,
	clarrow = nil,
	crarrow = nil,
	twidth = nil,
	toffset = nil,
	title_color = nil,
	title_scolor = nil,
	tableview = nil,
	--markx = nil,
	touchend = nil,
	bicondata = nil,

	cleanup = function(self)
		self.layer = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.can_touch = nil;
		self.icon_scale = nil;
		self.range = nil;
		self.clarrow = nil;
		self.crarrow = nil;
		self.twidth = nil;
		self.title_color = nil;
		self.title_scolor = nil;
		self.tableview = nil;
		--self.markx = nil;
		self.touchend = nil;
		self.bicondata = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.can_touch = true;
		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_BOTTOMBAR, self.handler, true);

		local path, pos, data, scale, sprite;
		--sprite,data = gui_add_sprite(self.layer,'bg_bottom',GUI_MAIN,ANCHOR_DOWN);
		gui_add_sprite(self.layer,'bottombar_cover',GUI_MAIN,ANCHOR_DOWN);

		data = gui_get_data('b1_text', GUI_MAIN, ANCHOR_DOWN);
		self.title_color = cc.c4b(data.r, data.g, data.b, 255);
		self.title_scolor = cc.c4b(data.sr, data.sg, data.sb, 255);

		self.bicondata = gui_get_data('bg_bottom_icon', GUI_MAIN, ANCHOR_DOWN);
		
		data,scale = gui_get_data('area_bottom', GUI_MAIN, ANCHOR_DOWN);
		self.icon_scale = scale;
		self.range = { y1 = data.y, y2 = data.y + data.height };

		self.list = {
			{ name = '排行榜', icon = 'icon_8', tag = 1, limit = 1 },
			{ name = '信件', icon = 'icon_39', tag = 10, limit = 1},
			{ name = '竞技场', icon = 'icon_prank', tag = 9, limit = 1},
			{ name = '公会', icon = 'icon_20', tag = 6, limit = 1 },
			--{ name = '比赛', icon = 'icon_34', tag = 8, limit = 1 },
			{ name = '公告', icon = 'icon_11', tag = 4, limit = 1 },
			{ name = '选项', icon = 'icon_12', tag = 5, limit = 1 },
		};
		if false == is_ver(VER_APPSTORE) and false == is_ver(VER_UCSDK) and false == is_anysdk_oppo() then
			local l = { name = '论坛', icon = 'icon_9', tag = 2, limit = 1 };
			--table.insert(self.list, 2, l);
			table.insert(self.list, l);
		end
		if false == is_ver(VER_UCSDK) then
			local l = { name = '客服', icon = 'icon_10', tag = 3, limit = 1 };
			--table.insert(self.list, 3, l);
			table.insert(self.list, l);
		end
		if true == DEBUG_MODE or is_ver(VER_APAY) or is_ver(VER_APPSTORE) or is_anysdk_show_pay() or is_ver(VER_UCSDK) or is_ver(VER_LJSDK) then
			local l = { name = '充值', icon = 'icon_19', tag = 7, limit = 1 };
			table.insert(self.list, 4, l);
		end

		pos = ccp(data.x, data.y);
		local size = cc.size(data.width, data.height);
		self.cwidth = size.width/5;
		--self.cwidth = self.bicondata.width;
		self.cheight = size.height;
		self.twidth = size.width;
		pos = cc.p(data.x, data.y);
		local toffset = self.toffset;
		local tv = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_HORIZONTAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, data.zorder);
		self.tableview = tv;
		tv:setBounceable(false);
		self.clarrow, self.crarrow = util.add_arrows(self.layer, pos, size, self.cwidth, #self.list, cc.p(0, 0));
		if nil ~= toffset then
			tv:setContentOffset(toffset);
		end

		return self.layer, self.name;

	end,

	set_show = function(self, is_visible)
		if nil == self.layer then
			return;
		end
		self.can_touch = is_visible;
		self.layer:setVisible(is_visible);
	end,

	callback_tap = function(self, info)
		if nil == info then
			return;
		end
		if true ~= self.can_touch then
			return;
		end
		play_tap_2();
		local index = info.tag;
		if 1 == index then
			g_scene:rank();
		elseif 2 == index then
			util.open_url("http://www.17kapai.com/forum-134-1.html");
		elseif 3 == index then
			g_scene:gm();
		elseif 4 == index then
			show_notice();
		elseif 5 == index then
			g_scene:option();
		elseif 6 == index then
			if true == g_euser:has_guild() then
				net_send('guild');
			else
				g_scene:lguild();
			end
		elseif 7 == index then
			go_pay();
		elseif 8 == index then
			show_match();
		elseif 9 == index then
			g_scene:prank();
		elseif 10 == index then
			g_scene:mail();
		end
	end,

	add_to_list = function(self, list)
		self.etable:insert_list(list);
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_bottombar;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			self.toffset = view:getContentOffset();
			util.handle_arrows(self.clarrow, self.crarrow, #self.list, self.cwidth, self.twidth, self.toffset);
			if true == self.touchend then
				local toffset = self.toffset;
				self.touchend = nil;
				print('on touch end');
				local tx = toffset.x; --self.markx or 0;
				local p = math.floor(math.abs(tx) / self.cwidth);
				local p2 = math.floor(math.abs(tx)) % self.cwidth;
				if p2 > self.cwidth/2 then
					p = p + 1;
				end
				if p >= #self.list then
					p = #self.list - 1;
				end
				toffset.x = - (p * self.cwidth);
				self.tableview:setContentOffset(toffset, true);
			end
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			local info = self.list[idx + 1];
			local limit = info.limit;
			if true ~= DEBUG_MODE and g_euser.level < limit then
				show_msg(limit .. '级开启');
				return;
			end
			self:callback_tap(info);
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight ,self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local info = self.list[idx + 1];
			local name = info.name or '';
			local limit = info.limit;
			local icon = info.icon;
			local fname, path, pos;
			--[[
			path = util.get_path('btn_9.png');
			pos = cc.p(width/2, height/2);
			sprite = util.add_sprite(cell, path, pos, ANCHOR_CENTER_CENTER, 1);
			sprite:setTag(TAG_CELL_BG);
			sprite:setScale(self.icon_scale);
			]]--
			path = util.get_path(self.bicondata.fname1);
			pos = cc.p(width/2, height/2);
			sprite = util.add_sprite(cell, path, pos, ANCHOR_CENTER_CENTER, 8);
			sprite:setTag(TAG_CELL_BG);
			sprite:setScale(self.icon_scale);

			if true ~= DEBUG_MODE and g_euser.level < limit then
				path = util.get_path('icon_15.png');
			else
				fname = icon .. '.png';
				path = util.get_path(fname);
			end
			pos = cc.p(width/2, height/2+5*self.icon_scale);
			sprite = util.add_sprite(cell, path, pos, ANCHOR_CENTER_CENTER, 10);
			--sprite:setTag(TAG_CELL_BG);
			sprite:setScale(self.icon_scale);

			pos = cc.p(width/2, 0);
			local label = util.add_labeloutline(cell, name, nil, 25, pos, self.title_color, self.title_scolor, 2, ANCHOR_CENTER_DOWN, 30);
			label:setScale(self.icon_scale);
			
			--[[
			fname = 'label_' .. string.sub(icon, 6, string.len(icon)) .. '.png';
			fullpath = util.get_fullpath(F_IMAGE, fname);
			pos = cc.p(self.cwidth/2, self.cheight/2 - 50*self.icon_scale);
			sprite = util.add_sprite(cell, fullpath, pos, ANCHOR_CENTER_DOWN);
			sprite:setTag(TAG_CELL_LABEL);
			sprite:setScale(self.icon_scale);
			]]--
			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			local info = self.list[idx + 1];
			local limit = info.limit;
			local icon = info.icon;
			local sprite = cell:getChildByTag(TAG_CELL_BG);
			if nil ~= sprite then
				local path = util.get_path(self.bicondata.fname2);
				local tc = cc.Director:getInstance():getTextureCache();
				local texture = tc:addImage(path);
				if nil == texture then return; end
				sprite:setTexture(texture);
			end
			--[[
			local sprite = cell:getChildByTag(TAG_CELL_LABEL);
			if nil ~= sprite then
				local fname = 'label_' .. string.sub(icon, 6, string.len(icon)) .. '_s.png';
				local fullpath = util.get_fullpath(F_IMAGE, fname);
				local tc = cc.Director:getInstance():getTextureCache();
				local texture = tc:addImage(fullpath);
				if nil == texture then return; end
				sprite:setTexture(texture);
			end
			]]--
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			local info = self.list[idx + 1];
			local limit = info.limit;
			local icon = info.icon;
			local sprite = cell:getChildByTag(TAG_CELL_BG);
			if nil ~= sprite then
				local path = util.get_path(self.bicondata.fname1);
				local tc = cc.Director:getInstance():getTextureCache();
				local texture = tc:addImage(path);
				if nil == texture then return; end
				sprite:setTexture(texture);
			end
			--[[
			local sprite = cell:getChildByTag(TAG_CELL_LABEL);
			if nil ~= sprite then
				local fname = 'label_' .. string.sub(icon, 6, string.len(icon)) .. '.png';
				local fullpath = util.get_fullpath(F_IMAGE, fname);
				local tc = cc.Director:getInstance():getTextureCache();
				local texture = tc:addImage(fullpath);
				if nil == texture then return; end
				sprite:setTexture(texture);
			end
			]]--
			return;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_bottombar;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function (self, x, y)
		if y > self.range.y2 or y < self.range.y1 then
			return false;
		end
		if true ~= self.can_touch then
			return false;
		end
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		--if nil == self.tableview then return; end
		--self.markx = self.tableview:getContentOffset().x;
	end,
	
	onTouchEnded = function(self, x, y)
		if nil == self.tableview then return; end
		--self.markx = self.tableview:getContentOffset().x;
		self.touchend = true;
		--[[
		print('on touch end');
		if nil == self.tableview then return; end
		local toffset = self.tableview:getContentOffset();
		--print('---touch end--- x: ', toffset.x, self.cwidth);
		--local tx = toffset.x;
		local tx = self.markx or 0;
		local p = math.floor(math.abs(tx) / self.cwidth);
		toffset.x = - (p * self.cwidth);
		print('---touch end--- p, x: ', p, toffset.x);
		self.tableview:setContentOffset(toffset, true);
		--self.tableview:setContentOffsetInDuration(toffset, 0.1);
		]]--

	end,

} -- layer_bottombar end

layer_chat = { -- start
	name = 'layer_chat',
	lchannel = {
		{ name = 'C_ALL', tag = C_ALL },
		{ name = 'C_WORLD', tag = C_WORLD },
		--{ name = 'C_ROOM', tag = C_ROOM },
		{ name = 'C_GUILD', tag = C_GUILD },
		{ name = 'C_PRIVATE', tag = C_PRIVATE },
		--{ name = 'C_LOG', tag = C_LOG },  			
	};
	chat_cwidth = nil,
	chat_cheight = nil,
	channel_cwidth = nil,
	channel_cheight = nil,
	channel_twidth = nil,
	layer = nil,
	chat_target = nil,
	channeltags = {},
	chat_view = nil,
	tchannel = nil, -- channel tab table view
	channel_speak = nil,
	channel_btn = nil,
	input_bar = nil,
	full_btn = nil,
	current_tab = nil,
	list = {},
	chat_view_height = 0,
	editlabel = nil,
	editrect = nil,
	editbox = nil,
	bg_chat = nil,
	clarrow = nil, -- channel left arrow
	crarrow = nil, -- channel right arrow
	twidth = nil, -- channel tableview width
	bar = nil,
	tap = nil,
	tpoint = nil,
	-- for map view
	btn_mission = nil,
	swallow_view = nil,
	rect_info = nil,
	label_guild = nil,
	label_lv = nil,
	bg_msg = nil,
	--
	guest_list = nil,
	gcwidth = nil, -- guest list view cell width
	gcheight = nil,-- guest list view cell height
	sprite_icon = nil,
	icon_vip = nil,
	icon_alias = nil,

	cleanup = function(self)
		self.layer = nil;
		self.chat_cwidth = nil;
		self.chat_cheight = nil;
		self.channel_cwidth = nil;
		self.channel_cheight = nil;
		self.channel_twidth = nil;
		self.channeltags = {};
		self.chat_view = nil;
		self.tchannel = nil;
		self.channel_speak = nil;
		self.channel_btn= nil;
		self.input_bar = nil;
		self.full_btn = nil;
		self.current_tab = nil;
		self.list = {};
		self.chat_view_height = 0;
		self.editlabel = nil;
		self.editrect = nil;
		self.editbox = nil;
		self.bg_chat = nil;
		self.clarrow = nil;
		self.crarrow = nil;
		self.twidth = nil;
		self.bar = nil;
		self.tap = nil;
		self.tpoint = nil;
		-- for map view
		self.btn_mission = nil;
		self.swallow_view = nil;
		self.rect_info = nil;
		self.label_guild = nil;
		self.label_lv = nil;
		self.bg_msg = nil;
		--
		self.guest_list = nil;
		self.gcwidth = nil;
		self.gcheight = nil;
		self.sprite_icon = nil;
		self.icon_vip = nil;
		self.icon_alias = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, is_battle)
		self:remove();
		self.list = {};
		self.layer = cc.Layer:create();

		--if g_scene:is_battle() then
		self.lchannel = {
			{ name = 'C_ALL', tag = C_ALL },
			{ name = 'C_WORLD', tag = C_WORLD },
			--{ name = 'C_ROOM', tag = C_ROOM },
			{ name = 'C_GUILD', tag = C_GUILD },
			{ name = 'C_PRIVATE', tag = C_PRIVATE },
			--{ name = 'C_LOG', tag = C_LOG },  			
		};
		if true == is_battle then
			util.reg_handler(self.layer, -ZORDER_LAYER_CHAT, self.handler, true);
			table.insert(self.lchannel, 2, { name = 'C_ROOM', tag = C_ROOM });	
			self:init_battle_chat_view();
		else
			util.reg_handler(self.layer, -ZORDER_LAYER_CHAT, self.handler, false);
			self:init_map_chat_view();
			self:init_map_info_view();
		end

		return self.layer, self.name;

	end,

	callback_close = function()
		local self = layer_chat;
		self:remove();
	end,

	get_mission = function()
		show_mission_list();
	end,

	tip_btn_mission = function(self)
		local btn = self.btn_mission;
		if nil == btn then return; end
		local sprite = btn:getChildByTag(360);
		if nil ~= sprite then
			sprite:removeFromParentAndCleanup(true);
		end
		local fname = nil;
		if 1 == g_mission_tip then -- has new mission
			fname = 'pic_58.png';
		elseif 2 == g_mission_tip then -- has target ok mission
			fname = 'pic_57.png';
		elseif 3 == g_mission_tip then -- has new and target ok mission
			fname = 'pic_58.png';
		else
			sprite = btn:getChildByTag(340);
			if nil ~= sprite then
				sprite:removeFromParentAndCleanup(true);
			end
			sprite = btn:getChildByTag(320);
			if nil ~= sprite then
				sprite:removeFromParentAndCleanup(true);
			end
			return;
		end
		local scale = btn:getScale();
		local size = btn:getContentSize();
		local x1 = 0;
		local x2 = size.width * scale;
		local y1 = 0;
		local y2 = size.height * scale;
		local path = util.get_path(fname);
		local pos = cc.p(x2/4*3, y2/5*4);
		sprite = util.add_sprite(btn, path, pos, ANCHOR_RIGHT_UP, 60);
		sprite:setTag(360);

		local array = {};
		table.insert(array, cc.JumpBy:create(1, cc.p(0, 0), 25, 2));
		table.insert(array, cc.DelayTime:create(2));
		sprite:runAction(cc.RepeatForever:create(cc.Sequence:create(array)));

		local speed = 250;
		local tx = (x2 - x1) / speed;
		local ty = (y2 - y1) / speed;

		sprite = btn:getChildByTag(340);
		if nil == sprite then
			path = util.get_path('tutor_star.png');
			pos = cc.p(x1, y1);
			sprite = util.add_sprite(btn, path, pos, ANCHOR_CENTER_CENTER, 40);
			sprite:setTag(340);

			array = {};
			table.insert(array, cc.MoveTo:create(ty, cc.p(x1, y2)));
			table.insert(array, cc.MoveTo:create(tx, cc.p(x2, y2)));
			table.insert(array, cc.MoveTo:create(ty, cc.p(x2, y1)));
			table.insert(array, cc.MoveTo:create(tx, cc.p(x1, y1)));
			sprite:runAction(cc.RepeatForever:create(cc.Sequence:create(array)));
			sprite:runAction(cc.RepeatForever:create(cc.RotateBy:create(1, 360)));
		end

		sprite = btn:getChildByTag(320);
		if nil == sprite then
			path = util.get_path('tutor_tail.plist');
			pos = cc.p(x1, y1);
			local p = util.add_particle(btn, path, pos, 20);
			sprite = p.batch;
			sprite:setTag(320);

			array = {};
			table.insert(array, cc.MoveTo:create(ty, cc.p(x1, y2)));
			table.insert(array, cc.MoveTo:create(tx, cc.p(x2, y2)));
			table.insert(array, cc.MoveTo:create(ty, cc.p(x2, y1)));
			table.insert(array, cc.MoveTo:create(tx, cc.p(x1, y1)));
			sprite:runAction(cc.RepeatForever:create(cc.Sequence:create(array)));
		end
	end,

	update_info = function(self)
		if nil == self.layer then
			return;
		end
		local str;

		--[[
		if true == g_euser:has_guild() then
			str = get_guild_name(g_euser.gname);
		else
			str = t_lang("NO_GUILD");
		end
		]]--
		str = get_power() .. "/90";
		self.label_guild:setString(str);

		local level = 'LV.' .. g_euser.level;
		self.label_lv:setString(level);

		self.sprite_icon:removeFromParentAndCleanup(true);
		local path1 = get_icon_path(g_euser.icon);
		local path2 = util.get_fullpath(F_IMAGE, 'picon_1_mask_1.png');
		self.sprite_icon = gui_add_mask_image(self.layer, path1, path2, 'icon_player', GUI_MAIN, ANCHOR_UP);

		--[[
		local percent;
		local exp_total = g_euser.exp_next - g_euser.exp_this;
		local exp = g_euser.exp - g_euser.exp_this;
		if exp < 0 then exp = 0; end
		if 0 == exp_total or exp >= exp_total then
			percent = 100;
		else
			percent = exp / exp_total * 100;
		end
		self.bar_exp:setPercentage(percent);
		]]--
	end,

	init_map_info_view = function(self)
		local path, pos, sprite, data, scale, str;

		sprite,data = gui_add_sprite(self.layer, 'bg_player',GUI_MAIN,ANCHOR_UP);
		self.rect_info = { x1 = data.x, x2 = data.x + data.width,
		                   y1 = data.y, y2 = data.y + data.height };

		gui_add_sprite(self.layer, 'bg_playerinfo',GUI_MAIN,ANCHOR_UP);

		self.icon_alias, data = gui_add_sprite(self.layer,'icon_alias',GUI_MAIN,ANCHOR_UP);
		path = util.get_path('bone_eye_fire.plist');
		pos = ccp(data.width/4+1, data.height/2+5);
		util.add_particle(self.icon_alias, path, pos, 1);
		pos = ccp(data.width/4*3-4, data.height/2+5);
		util.add_particle(self.icon_alias, path, pos, 1);

		self.icon_vip = gui_add_sprite(self.layer, 'icon_vip', GUI_MAIN, ANCHOR_UP);
		self:show_vip(is_vip_member(g_euser));

		gui_add_sprite(self.layer, 'icon_power', GUI_MAIN, ANCHOR_UP);

		str = (g_euser.alias or '');
		gui_add_label(self.layer, str, 18, 'alias', GUI_MAIN, ANCHOR_UP);

		--[[
		if true == g_euser:has_guild() then
			str = get_guild_name(g_euser.gname);
		else
			str = t_lang("NO_GUILD");
		end
		self.label_guild = gui_add_label(self.layer, str, 18, 'guild', GUI_MAIN, ANCHOR_UP);
		]]--
		path = util.get_path(FNT_1);
		str = get_power() .. "/90";
		self.label_guild = gui_add_labelbmf(self.layer, str, path, 'power', GUI_MAIN, ANCHOR_UP);

		path = get_icon_path(g_euser.icon);
		local mask_path = util.get_path('picon_1_mask_1.png');
		sprite = gui_add_mask_image(self.layer, path, mask_path, 'icon_player', GUI_MAIN, ANCHOR_UP);
		self.sprite_icon = sprite;
		gui_add_sprite(self.layer, 'icon_light', GUI_MAIN, ANCHOR_UP);

		path = util.get_path('font_lv.fnt');
		str = 'LV.' .. g_euser.level;
		self.label_lv = gui_add_labelbmf(self.layer, str, path, 'lv', GUI_MAIN, ANCHOR_UP);

		local items = {};
		local item, data;

		item,data=gui_add_item(items, 'btn_reward', GUI_MAIN, self.get_mission, ANCHOR_UP);
		self.btn_mission = item;
		util.add_menu(self.layer, items, data.zorder);
		str = '奖励';
		gui_add_stroke(self.layer, str, 25, 'text_reward', GUI_MAIN, ANCHOR_UP);

		self:tip_btn_mission();

		--[[
		sprite, data = gui_add_sprite(self.layer, 'bar_exp', GUI_MAIN, ANCHOR_UP);
		pos = ccp(sprite:getPositionX(), sprite:getPositionY());
		fullpath = util.get_fullpath(F_IMAGE, 'bar_exp_2.png');
		self.bar_exp = util.add_progress_bar(self.layer, util.create_sprite(fullpath), pos, cc.PROGRESS_TIMER_TYPE_BAR, ccp(0, 1), ccp(1, 0), 0, data.zorder);
		self.bar_exp:setAnchorPoint(sprite:getAnchorPoint());
		self.bar_exp:setScaleX(sprite:getScaleX());
		self.bar_exp:setScaleY(sprite:getScaleY());
		fullpath = util.get_fullpath(F_IMAGE, 'bar_exp_3.png');
		sprite = util.add_sprite(self.layer, fullpath, pos, sprite:getAnchorPoint(), data.zorder);
		sprite = gui_add_sprite(self.layer, 'exp', GUI_MAIN, ANCHOR_UP);
		]]--
	end,

	show_vip = function(self, is_show)
		if nil == self.layer then return; end
		if nil == self.icon_vip then return; end
		if nil == self.icon_alias then return; end
		self.icon_vip:setVisible(is_show);
		self.icon_alias:setVisible(not is_show);
	end,

	get_map_chat_win_data = function(self)
		local x, y, width, height;
		local data_bg_up = gui_get_data('bg_chat', GUI_MAIN, ANCHOR_UP);
		local data_bg_down = gui_get_data('bg_chat', GUI_MAIN, ANCHOR_DOWN);
		x = data_bg_up.x;
		y = data_bg_down.y;
		width = data_bg_up.width;
		height = data_bg_up.y + data_bg_up.height - data_bg_down.y;
		local ndata = {};
		for k, v in pairs(data_bg_up) do
			ndata[k] = v;
		end
		ndata.x = x;
		ndata.y = y;
		ndata.width = width;
		ndata.height = height;
		if ndata.height < 0 then
			ndata.height = 0;
		end
		return ndata, scale;
		--[[
		local d = gui_get_data('bg_chat', GUI_MAIN);
		local scale = d.width/d.rwidth;
		local dup = gui_get_data('area_channel', GUI_MAIN);
		local ddown = gui_get_data('bg_input_channel', GUI_MAIN);
		local gup = dup.oy - (d.oy + d.rheight);
		local gdown = d.oy - (ddown.oy + ddown.height);
		local sup = gui_get_data('area_channel', GUI_MAIN, ANCHOR_UP);
		local sdown = gui_get_data('bg_input_channel', GUI_MAIN, ANCHOR_DOWN);
		local hup = sup.y - gup;
		local hdown = sdown.y - gdown;
		height = hup - hdown;
		width = d.width;
		local ndata = {};
		for k, v in pairs(d) do
			ndata[k] = v;
		end
		ndata.x = d.x;
		ndata.y = hdown;
		ndata.width = width;
		ndata.height = height;
		if ndata.height < 0 then
			ndata.height = 0;
		end
		return ndata, scale;
		]]--
	end,

	set_chat_view = function(self, bgpos, bgsize, zorder)
		if nil ~= self.chat_view then
			self.chat_view:removeFromParentAndCleanup(true);
		end
		if nil ~= self.bar then self.bar:removeFromParentAndCleanup(true); end
		local offsetx = 10;--wfix(25);
		local offsety = 10;--hfix(25);
		local pos = cc.p(bgpos.x + offsetx, bgpos.y + offsety);
		local size = cc.size(bgsize.width-offsetx*2, bgsize.height-offsety*2);
		self.chat_cwidth = size.width;
		self.chat_cheight = 90;
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, zorder+4);
		-----
		self.chat_view = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, zorder);
		self.chat_view_height = size.height;
	end,

	init_map_chat_view = function(self)
		local sprite, data, pos, path;
		---------- bg start ---------
		data = self:get_map_chat_win_data();
		pos = cc.p(data.x, data.y);
		path = util.get_path(data.fname1);
		local fullrect = cc.rect(0, 0, data.owidth, data.oheight);
		local insetrect = cc.rect(data.owidth/2-2, data.oheight/2-2, 4, 4);
		local realsize = cc.size(data.width, data.height);
		local gapheight = realsize.height-data.rheight;
		sprite = util.add_scale9sprite(self.layer, path, pos, ANCHOR_LEFT_DOWN, fullrect, insetrect, realsize, data.zorder); 
		self.bg_chat = sprite;
		---------- bg end ---------
		-------- channel list start ------
		data = gui_get_data('btn_chat_all', GUI_MAIN, ANCHOR_UP);
		self.channel_cwidth = data.width;
		self.channel_cheight = data.height;
		data = gui_get_data('area_channel', GUI_MAIN, ANCHOR_UP);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height);
		self.channel_twidth = size.width;
		self.tchannel = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_HORIZONTAL, self.tableview_channel_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, data.zorder);
		self:change_channel(C_ALL);
		self.clarrow, self.crarrow = util.add_arrows(self.layer, pos, size, self.channel_cwidth, #self.lchannel, cc.p(0, 0));
		-------- channel list end ------
		-------- bg chat msg start ------
		data = gui_get_data('bg_chat_msg', GUI_MAIN, ANCHOR_UP);
		local frect = cc.rect(0, 0, data.owidth, data.oheight);
		local irect = cc.rect(data.owidth/2-2, data.oheight/2-2, 4, 4);
		local rsize = cc.size(data.width, data.height+gapheight);
		if rsize.height < data.oheight then
			rsize.height = data.oheight;
		end
		pos = cc.p(data.x, data.y-gapheight);
		path = util.get_path(data.fname1);
		sprite = util.add_scale9sprite(self.layer, path, pos, ANCHOR_LEFT_DOWN, frect, irect, rsize, data.zorder); 
		self.bg_msg = sprite;
		self:set_chat_view(pos, rsize, data.zorder+5);
		-------- bg chat msg end ------
		-------- input bar start ------
		sprite = gui_add_sprite(self.layer, 'bg_input_chat',GUI_MAIN,ANCHOR_DOWN);
		self.input_bar = sprite;

		local items = {};
		local item;

		item, data = gui_add_item(items, 'btn_input_channel', GUI_MAIN, self.callback_channel, ANCHOR_DOWN);
		self.channel_btn = item;
		self:handle_channel_btn(C_WORLD);

		item, data = gui_add_item(items, 'btn_full', GUI_MAIN, self.cb_chatscale, ANCHOR_DOWN);
		self.full_btn = item;

		util.add_menu(self.layer, items, data.zorder);

		self.editbox, data = gui_add_editbox(self.layer, 'area_chat_input', GUI_MAIN, ANCHOR_DOWN, 22, self.edit_box_handler, 60, t_lang("CHAT_TIP_ENTER"));
		self.editbox:setVisible(false);
		pos = cc.p(data.x, data.y);
		local tsize = cc.size(data.width, data.height);
		self.editlabel = util.add_labelttf(self.layer, t_lang("CHAT_TIP_ENTER"), nil, 25, pos, util.c4b_black, ANCHOR_LEFT_DOWN, data.zorder, tsize, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_CENTER); 
		self.editrect = { x1= pos.x, x2 = pos.x + tsize.width,
						  y1= pos.y, y2 = pos.y + tsize.height }; 
		-------- input bar end ------
	end,

	move_y = function(self, sprite, gapy)
		local y = sprite:getPositionY();
		sprite:setPositionY(y + gapy);
	end,

	init_guest_list_view = function(self)
		if nil == g_euser.room_data then
			return;
		end
		local l = g_euser.room_data.guest_list or {};
		if #l < 3 then
			return;
		end
		local data = gui_get_data('bg_chat', GUI_MAIN, ANCHOR_UP); 
		local x = data.x;
		local y = data.y + data.height + 5;
		local width = data.width;
		local height = FULL_HEIGHT - hfix(60) - y;
		local path = util.get_path('bg_5.png');
		local frect = cc.rect(0, 0, 152, 152); -- fullrect
		local irect = cc.rect(74, 74, 4, 4); -- insetrect
		local rsize = cc.size(width, height); -- realsize
		local pos = cc.p(x, y);
		local bg = util.add_scale9sprite(self.layer, path, pos, ANCHOR_LEFT_DOWN, frect, irect, rsize, data.zorder); 

		local p = cc.p(rsize.width/2, rsize.height - 50);
		local str = string.format("观战人数: %d", #l-2);
		local label = util.add_labeloutline(bg, str, nil, 25, p, util.c4b_gold, util.c4b_black, 2, ANCHOR_CENTER_DOWN, 10);

		self.guest_list = {};
		for i = 3, #l do
			table.insert(self.guest_list, l[i]);
		end
		p = cc.p(50, 30);
		local s = cc.size(rsize.width - 100, rsize.height - 50 - 30);
		self.gcwidth = s.width;
		self.gcheight = 50;
		util.add_tableview(bg, s, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.guest_tv_handler, p, cc.TABLEVIEW_FILL_TOPDOWN, 10);
	end,

	init_battle_chat_view = function(self)
		self:init_guest_list_view();
		local sprite, data, pos, path;
		local data1 = gui_get_data('bg_input_chat', GUI_MAIN, ANCHOR_DOWN); 
		local data2 = gui_get_data('bg_input_chat_full',GUI_MAIN,ANCHOR_DOWN);
		local gapy = data1.y - data2.y;
		---------- bg start ---------
		data = self:get_map_chat_win_data();
		pos = cc.p(data.x, data.y-gapy);
		path = util.get_path(data.fname1);
		local fullrect = cc.rect(0, 0, data.owidth, data.oheight);
		local insetrect = cc.rect(data.owidth/2-2, data.oheight/2-2, 4, 4);
		local realsize = cc.size(data.width, data.height+gapy);
		local gapheight = realsize.height-data.rheight;
		sprite = util.add_scale9sprite(self.layer, path, pos, ANCHOR_LEFT_DOWN, fullrect, insetrect, realsize, data.zorder); 
		self.bg_chat = sprite;
		---------- bg end ---------
		-------- channel list start ------
		data = gui_get_data('btn_chat_all', GUI_MAIN, ANCHOR_UP);
		self.channel_cwidth = data.width;
		self.channel_cheight = data.height;
		data = gui_get_data('area_channel', GUI_MAIN, ANCHOR_UP);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height);
		self.channel_twidth = size.width;
		self.tchannel = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_HORIZONTAL, self.tableview_channel_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, data.zorder);
		self:change_channel(C_ROOM);
		self.clarrow, self.crarrow = util.add_arrows(self.layer, pos, size, self.channel_cwidth, #self.lchannel, cc.p(0, 0));
		-------- channel list end ------
		-------- bg chat msg start ------
		data = gui_get_data('bg_chat_msg', GUI_MAIN, ANCHOR_UP);
		local frect = cc.rect(0, 0, data.owidth, data.oheight);
		local irect = cc.rect(data.owidth/2-2, data.oheight/2-2, 4, 4);
		local rsize = cc.size(data.width, data.height+gapheight);
		if rsize.height < data.oheight then
			rsize.height = data.oheight;
		end
		pos = cc.p(data.x, data.y-gapheight);
		path = util.get_path(data.fname1);
		sprite = util.add_scale9sprite(self.layer, path, pos, ANCHOR_LEFT_DOWN, frect, irect, rsize, data.zorder); 
		self.bg_msg = sprite;
		self:set_chat_view(pos, rsize, data.zorder+5);
		local tboffset = self.chat_view:getContentOffset();
		tboffset.y = 0;
		self.chat_view:setContentOffset(tboffset);
		-------- bg chat msg end ------
		-------- input bar start ------
		sprite = gui_add_sprite(self.layer, 'bg_input_chat',GUI_MAIN,ANCHOR_DOWN);
		move_tvh(sprite, -gapy);
		self.input_bar = sprite;

		local items = {};
		local item;

		add_item_1(items, '返回', nil, 30, self.callback_close, ANCHOR_CENTER_DOWN, cc.p(HALF_WIDTH, hfix(50)));

		item, data = gui_add_item(items, 'btn_input_channel', GUI_MAIN, self.callback_channel, ANCHOR_DOWN);
		move_tvh(item, -gapy);
		self.channel_btn = item;
		self:handle_channel_btn(C_ROOM);

		util.add_menu(self.layer, items, data.zorder);

		self.editbox, data = gui_add_editbox(self.layer, 'area_chat_input', GUI_MAIN, ANCHOR_DOWN, 22, self.edit_box_handler, 60, t_lang("CHAT_TIP_ENTER"));
		move_tvh(self.editbox, -gapy);
		self.editbox:setVisible(false);
		pos = cc.p(data.x, data.y-gapy);
		local tsize = cc.size(data.width, data.height);
		self.editlabel = util.add_labelttf(self.layer, t_lang("CHAT_TIP_ENTER"), nil, 25, pos, util.c4b_black, ANCHOR_LEFT_DOWN, data.zorder, tsize, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_CENTER); 
		self.editrect = { x1= pos.x, x2 = pos.x + tsize.width,
						  y1= pos.y, y2 = pos.y + tsize.height }; 
		-------- input bar end ------

		--[[
		local data_btn_1 = gui_get_data('btn_chat', GUI_MATCH, ANCHOR_NULL);
		local data_btn_2 = gui_get_data('btn_chat', GUI_MATCH, ANCHOR_UP);
		local gapy = data_btn_1.y - data_btn_2.y;
		local sprite, data, pos, fullpath;
		---------- bg ---------
		sprite = gui_add_sprite(self.layer,'chat_bg',GUI_MATCH,ANCHOR_UP);
		self:move_y(sprite, gapy);
		-------------------
		data = gui_get_data('chat_area', GUI_MATCH, ANCHOR_UP);
		pos = cc.p(data.x, data.y+gapy);
		local size = cc.size(data.width, data.height);
		self:set_chat_view(pos, size, data.zorder);

		sprite = gui_add_sprite(self.layer,'chat_input_bg',GUI_MATCH,ANCHOR_UP);
		self:move_y(sprite, gapy);
		self.input_bar = sprite;

		data = gui_get_data('chat_channel_table', GUI_MATCH, ANCHOR_UP);
		pos = cc.p(data.x, data.y+gapy);
		size = cc.size(data.width, data.height);
		self.channel_cwidth = 113;
		self.channel_cheight = 47;
		self.channel_twidth = size.width;
		self.tchannel = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_HORIZONTAL, self.tableview_channel_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, data.zorder);
		self:change_channel(C_ROOM);
		self.clarrow, self.crarrow = util.add_arrows(self.layer, pos, size, self.channel_cwidth, #self.lchannel, cc.p(0, 0));

		local fullpath;
		local items = {};
		local item;

		item, data = gui_add_item(items, 'chat_close', GUI_MATCH, self.callback_close, ANCHOR_UP);
		self:move_y(item, gapy);

		item, data = gui_add_item(items, 'chat_channel_btn', GUI_MATCH, self.callback_channel, ANCHOR_UP);
		self:move_y(item, gapy);
		self.channel_btn = item;
		self:handle_channel_btn(C_ROOM);

		util.add_menu(self.layer, items, data.zorder);

		data = gui_get_data('chat_input_area', GUI_MATCH, ANCHOR_UP);
		pos = cc.p(data.x, data.y+gapy);
		realsize = cc.size(data.width, data.height);
		self.editlabel = util.add_labelttf(self.layer, t_lang("CHAT_TIP_ENTER"), nil, 22, pos, util.c_black, ANCHOR_LEFT_DOWN, data.zorder, realsize, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_CENTER); 
		self.editrect = { x1= pos.x, x2 = pos.x + realsize.width,
						   y1= pos.y, y2 = pos.y + realsize.height }; 
		self.editbox = util.add_editbox_blank(self.layer, realsize, 
			ANCHOR_LEFT_DOWN, pos, util.f_default, 22, util.c_black, 
			cc.EDITBOX_INPUT_MODE_SINGLELINE, cc.KEYBOARD_RETURNTYPE_DONE, nil, 
			self.edit_box_handler, 60,t_lang("CHAT_TIP_ENTER"),
			util.c_black,data.zorder);
		self.editbox:setVisible(false);
		]]--
	end,

	callback_close = function()
		local self = layer_chat;
		self:remove();
	end,

	swallow_touch_for_map = function(self, is_swallow)
		if nil == self.swallow_view then
			local layer = cc.Layer:create();
			local function handler(event, x, y)
				if "began" == event then   
					if true == layer:isVisible() then return true; end
					return false;
				end
			end
			local zorder = ZORDER_LAYER_CHAT-1;
			util.reg_handler(layer, -zorder, handler, true);
			g_scene:add_layer(zorder, layer);
			self.swallow_view = layer;
		end
		if true == is_swallow then
			self.swallow_view:setVisible(true);
		else
			self.swallow_view:setVisible(false);
		end
	end,

	update_chat_input_tap = function()
		local self = layer_chat;
		self.editlabel:setVisible(true);
		local y = self.editbox:getPositionY();
		local height = self.editbox:getContentSize().height;
		self.editrect.y1 = y;
		self.editrect.y2 = y + height;
		self.editlabel:setPositionY(y);
	end,

	cb_chatscale = function(tag, sender)
		play_tap_1();
		local self = layer_chat;
		--  0 : off     1 : on
		local flag = tolua.cast(sender, "cc.MenuItemToggle"):getSelectedIndex();
		if nil == self.chat_view then
			-- still doing animation, because chat_view will be set when finish
			if 0 == flag then
				flag = 1;
			else
				flag = 0;
			end
			sender:setSelectedIndex(flag);
			return;
		end
		self.chat_view:removeFromParentAndCleanup(true);
		self.chat_view = nil;
		local gapy = 0;
		--local gapy = hfix(284);
		local data1 = gui_get_data('bg_input_chat', GUI_MAIN, ANCHOR_DOWN); 
		local data2 = gui_get_data('bg_input_chat_full',GUI_MAIN,ANCHOR_DOWN);
		local data_win = self:get_map_chat_win_data();
		local gapy = data1.y - data2.y;
		local gapheight = data_win.height - data_win.rheight;
		local data_bg_msg = gui_get_data('bg_chat_msg', GUI_MAIN, ANCHOR_DOWN);
		data_bg_msg.height = data_bg_msg.height + gapheight;
		local list_bar = { 
			 { node = self.input_bar, key = 'bg_input_chat' },
			 { node = self.channel_btn, key = 'btn_input_channel' },
			 { node = self.full_btn, key = 'btn_full' },
			 { node = self.editbox, key = 'area_chat_input' },
		};
		local list_chat = {
			 { node = self.bg_chat, offsety = 0, data = data_win },
			 { node = self.bg_msg, offsety = 0, data = data_bg_msg },
		};
		self.editrect.y1=FULL_HEIGHT*2; --set a very height value to avoid trigger
		self.editlabel:setVisible(false);
		local atime = 0.3;
		local scroll_speed = hfix(3);
		local atag1 = 25;
		if 1 == flag then -- scale full
			if g_scene:is_stage(STAGE_MAP) then
				self:swallow_touch_for_map(true);
			end
			for i = 1, #list_bar do
				local node = list_bar[i].node;
				local key = list_bar[i].key;
				local data = gui_get_data(key, GUI_MAIN, ANCHOR_DOWN); 
				local newy = data.y - gapy;
				local x = node:getPositionX();
				local npos = cc.p(x, newy);
				local array = {};
				local action = cc.MoveTo:create(atime, npos); 
				action = cc.EaseIn:create(action, atime);
				table.insert(array, action);
				if i == #list_bar then
					action = cc.CallFunc:create(self.update_chat_input_tap);
					table.insert(array, action);
				end
				action = cc.Sequence:create(array);
				node:runAction(action);
			end
			for i = 1, #list_chat do
				local node = list_chat[i].node;
				local offsety = list_chat[i].offsety;
				local data = list_chat[i].data;
				local has_set_chat_view = false;
				local change_pos = function(...)
					local args = {...};
					local node = args[1];
					local y = node:getPositionY() - scroll_speed;
					node:setPositionY(y);
					local size = node:getContentSize();
					size.height = size.height + scroll_speed;
					node:setContentSize(size);
					if y <= data.y-gapy+offsety or size.height >= data.height+gapy-offsety*2 then
						node:setPositionY(data.y-gapy+offsety);
						node:setContentSize(cc.size(data.width,data.height+gapy-offsety*2));
						node:stopActionByTag(atag1);
						if i ~= #list_chat or true == has_set_chat_view then
							return;
						end
						has_set_chat_view = true;
						local pos = cc.p(node:getPositionX(),node:getPositionY());
						local size = node:getContentSize();
						self:set_chat_view(pos, size, data.zorder+5);
					end
				end
				local array, action;
				--- repeat action ----
				array = {};
				action = cc.CallFunc:create(change_pos);
				table.insert(array, action);
				action = cc.Spawn:create(array); -- run more change_pos
				--action = cc.Sequence:create(array);
				action = cc.RepeatForever:create(action);
				action:setTag(atag1);
				node:runAction(action);
				---------------------
			end
		else -- scale small
			if g_scene:is_stage(STAGE_MAP) then
				self:swallow_touch_for_map(false);
			end
			for i = 1, #list_bar do
				local node = list_bar[i].node;
				local key = list_bar[i].key;
				local data = gui_get_data(key, GUI_MAIN, ANCHOR_DOWN); 
				local newy = data.y;
				local x = node:getPositionX();
				local npos = cc.p(x, newy);
				local array = {};
				local action = cc.MoveTo:create(atime, npos); 
				action = cc.EaseIn:create(action, atime);
				table.insert(array, action);
				if i == #list_bar then
					action = cc.CallFunc:create(self.update_chat_input_tap);
					table.insert(array, action);
				end
				action = cc.Sequence:create(array);
				node:runAction(action);
			end
			for i = 1, #list_chat do
				local node = list_chat[i].node;
				local offsety = list_chat[i].offsety;
				local data = list_chat[i].data;
				local has_set_chat_view = false;
				local change_pos = function(...)
					local args = {...};
					local node = args[1];
					local y = node:getPositionY() + scroll_speed;
					node:setPositionY(y);
					local size = node:getContentSize();
					size.height = size.height - scroll_speed;
					if size.height < data.oheight then
						size.height = data.oheight;
					end
					node:setContentSize(size);
					if y >= data.y+offsety or size.height <= data.height-offsety*2 then
						node:setPositionY(data.y+offsety);
						local h = data.height-offsety*2;
						if h < data.oheight then
							h = data.oheight;
						end
						node:setContentSize(cc.size(data.width, h));
						node:stopActionByTag(atag1);
						if i ~= #list_chat or true == has_set_chat_view then
							return;
						end
						has_set_chat_view = true;
						local pos = ccp(node:getPositionX(), node:getPositionY());
						local size = node:getContentSize();
						self:set_chat_view(pos, size, data.zorder+5);
					end
				end
				local array, action;
				--- repeat action ----
				array = {}
				action = cc.CallFunc:create(change_pos);
				table.insert(array, action);
				action = cc.Spawn:create(array); -- run more change pos
				--action = cc.Sequence:create(array);
				action = cc.RepeatForever:create(action);
				action:setTag(atag1);
				node:runAction(action);
				---------------------
			end
		end
	end,

	guest_tv_handler = function(...)  -- { start
		local self = layer_chat;
		local args = {...};
		local event = args[1];
		local view = args[2];
		if "numberOfCellsInTableView" == event then
			return #(self.guest_list or {});
		elseif "scrollViewDidScroll" == event then
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			local info = self.guest_list[idx + 1];
			g_scene:add_layer(ZORDER_LAYER_CHATPOP, layer_chatpop:create(info));
			return 0;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.gcheight, self.gcwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.gcwidth;
			local height = self.gcheight;
			local info = self.guest_list[idx + 1];
			local alias = info.alias;
			local icon = info.icon;
			local str = string.format("%s", alias);
			local pos = ccp(0, height/2);
			util.add_labeloutline(cell, str, nil, 30, pos, util.c4b_white, util.c4b_black, 2, ANCHOR_LEFT_CENTER, 10);

			local path = util.get_path('line_1.png');
			pos = ccp(width/2, 0);
			local line = util.add_sprite(cell, path, pos, ANCHOR_CENTER_DOWN);
			line:setScaleX((width-40)/line:getContentSize().width);
			return cell;
		end
	end, -- tableview_handler end }

	tableview_handler = function(...)  -- { start
		local self = layer_chat;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			local info = self.list[idx+1];
			if nil == info then return; end
			if info.eid == g_euser.eid then return; end
			if tonumber(info.eid) == 1501 then return; end
			g_scene:add_layer(ZORDER_LAYER_CHATPOP, layer_chatpop:create(info));
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.chat_cheight, self.chat_cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.chat_cwidth;
			local height = self.chat_cheight;
			local info = self.list[idx + 1];
			local channel = self:channel_name(info.channel);
			local eid = info.eid;
			local alias = info.alias;
			local msg = info.msg;
			local time = info.time;
			local is_vip = info.is_vip;
			local str, pos, size;

			local path = util.get_path('line_2.png');
			pos = ccp(width/2, 0);
			local line = util.add_sprite(cell, path, pos, ANCHOR_CENTER_DOWN);
			line:setScaleX((width-40)/line:getContentSize().width);

			--[[
			local fullrect = cc.rect(0, 0, 52, 20);
			local insetrect = cc.rect(21, 9, 10, 2);
			size = cc.size(self.chat_cwidth, 20);

			pos = ccp(0, 0);
			sprite = util.add_scale9sprite(cell, fullpath, pos, ANCHOR_LEFT_DOWN, fullrect, insetrect, size); 
			]]--

			if true == DEBUG_MODE then
				str = string.format('[%s][(%d)%s][%s]:',channel,eid, alias, time);
			else
				str = string.format('[%s][%s][%s]:',channel, alias, time);
			end
			if is_vip == 1 then
				local fpath = util.get_fullpath(F_IMAGE, 'icon_vip2.png');
				pos = ccp(0, height);
				local icon_vip = util.add_sprite(cell, fpath, pos, ANCHOR_LEFT_UP);
				icon_vip:setScale(.8);
				local icon_size = icon_vip:getContentSize();
				pos = cc.p(icon_size.width * .8 + 8, height + 3);
				size = cc.size(width, 30);
			else
				pos = cc.p(0, height);
				size = cc.size(width, 30);
			end
			util.add_label(cell, str, 20, pos, util.c_red, ANCHOR_LEFT_UP, nil, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

			str = string.format('%s', msg);
			pos = cc.p(0, height-30);
			size = cc.size(width, height-30);
			util.add_label(cell, str, 20, pos, util.c_black, ANCHOR_LEFT_UP, nil, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
			return cell;
		end
	end, -- tableview_handler end }

	tableview_channel_handler = function(...)  -- { start
		local self = layer_chat;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.lchannel or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_arrows(self.clarrow, self.crarrow, #self.lchannel, self.channel_cwidth, self.channel_twidth, view:getContentOffset());
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			play_tap_1();
			local cell = args[3];
			local idx = cell:getIdx();
			local info = self.lchannel[idx + 1];
			local tag = info.tag;
			local x, y = view:getContentOffset();
			self:change_channel(tag);
			view:setContentOffset(cc.p(x, y), false);
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.channel_cheight, self.channel_cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.channel_cwidth;
			local height = self.channel_cheight;
			local info = self.lchannel[idx + 1];
			local tag = info.tag;
			local name = t_lang(info.name);
			local data = gui_get_data('btn_chat_all', GUI_MAIN);
			local path, filename, pos, sprite, size;
			pos = cc.p(width/2, height/2);
			local findex = idx + 1;
			if findex == C_LOG then
				findex = 99;
			end
			if self.current_tab == tag then
				--filename = string.format("btn_1_s.png");
				filename = data.fname2;
			else
				--filename = string.format("btn_1.png");
				filename = data.fname1;
			end
			path = util.get_path(filename);
			sprite = util.add_sprite(cell, path, pos, ANCHOR_CENTER_CENTER, 1);

			pos = cc.p(width/2, height/2);
			size = cc.size(width, height);
			local color = cc.c4b(data.r, data.g, data.b, 255);
			local scolor = cc.c4b(data.sr, data.sg, data.sb, 255);
			--util.add_label(sprite, name, 25, pos, util.c_white, ANCHOR_LEFT_DOWN, nil, size, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
			util.add_labeloutline(cell, name, nil, 25, pos, color, scolor, 2, ANCHOR_CENTER_CENTER, 5);
			return cell;
		end
	end, -- tableview_channel_handler end }

	handle_channel_btn = function(self, channel)
		local item = self.channel_btn;
		self.channel_speak = channel;
		local name = self:channel_name(channel);
		if nil == item then
			return;
		end
		util.add_text_outline_to_sprite(item, name, 25, cc.c4b(255, 208, 1, 255), cc.c4b(30, 24, 60, 255), 1);
		if nil == self.editbox then
			return;
		end
		local ph = t_lang("CHAT_TIP_ENTER");
		if channel == C_PRIVATE and nil ~= self.chat_target then
			--ph = 
			ph = string.format("(%s)%s", self.chat_target.alias, ph);
		end
		self.editbox:setPlaceHolder(ph);
		self.editlabel:setString(ph);
	end,

	callback_channel = function()
		play_tap_1();
		local self = layer_chat;
		local channel = self.channel_speak or (C_WORLD - 1);
		channel = channel + 1;
		if g_euser.st < ST_ROOM and channel == C_ROOM then
			channel = channel + 1;
		end
		if channel == C_GUILD and (g_euser.gid <= 0 or g_euser.gpos == GUILD_POS_APPLY) then
			channel = channel + 1;
		end
		if channel == C_LOG then
			channel = channel + 1;
		end
		if channel >= C_LOG + 1 then -- no need to be C_LOG
			channel = C_WORLD;
		end
		self:handle_channel_btn(channel);
	end,

	channel_name = function(self, tag)
		local str = '';
		if tag == C_ALL then
			str = str .. t_lang("C_ALL");
		elseif tag == C_WORLD then
			str = str .. t_lang("C_WORLD");
		elseif tag == C_ROOM then
			str = str .. t_lang("C_ROOM");
		elseif tag == C_GUILD then
			str = str .. t_lang("C_GUILD");
		elseif tag == C_PRIVATE then
			str = str .. t_lang("C_PRIVATE");
		elseif tag == C_LOG then
			str = str .. t_lang("C_LOG");
		else
			str = str .. '???';
		end

		return str;
	end,

	callback_channeltag = function(...)
		local self = layer_chat;
		local args = {...};
		local index = args[2]:getTag();
		self:change_channel(index);
	end,

	refresh_list = function(self)
		local table_view = self.chat_view;
		if nil == table_view then
			return;
		end
		table_view:reloadData();
		if self.chat_cheight * #self.list <= self.chat_view_height then
			return;
		end
		local offsetx, offsety = table_view:getContentOffset();
		offsety = table_view:getContentSize().height-self.chat_cheight*#self.list;
		local offset = cc.p(offsetx, offsety);
		local animated = false;
		table_view:setContentOffset(offset, animated);
	end,

	change_channel = function(self, tag)
		self.current_tab = tag;
		self.tchannel:reloadData();
		self.list = g_chat_list[self.current_tab];
		self:refresh_list();
	end,

	refresh = function(self)
		if nil == self.layer then
			return;
		end
		self.current_tab = self.current_tab or C_WORLD;
		self.list = g_chat_list[self.current_tab];
		self:refresh_list();
	end,

	add_msg = function(self, msg)
		local channel = self.channel_speak or C_WORLD;
		if nil == msg or '' == msg then
			return;
		end
		msg = util.replace_sensitive_data(msg);
		local cmd = '';
		--msg = msg or '???';
		if C_WORLD == channel then
			cmd = 'wchat ' .. msg;	
		elseif C_ROOM == channel then
			if 'show_local_version' == msg then
				-- for debug
				add_chat_msg(C_LOG, -1, '本地', string.format('seed [%s], logic_version [%s]', g_seed, LOGIC_VERSION), get_time());
				--
			elseif 'savebug' == msg then
				-- for debug
				save_bug();
				--
			end
			cmd = 'rchat ' .. msg;
		elseif C_GUILD == channel then
			local gid = g_euser.gid or 0;
			local gpos = g_euser.gpos or GUILD_POS_NONE;
			if 0 >= gid or gpos == GUILD_POS_APPLY then
				add_chat_msg(C_GUILD, -1, '本地', string.format('未加入公会，不能发言'), get_time());
				return;
			end
			cmd = 'gchat ' .. msg;
		elseif C_PRIVATE == channel then
			if nil == self.chat_target then
				return;
			end
			local eid = self.chat_target.eid;
			--local alias = self.chat_target.alias;
			cmd = string.format("fchat %d %s", eid, msg);
		elseif C_LOG == channel then
			cmd = msg;
		end
		if true == g_scene:is_online() then
			net_send(cmd);
		end
	end,

	handler = function(event, x, y)
		local self = layer_chat;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		self.tpoint = ccp(x, y);
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)
		if nil == self.tpoint then
			return;
		end
		x = self.tpoint.x;
		y = self.tpoint.y;
		self.tpoint = nil;
		local t = self.editrect;
		if nil ~= t and x > t.x1 and x < t.x2 and y > t.y1 and y < t.y2 then
			play_tap_3();
			self.editlabel:setVisible(false);
			self.editbox:setVisible(true);
			self.editbox:sendActionsForControlEvents(CCControlEventTouchUpInside);
		end
		local r = self.rect_info;
		if nil == r then
			return;
		end
		if x > r.x1 and x < r.x2 and y > r.y1 and y < r.y2 then
			play_tap_1();
			--[[
			if 0 == is_wait_for_battle() then
				print('is_wait_for_battle');
				g_scene:add_layer(ZORDER_LAYER_INFO, layer_info:create(g_euser));
				return;
			end
			local zorder = ZORDER_LAYER_OTHERINFO;
			g_scene:add_layer(zorder, layer_info:create(g_euser, zorder));
			]]--
			g_scene:add_layer(ZORDER_LAYER_INFO, layer_info:create(g_euser));
			return;
		end
	end,

	is_legal = function(self, str)
		-- trim white space
		str = string.gsub(str, "%s", "");
		if 0 == string.len(str) then
			return false;
		end
		return true;
	end,

	edit_box_handler = function(eventname, psender)
		local self = layer_chat;
		local edit = tolua.cast(psender, "cc.EditBox");
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
			local str = edit:getText();
			str = util.string_cut_by_size(str, 60);
			if true == self:is_legal(str) then
				self:add_msg(str);	
			end
			edit:setText('');
			edit:setVisible(false);
			self.editlabel:setVisible(true);
		elseif eventname == "changed" then
		end

	end,

} -- layer_chat end

layer_debug = {
	name = 'layer_touch',
	layer = nil,
	stage = nil,
	label_texture = nil,

	cleanup = function(self)
		self.layer = nil;
		self.stage = nil;
		self.label_texture = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_DEBUG, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 128));

		self.stage = g_scene.this_stage;

		local pos, string;
		pos = cc.p(FULL_WIDTH, FULL_HEIGHT);
		string = 'LOGIC_VER: ' .. LOGIC_VERSION;
		string = string .. '\nGAME_VER: ' .. GAME_VERSION;
		util.add_label(self.layer, string, 30, pos, util.c_white,ANCHOR_RIGHT_UP);

		pos = cc.p(FULL_WIDTH, FULL_HEIGHT - 100);
		local cache = cc.Director:getInstance():getTextureCache();
		string = cache:getCachedTextureInfo();
		local sp = string.find(string, "TextureCache dumpDebugInfo", 1);
		string = string.sub(string, sp, string.len(string));
		self.label_texture = util.add_label(self.layer, string, 25, pos, util.c_white, ANCHOR_RIGHT_UP, nil, cc.size(HALF_WIDTH, 150), cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_TOP);

		local items = {};
		local item;
		local size = cc.size(172, 52);

		pos = ccp(FULL_WIDTH, FULL_HEIGHT-250);
		item = add_item_1(items, '清除', nil, 20, self.clean, ANCHOR_RIGHT_UP, pos, size);

		pos = ccp(HALF_WIDTH, FULL_HEIGHT-250);
		item = add_item_1(items, '重开', nil, 20, self.relaunch_game, ANCHOR_CENTER_UP, pos, size);

		pos = ccp(FULL_WIDTH, FULL_HEIGHT-320);
		item = add_item_1(items, '清教程', nil, 20, reset_tutor, ANCHOR_RIGHT_UP, pos, size);

		pos = ccp(FULL_WIDTH, FULL_HEIGHT-390);
		item = add_item_1(items, '清闯关教程', nil, 20, reset_svg_tutor, ANCHOR_RIGHT_UP, pos, size);

		util.add_menu(self.layer, items, 1);

		local lstr = '';
		local list = g_scene:get_layer_list();
		for i = 1, #list do
			local t = list[i];
			lstr = '\n' .. t .. lstr;
		end
		pos = cc.p(FULL_WIDTH, 0);
		util.add_label(self.layer, lstr, 25, pos, util.c_white, ANCHOR_RIGHT_DOWN, nil, cc.size(HALF_WIDTH, HALF_HEIGHT), cc.TEXT_ALIGNMENT_RIGHT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);


		if g_scene:is_stage(STAGE_LOGIN) then
			self:for_login();
		elseif g_scene:is_stage(STAGE_PVP) or g_scene:is_stage(STAGE_PVE) then
			self:for_game();
		elseif g_scene:is_stage(STAGE_MAP) then
			self:for_map();
		end

		return self.layer, self.name;
	end,

	clean_texture = function()
		local self = layer_debug;
		local cache = cc.Director:getInstance():getTextureCache();
		cache:removeUnusedTextures();
		string = cache:getCachedTextureInfo();
		local sp = string.find(string, "TextureCache dumpDebugInfo", 1);
		string = string.sub(string, sp, string.len(string));
		self.label_texture:setString(string);
	end,

	debug_function = function()
		g_scene:testlua();
	end,

	debug_card = function()
		local self = layer_debug;
		LOCAL_TEST = true;
		--self.cb_debug_card();
		g_scene:preload(self.cb_debug_card, layer_preload.START, STAGE_PVE);
		--[[
		local c = util.check_file('res_eff.plist');
		if c == true then
			path = "yes";
		else
			path = "no";
		end
		local layer, name = layer_text:create("path", path);
		g_scene:add_layer(ZORDER_LAYER_TEXT, layer, name);
		util.add_particle(layer, path, cc.p(HALF_WIDTH, HALF_HEIGHT), 10);
		]]--
	end,

	cb_debug_card = function()
		g_scene:pve(2);
	end,

	debug_local = function()
		--data_handler:cleanup();
		local self = layer_debug;
		LOCAL_TEST = false;
		-- TODO double time do game will crash
		--self.cb_debug_local()
		g_scene:preload(self.cb_debug_local, layer_preload.START, STAGE_PVE);
	end,

	cb_debug_local = function()
		local deck1_array, deck2_array;
		deck1_array = get_standard_deck_array(15);
		deck2_array = get_standard_deck_array(1);
		g_scene:pve(2, 200, deck1_array, deck2_array, false, 2);
	end,

	debug_c_function = function()
		--g_scene:cdebug();
	end,

	debug_replay = function()
		--g_scene:add_layer(ZORDER_LAYER_REPLAY, layer_replay:create());
	end,

	delete_res = function()
		--[[
		if nil == delete_download_resource then
			CLIENT_PATCH = CLIENT_PATCH_CONSTANT;
			util.save_rms(KEY_PATCH_INDEX, tonumber(CLIENT_PATCH), 'integer');
			local path = cc.FileUtils:getInstance():getWritablePath() .. 'res/';
			local list = KUtils:dfsFolder(path, 0);
			for i = 1, #list do
				local fname = list[i];
				local p = path .. fname;
				KUtils:deleteDownloadDir(p);
			end
			return;
		end
		]]--
		delete_download_resource();
		--util.relaunch_game();
	end,

	reload_res = function()
		CLIENT_PATCH = CLIENT_PATCH_CONSTANT or 1;
		util.save_rms(KEY_PATCH_INDEX, tonumber(CLIENT_PATCH), 'integer');
		util.relaunch_game();
	end,

	local_push = function()
		local platform = cc.Application:getInstance():getTargetPlatform();
		if platform == cc.PLATFORM_OS_IPHONE or platform == cc.PLATFORM_OS_IPAD then
			local args = { 
				sec = 0,
				min = 1,
				hours = 0,
				days = 0,
				startHour = 16,
				endHour = 20,
				message = 'IOS 本地推送测试',
			};
			local luaoc = require "luaoc";
			local class_name = "SysTool";
			local ok = luaoc.callStaticMethod(class_name, "setUpLocalPush", args);
		elseif platform == cc.PLATFORM_OS_ANDROID then
			local sec = 0;
			local min = 1;
			local hours = 0;
			local days = 0;
			local startHour = 16;
			local endHour = 20;
			local message = 'ANDROID 本地推送测试';
				--message, sec, min, hours, days, startHour, endHour
			local args = { 
				sec, min, hours, days, startHour, endHour, message
			};
			local sigs = "(IIIIIILjava/lang/String;)V";
			local luaj = require "luaj";
			local class_name = "org/cocos2dx/lua/AppActivity";
			local ok, ret = luaj.callStaticMethod(class_name, "setLocalPush", args, sigs);
		end
	end,

	clean_iap_record = function()
		local args = { };
		local luaoc = require "luaoc";
		local class_name = "IAPView";
		local ok, ret = luaoc.callStaticMethod(class_name, "cleanIAPrecord",args);
	end,

	test_iap = function()
		local args = { 
		};
		local luaoc = require "luaoc";
		local class_name = "IAPView";
		local ok, ret = luaoc.callStaticMethod(class_name, "testSend",args);
	end,

	for_login = function(self)
		local target = layer_login;
		local items = {};
		local item, pos;

		local size = cc.size(172, 52);
		pos = ccp(0, FULL_HEIGHT);
		item = add_item_1(items, '卡牌测试', nil, 20, self.debug_card, ANCHOR_LEFT_UP, pos, size);

		pos = ccp(0, FULL_HEIGHT-100);
		item = add_item_1(items, '单机测试', nil, 20, self.debug_local, ANCHOR_LEFT_UP, pos, size);

		pos = ccp(0, FULL_HEIGHT-200);
		item = add_item_1(items, '功能(lua)', nil, 20, self.debug_function, ANCHOR_LEFT_UP, pos, size);

		pos = ccp(0, FULL_HEIGHT-300);
		item = add_item_1(items, '测试下载', nil, 20, self.test_dres, ANCHOR_LEFT_UP, pos, size);

		pos = ccp(0, FULL_HEIGHT-400);
		item = add_item_1(items, '删除资源', nil, 20, self.delete_res, ANCHOR_LEFT_UP, pos, size);

		pos = ccp(0, FULL_HEIGHT-500);
		item = add_item_1(items, '重下资源', nil, 20, self.reload_res, ANCHOR_LEFT_UP, pos, size);

		pos = ccp(0, FULL_HEIGHT-600);
		item = add_item_1(items, '本地通知', nil, 20, self.local_push, ANCHOR_LEFT_UP, pos, size);

		pos = ccp(0, FULL_HEIGHT-700);
		item = add_item_1(items, '清楚IAP记录', nil, 20, self.clean_iap_record, ANCHOR_LEFT_UP, pos, size);

		--pos = ccp(0, FULL_HEIGHT-700);
		--item = add_item_1(items, 'IOS IAP', nil, 20, self.test_iap, ANCHOR_LEFT_UP, pos, size);

		--[[
		pos = ccp(0, 300);
		item = util.create_item_sprite_2(fname1,fname2,pos,ANCHOR_LEFT_UP,target.debug_c_function,'功能(c++)');
		table.insert(items, item);

		if true == RELOAD_MODE and true == DEBUG_MODE then
			pos = ccp(0, 400);
			item = util.create_item_sprite_2(fname1,fname2,pos,ANCHOR_LEFT_UP,target.restart,'重开');
			items:addObject(item);
			--util.add_labelttf(self.layer, '重开，即重新回到更新界面进行更新，会使用上面的服务器地址来进行更新，想得到不同地方的lua，可切换上面的服务器再点更新，此操作不会记录于本地，下次打开程序时，依旧会用默认的211.149.186.201进行更新', util.f_default, 23, ccp(HALF_WIDTH, 140), util.c_black, ANCHOR_CENTER_UP, data.zorder, CCSizeMake(FULL_WIDTH, 140), kCCTextAlignmentLeft);
		end
		]]--

		util.add_menu(self.layer, items, 1);
	end,

	win_ai = function()
		local self = layer_debug;
		self:remove();
		net_send("@win");
	end,

	for_game = function(self)
		local pos, string;
		pos = ccp(0, FULL_HEIGHT);
		local count = 0;
		for k, v in pairs(g_sprite_cache or {}) do
			count = count + 1;
		end
		string = '当前绘制卡牌数量: ' .. count;
		util.add_label(self.layer, string, 25, pos, util.c_white, ANCHOR_LEFT_UP, nil, cc.size(HALF_WIDTH, 200), cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_TOP);

		local items = {};
		local item, pos;

		local size = cc.size(172, 52);
		pos = ccp(0, FULL_HEIGHT/4*3);
		item = add_item_1(items, '@win', nil, 20, self.win_ai, ANCHOR_LEFT_UP, pos, size);

		util.add_menu(self.layer, items, 1);

	end,

	show_pay = function()
		local self = layer_debug;
		self:remove();
		net_send('lpay 1');
	end,

	show_guild = function()
		local self = layer_debug;
		self:remove();
		if true == g_euser:has_guild() then
			net_send('guild');
		else
			g_scene:lguild();
		end
	end,

	create_match = function()
		layer_debug:remove();
		g_scene:add_layer(ZORDER_LAYER_CMATCH, layer_cmatch:create());
	end,

	for_map = function(self)
		local items = {};
		local item, pos;

		local size = cc.size(172, 52);
		pos = ccp(0, FULL_HEIGHT);
		item = add_item_1(items, '创建比赛', nil, 20, self.create_match, ANCHOR_LEFT_UP, pos, size);

		pos = ccp(0, FULL_HEIGHT-90);
		item = add_item_1(items, '剧情教程', nil, 20, tutor_local, ANCHOR_LEFT_UP, pos, size);

		pos = ccp(0, FULL_HEIGHT-180);
		item = add_item_1(items, '新solo列表', nil, 20, show_list_solo, ANCHOR_LEFT_UP, pos, size);

		pos = ccp(0, FULL_HEIGHT-270);
		item = add_item_1(items, 'pay_ad', nil, 20, show_pay_ad, ANCHOR_LEFT_UP, pos, size);


		util.add_menu(self.layer, items, 1);
	end,

	test_dres = function()
		local self = layer_debug;
		send_dres('card1.png');
	end,

	handler = function(event, x, y)
		local self = layer_debug;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
	end,

	onTouchEnded = function(self, x, y)
		self:remove();
	end,
} -- layer_debug

layer_testlua = { -- layer_testlua start
	name = 'layer_testlua',
	layer = nil,
	list = {
		'1 label', '2 card', '3 result', '4 anim', '5 tutorial', '6 horse lamp',
		'7 luajit', '8 richlabel', '9 iap test error receipt', 
	},
	cwidth = nil,
	cheight = nil,

	cleanup = function(self)
		self.layer = nil;
		self.cwidth = nil;
		self.cheight = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();
		self.layer = cc.Layer:create();

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 200))

		util.reg_handler(self.layer, -ZORDER_LAYER_TESTLUA, self.handler, true);

		local items = {};
		local item, pos;
		local size = cc.size(172, 52);

		pos = cc.p(0, FULL_HEIGHT);
		item = add_item_1(items, '返回', nil, 20, self.back, ANCHOR_LEFT_UP, pos, size);

		util.add_menu(self.layer, items);

		pos = cc.p(0, 0);
		size = cc.size(FULL_WIDTH, FULL_HEIGHT-100);
		self.cwidth = size.width;
		self.cheight = 100;
		util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, 1);

		return self.layer, self.name;
	end,

	back = function()
		g_scene:login();
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_testlua;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			self:callback_case(idx+1);
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local name = self.list[idx+1];
			local pos = cc.p(0, self.cheight/2);
			util.add_label(cell, name, 40, pos, util.c_white, ANCHOR_LEFT_CENTER, 0, cc.size(self.cwidth, self.cheight), cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
			return cell;
		end
	end, -- tableview_handler end }

	callback_case = function(self, index)
		local input_list, name, num;
		name = self.list[index];
		--num = string.sub(name, 1, 1);
		input_list = split_num(name);
		num = input_list[1];
		local function_name = 'test' .. num;
		local fun_ptr = nil;
		fun_ptr = self[function_name];
		if nil == fun_ptr then
			print('ERROR function is nil: ', function_name);
			return;
		end

		-- implicit:  fun_ptr is non-nil
    	local layer_test = cc.Layer:create()
		util.add_layer_color(layer_test, ccc4(200, 200, 200, 255))
		fun_ptr(layer_test); 

		local items = {};
		local item;
		local size = cc.size(172, 52);
		local pos = cc.p(FULL_WIDTH, FULL_HEIGHT);
		item = add_item_1(items, '关闭', nil, 20, self.callback_close_test, ANCHOR_RIGHT_UP, pos, size);
		util.add_menu(layer_test, items);

		pos = ccp(0, FULL_HEIGHT);
		util.add_label(layer_test, name, 35, pos, util.c_black, ANCHOR_LEFT_UP, 1);
		g_scene:add_layer(ZORDER_LAYER_TESTLUA+20, layer_test);
	end,

	-- this is a generic close!
	callback_close_test = function(...)
		local arg = {...};
		local menu = arg[2];
		local layer = menu:getParent():getParent();  
		layer:removeFromParentAndCleanup(true);
	end,

	handler = function(event, x, y)
		local self = layer_testlua;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
	end,

	test1 = function(layer)
		show_test1(layer);
	end,

	test2 = function(layer)
		show_test2(layer);
	end,

	test3 = function(layer)
		show_test3(layer);
	end,

	test4 = function(layer)
		show_test4(layer);
	end,

	test5 = function(layer)
		show_test5(layer);
	end,

	test6 = function(layer)
		show_test6(layer);
	end,

	test7 = function(layer)
		show_test7(layer);
	end,

	test8 = function(layer)
		show_test8(layer);
	end,

	test9 = function(layer)
		show_test9(layer);
	end,
} -- layer_testlua end

layer_table = {  -- layer_table start
	name = 'layer_table',
	layer = nil,
	btn_chat = nil,
	btn_name_up = nil,
	btn_name_down = nil,
	phase = nil,
	gr = nil,
	gate_tip = nil,
	gate_msg = nil,

	cleanup = function(self)
		self.layer = nil;
		self.btn_chat = nil;
		self.btn_name_up = nil;
		self.btn_name_down = nil;
		self.phase = nil;
		self.gr = nil;
		self.gate_tip = nil;
		self.gate_msg = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_TABLE, self.handler, true);

		local sprite, data, side;
    	-- add desk background
		sprite = gui_add_sprite(self.layer, 'bg', GUI_MATCH);
		gui_add_sprite(self.layer, 'board', GUI_MATCH);
		gui_add_sprite(self.layer, 'arc_up', GUI_MATCH, ANCHOR_UP);
		gui_add_sprite(self.layer, 'arc_down', GUI_MATCH, ANCHOR_DOWN);
		gui_add_sprite(self.layer, 'bg_right_up', GUI_MATCH, ANCHOR_UP);
		sprite, data = gui_add_sprite(self.layer, 'res_up', GUI_MATCH);
		sprite, data = self:adjust_res(sprite, data);
		sprite:setRotation(180);
		sprite, data = gui_add_sprite(self.layer, 'res_down', GUI_MATCH);
		sprite, data = self:adjust_res(sprite, data);
		gui_add_sprite(self.layer, 'bg_btn_left', GUI_MATCH);
		gui_add_sprite(self.layer, 'bg_btn_right', GUI_MATCH);
		gui_add_sprite(self.layer, 'bg_hero_up', GUI_MATCH);
		gui_add_sprite(self.layer, 'bg_hero_down', GUI_MATCH);

        -- ===down side start===
		side = SIDE_DOWN;
        -- grave
		data = self:set_table('grave_down', side, T_GRAVE);
        -- deck
		data = self:set_table('deck_down', side, T_DECK);
        -- resource
		data = self:set_table('res_down', side, T_RES);
        -- support
		data = self:set_table('sup_down', side, T_SUPPORT);
        -- hand
		data = self:set_table('hand_down', side, T_HAND);
        -- ally
		data = self:set_table('ally_down', side, T_ALLY);
        -- hero
		data = self:set_table('hero_down', side, T_HERO);
		self.name_down = util.add_labeloutline(self.layer, '', nil, 25, cc.p(data.x, data.y+data.height/2), util.c4b_white, util.c4b_black, 1, ANCHOR_LEFT_DOWN, data.zorder - 2);
        -- ===down side end===
        
		-- ===up side start===
		side = SIDE_UP;
        -- grave
		data = self:set_table('grave_up', side, T_GRAVE);
        -- deck
		data = self:set_table('deck_up', side, T_DECK);
        -- resource
		data = self:set_table('res_up', side, T_RES);
        -- support
		data = self:set_table('sup_up', side, T_SUPPORT);
        -- hand
		data = self:set_table('hand_up', side, T_HAND);
        -- ally
		data = self:set_table('ally_up', side, T_ALLY);
        -- hero
		data = self:set_table('hero_up', side, T_HERO);
		self.name_up = util.add_labeloutline(self.layer, '', nil, 25, cc.p(data.x, data.y+data.height/2), util.c4b_white, util.c4b_black, 1, ANCHOR_LEFT_DOWN, data.zorder - 2);
		-- ===up side end  ===

		local items = {};
		local item;

		--[[
		item, data = gui_add_item(items, 'btn_left', GUI_MATCH, self.chat, ANCHOR_NULL);
		util.add_text_outline_to_sprite(item, '聊天', 25, util.c4b_gold, util.c4b_black, 1);
		self.btn_chat = item;
		]]--
		item, data = gui_add_item(items, 'btn_left', GUI_MATCH, self.tip, ANCHOR_NULL);
		--util.add_text_outline_to_sprite(item, '提示', 25, util.c4b_gold, util.c4b_black, 1);
		util.add_text_to_sprite(item, '提示', 28, util.c4b_text);

		if true == is_show_tip_btn() then
			--[[
			item, data = gui_add_item(items, 'btn_tip', GUI_MATCH, self.tip, ANCHOR_NULL);
			util.add_text_outline_to_sprite(item, '提示', 25, cc.c4b(data.r, data.g, data.b, 255), cc.c4b(data.sr, data.sg, data.sb, 255), 1);
			self:btn_tip_anim(item);
			]]--
			item, data = gui_add_item(items, 'btn_tip', GUI_MATCH, self.chat, ANCHOR_NULL);
			util.add_text_outline_to_sprite(item, '聊天', 25, cc.c4b(data.r, data.g, data.b, 255), cc.c4b(data.sr, data.sg, data.sb, 255), 1);
			self.btn_chat = item;
		end

		util.add_menu(self.layer, items, 100);

		self:set_name_btn();
		self:add_phase_tip();

		return self.layer, self.name;
	end,

	add_gate_msg = function(self, gate_msg_list)
		if nil == self.layer then return; end
		self.gate_msg = gate_msg_list or {};
	end,

	check_svg_tutorial = function()
		local flag = false;
		if false == flag then
			flag = util.trigger_tutor(TUTOR_FIRST_SAC);
		end
		if false == flag then
			flag = util.trigger_tutor(TUTOR_SECOND_SAC);
		end
	end,

	show_gate_msg = function(self, round)
		if 0 == round%2 then return; end
		local rr = math.floor(round/2) + round%2;
		for i = 1, #(self.gate_msg or {}) do
			local data = self.gate_msg[i];
			local gate_round = data.round;
			local r = math.floor(gate_round/2) + gate_round%2;
			--if round == data.round then
			if rr == r then
				local cid = data.card_id;
				local rc = g_card_list[cid];
				if nil == rc then
					rc = hero_list[cid];
				end
				if nil ~= rc then
					local card = clone(rc);	
					g_scene:add_layer(ZORDER_LAYER_GATEPOP, layer_gatepop:create(card, data.msg, layer_table.check_svg_tutorial));
				end
				--[[
				local actor = { name = rc.name, icon = 1, use_card_pic = true };
				local list_tip = { data.msg, };
				local layer, name = layer_story:create(actor, list_tip, nil);
				g_scene:add_layer(ZORDER_LAYER_STORY, layer, name);
				]]--
				return;
			end
		end
	end,

	add_gate_tip = function(self, gr)
		self.gr = gr;
		local data = gui_get_data('num_deck_up', GUI_MATCH);
		local pos = cc.p(data.x+data.width/2, data.y);
		local text = "第1回合\n";
		for i = 1, #gr do
			local r = gr[i];
			print('r: ', r);
			r = math.floor(r/2) + r%2;
			if i == 1 then
				text = text .. r;
			else
				text = text .. '-' .. r;
			end
		end
		--local label = util.add_labeloutline(self.layer, text, nil, 24, pos, util.c4b_gold, util.c4b_black, 2, ANCHOR_CENTER_CENTER, 10, cc.size(width, height), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
		self.gate_tip = util.add_labeloutline(self.layer, text, nil, 24, pos, util.c4b_gold, util.c4b_black, 2, ANCHOR_CENTER_CENTER, 90);
	end,

	update_gate_tip = function(self, round)
		self:show_gate_msg(round);
		if nil == self.gate_tip or nil == self.gr then return; end
		local rr = math.floor(round/2) + round%2;
		local text = "第" .. rr .. "回合\n";
		local offset = nil;
		for i = 1, #self.gr do
			local r = self.gr[i];
			r = math.floor(r/2) + r%2;
			text = text .. '-' .. r;
			if nil == offset and r >= rr then
				offset = r - rr;
			end
		end
		self.gate_tip:setString(text);
		if round%2 == 0 then return; end
		if nil == offset then return; end
		local msg;
		if 0 == offset then
			msg = "敌人即将出现";
		else
			msg = string.format("第%d回合\n离下一轮敌方出现还有%d个回合", rr, offset);
		end
		pop_gate_count(msg);

	end,

	add_phase_tip = function(self)
		local size = cc.size(wfix(200), hfix(64));--realsize
		if size.height < 64 then size.height = 64; end
		local path = util.get_path('pop_up.png');
		local frect = cc.rect(0, 0, 64, 64); -- fullrect
		local irect = cc.rect(30, 30, 4, 4); -- insetrect
		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		local bg = util.add_scale9sprite(self.layer, path, pos, ANCHOR_CENTER_CENTER, frect, irect, size, 10); 
		self.phase = bg;
		bg:setOpacity(200);
		local str;
		if phase == PHASE_SACRIFICE then
			str = '弃牌阶段';
		else
			str = '出牌阶段';
		end
		local label = util.add_labeloutline(bg, str, nil, 25, cc.p(size.width/2, size.height/2), util.c4b_gold, util.c4b_black, 2, ANCHOR_CENTER_CENTER, 10, cc.size(size.width-40, size.height-30), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
		label:setTag(333);

		--util.add_labeloutline(self.layer, str, nil, 28, cc.p(HALF_WIDTH, HALF_HEIGHT), util.c4b_black, util.c4b_white, 2, ANCHOR_CENTER_CENTER, 10, cc.size(size.width-40, size.height-30), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
	end,

	update_phase = function(self, side, phase)
		if nil == self.layer then return; end
		if nil == self.phase then return; end
		if side == g_euser.side then return; end -- my side only show phase
		local tag = 123;
		self.phase:stopActionByTag(tag);
		local function change()
			local str;
			if phase == -1 then
				str = '对方回合';
				if g_euser.side == SIDE_GUEST then
					if side == SIDE_UP then
						str = '上方回合';
					else
						str = '下方回合';
					end
				end
			elseif phase == PHASE_SACRIFICE then
				str = '弃牌阶段';
			else
				str = '出牌阶段';
			end
			local label = self.phase:getChildByTag(333);
			if nil == label then return; end
			label:setString(str);
		end
		local orbit_time = 0.3;
		local anims_array = {};
		local orbit1 = cc.OrbitCamera:create(orbit_time, 1, 0, 0, -90, 90, 0);
		local orbit2 = cc.OrbitCamera:create(orbit_time, 1, 0, 90, -90, 90, 0);
		table.insert(anims_array, orbit1);
		table.insert(anims_array, cc.CallFunc:create(change));
		table.insert(anims_array, orbit2);
		local action = cc.Sequence:create(anims_array);

		action:setTag(tag);
		self.phase:runAction(action);
	end,

	adjust_res = function(self, sprite, data)
		local x = data.x+data.width/2;
		local y = data.y+data.height/2;
		sprite:setPosition(cc.p(x, y));
		sprite:setAnchorPoint(ANCHOR_CENTER_CENTER);
		local scale = data.width/data.rwidth;
		if data.height/data.rheight < scale then
			scale = data.height/data.rheight;
		end
		sprite:setScale(scale);
		data.scale = scale;
		data.x = x;
		data.y = y;
		data.width = data.owidth * data.scale;
		data.height = data.oheight * data.scale;
		local path = util.get_path('res_eff.plist');
		util.add_particle(sprite, path, cc.p(data.rwidth/2, data.rheight/3*2),10);
		return sprite, data;
	end,

	btn_tip_anim = function(self, btn)
		--local sprite = btn:getNormalImage();
		local c = btn:getColor();
		local action, array;
		array = {};
		action = cc.TintTo:create(1, 150, 150, 100);
		table.insert(array, action);
		action = cc.TintTo:create(1, c.r, c.g, c.b);
		table.insert(array, action);
		action = cc.Sequence:create(array);
		action = cc.RepeatForever:create(action);
		btn:runAction(action);
	end,

	hide_name_btn = function(self, side)
		local label = nil;
		local tag = TAG_SPRITE_LABEL;
		if side == SIDE_UP then
			label = self.btn_name_up:getChildByTag(tag);
		else
			label = self.btn_name_down:getChildByTag(tag);
		end
		if nil == label then return; end
		label:setVisible(false);
	end,

	set_name_btn = function(self)
		if nil == g_euser.room_data then
			return;
		end
		local list = g_euser.room_data.guest_list or {};
		if 2 > #list then
			return;
		end
		local name_up = nil;
		local name_down = nil;
		local eid_up, eid_down;
		local is_guest = true;
		for i = 1, 2 do
			local info = list[i];
			if info.eid == g_euser.eid then
				is_guest = false;
				break;
			end
		end
		if true == is_guest then
			for i = 1, 2 do
				local info = list[i];
				if i == SIDE_DOWN then
					name_down = info.alias;
					eid_down = info.eid;
				else
					name_up = info.alias;
					eid_up = info.eid;
				end
			end
		else
			for i = 1, 2 do
				local info = list[i];
				if info.eid == g_euser.eid then
					name_down = info.alias;
					eid_down = info.eid;
				else
					name_up = info.alias;
					eid_up = info.eid;
				end
			end
		end
		if nil == name_down or nil == name_up then
			return;
		end

		local function cb(...)
			local args = {...};
			local tag = args[2]:getTag();
			if tag == g_euser.eid then return; end
			if tag < 500 then return; end
			local info = nil;
			for i = 1, 2 do
				local d = list[i];
				if d.eid == tag then
					info = d;
					break;
				end
			end
			g_scene:add_layer(ZORDER_LAYER_CHATPOP, layer_chatpop:create(info));
		end

		local items = {};
		local data, item, label;

		item,data = gui_add_item(items, 'bg_alias_up', GUI_MATCH, cb);
		label = gui_add_text_outline_on_sprite(item, name_up, 'alias_up', GUI_MATCH, nil, 23);
		item:setTag(eid_up);
		self.btn_name_up = item;

		item,data = gui_add_item(items, 'bg_alias_down', GUI_MATCH, cb);
		label = gui_add_text_outline_on_sprite(item, name_down, 'alias_down', GUI_MATCH, nil, 23);
		item:setTag(eid_down);
		self.btn_name_down = item;

		util.add_menu(self.layer, items, ZORDER_SHOWING+11);
	end,

	change_side = function(self, side)
		if nil == self.btn_name_up or nil == self.btn_name_down then return; end
		local s1, s2;
		local tag = TAG_SPRITE_LABEL;
		if side == SIDE_DOWN then
			s1 = self.btn_name_down:getChildByTag(tag);
			s2 = self.btn_name_up:getChildByTag(tag);
		elseif side == SIDE_UP then
			s1 = self.btn_name_up:getChildByTag(tag);
			s2 = self.btn_name_down:getChildByTag(tag);
		else
			return;
		end
		if nil ~= s1 then
			s1:setColor(cc.c3b(0, 255, 0));
		end
		if nil ~= s2 then
			s2:setColor(cc.c3b(255, 255, 255));
		end
		--pop_turn(g_euser.side, side);
		layer_table:update_phase(side, -1);
		if g_scene:is_stage(STAGE_PVG) then
			layer_table:update_gate_tip(g_round);
		end
	end,

	fix_size_ally_support = function(self, data, cwidth, cheight)
		local x, y, width, height, scale;
		local offsetx = 0;--5;--10;--20;
		local offsety = 0;--3;--13;
		y = data.y + data.height / 2;
		scale = (data.height-hfix(offsety*2))/cheight;
		x = data.x + wfix(offsetx) + cwidth * scale / 2;
		width = data.width - offsetx * 2;
		height = data.height - offsety * 2;
		return x, y, width, height, scale;
	end,

	set_table = function(self, key, side, _table)
		local cwidth = CARD_SIZE_2.width;
		local cheight = CARD_SIZE_2.height;
		local data = gui_get_data(key, GUI_MATCH);
		local x, y, width, height, scale;
		if _table == T_HAND then
			local gapy = hfix(30);
			width = data.width;
			height = data.height + gapy;
			x = data.x + cwidth / 2;
			y = data.y + data.height / 2;
			scale = height / cheight;
		elseif _table == T_ALLY or _table == T_SUPPORT then
			x, y, width, height, scale = self:fix_size_ally_support(data, cwidth, cheight);
		else
			x = data.x + data.width / 2;
			y = data.y + data.height / 2;
			width = data.width;
			height = data.height;
			scale = data.height / cheight;
		end
		if _table == T_HERO then
			local wscale = data.width / data.rwidth;
			local hscale = data.height / data.rheight;
			if wscale < hscale then
				scale = wscale;
			else
				scale = hscale;
			end
		end
		if _table == T_DECK then
			scale = 1;
		end
		local ui_table = g_ui_table[side][_table];
		local b = false;
		if _table == T_GRAVE then
			b = true;
		end
		self:set_frame(ui_table, x, y, width, height, scale, cwidth, cheight, b);
		return data;
	end,

	set_frame = function(self, frame, x, y, width, height, cscale, cwidth, cheight, is_grave)
		frame.x = x;
		frame.y = y;
		frame.width = width;
		frame.height = height;
		frame.cscale = cscale;
		frame.cwidth = cwidth * cscale;
		frame.cheight = cheight * cscale;
		if true == is_grave then
			local psize = PIC_SIZE;
			local pscale = width/psize.width;
			local pwidth = width;
			local pheight = math.floor(height * pscale);
			local gapy = pheight + hfix(6);
			frame.pic_width = pwidth;
			frame.pic_height = pheight;
			frame.pic_scale = pscale;
			frame.origin_y = y;
			frame.y = math.floor(y + height/2 - pheight/2);
			frame.cscale = pscale;
			frame.cwidth = cwidth * pscale;
			frame.cheight = cheight * pscale;
			frame.pic_len = math.floor(height/gapy) - 1;
		else
			frame.pic_width = nil;
			frame.pic_height = nil;
			frame.pic_scale = nil;
			frame.origin_y = nil;
			frame.pic_len = nil;
		end
	end,

	chat = function()
		play_tap_1();
		g_scene:add_layer(ZORDER_LAYER_CHAT, layer_chat:create(true));
	end,

	tip = function()
		play_tap_1();
--		if true == g_scene:is_stage(STAGE_PVP) then
--			tutor_pvp_attack();
--			return;
--		end
		if true == LOCAL_TEST then
			do_ai();
			return;
		end
		if true ~= g_scene:is_online() then
			return;
		end
		if g_euser.side ~= g_current_side then
			show_msg(t_lang("TIP_WAIT_OPPONENT"));
			return;
		end
		if false == is_touchable() then
			return;
		end
		if PHASE_SACRIFICE == g_phase then
--			util.set_tutor(TUTOR_RES, false, false);
--			util.set_tutor(TUTOR_SAC_TAP, false, false);
			util.trigger_tutor(TUTOR_RES);
		else
			local list = g_ui_table[g_euser.side][T_HAND];
			local info = nil;
			info = check_hl_in_list(list);
			if nil ~= info then
				-- can use card in hand
--				util.set_tutor(TUTOR_PLAY, false, false);
--				util.set_tutor(TUTOR_HL, false, false);
--				util.set_tutor(TUTOR_NEED_RES, false, false);
--				util.set_tutor(TUTOR_USE, false, false);
				util.trigger_tutor(TUTOR_PLAY);
				return;
			end
			list = g_ui_table[g_euser.side][T_ALLY];
			info = check_hl_in_list(list);
			if nil ~= info then
				-- can use card in ally
--				util.set_tutor(TUTOR_HL_ALLY, false, false);
--				util.set_tutor(TUTOR_TAP_ATTACK, false, false);
--				util.set_tutor(TUTOR_HL_ATTARGET, false, false);
--				util.set_tutor(TUTOR_TAP_ATTARGET, false, false);
				util.trigger_tutor(TUTOR_HL_ALLY);
				return;
			end
			if nil ~= g_src_index and g_src_index > 0 
				                  and g_action_type == TYPE_ATTACK then
				-- choose target to attack
--				util.set_tutor(TUTOR_HL_ATTARGET, false, false);
--				util.set_tutor(TUTOR_TAP_ATTARGET, false, false);
				util.trigger_tutor(TUTOR_HL_ATTARGET);
				return;
			end
			info = g_ui_table[g_euser.side][T_HERO][1];
			if nil ~= info then
				--[[
				local s = info:get_sprite();
				local h = s:getChildByTag(TAG_HIGHLIGHT);
				local index = cindex(info.card);
				local indexs = list_ability_target(index, g_logic_table, g_current_side, {}, 1);
				if nil ~= h and #indexs > 0 then
					util.set_tutor(TUTOR_HL_HERO, false, false);
					util.set_tutor(TUTOR_TAP_ABHERO, false, false);
					util.trigger_tutor(TUTOR_HL_HERO);
					return;
				end
				]]--
				local kind = check_kind(info.card, g_logic_table, g_current_side, g_phase);
				if kind == AKIND_ABILITY or kind == AKIND_BOTH then
--					util.set_tutor(TUTOR_HL_HERO, false, false);
--					util.set_tutor(TUTOR_TAP_ABHERO, false, false);
					util.trigger_tutor(TUTOR_HL_HERO);
					return;
				end
			end
--			util.set_tutor(TUTOR_NEXT, false, false);
			util.trigger_tutor(TUTOR_NEXT);
		end
	end,

	handler = function(event, x, y)
		local self = layer_table;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
}  -- layer_table end

layer_card = {
	name = 'layer_card',
	layer = nil,   -- @see init()
	touch_point = nil,
	btn_next = nil,
	btn_confirm = nil,
	btn_skip = nil,
	btn_cancel = nil,
	-- action target list ,such as ability target list
	-- @see callback_cancel()  : reset to empty (write)
	ability_target_list = {},
	touch_card = {ltype = 0, index = 0},
	target_card = nil, -- will init in onTouchMove
	p_drag = nil, -- particle drag
	p_pointer = nil, 
	p_hand = nil,
	label_count_deck = {},
	time_start = nil,
	next_timeout = nil,
	list_grave = { [SIDE_UP] = nil, [SIDE_DOWN] = nil, },
	count_label = nil,
	--round_label = nil,
	list_player = { [SIDE_UP] = nil, [SIDE_DOWN] = nil, },
	touch_func = nil,
	should_start_next_after_result = nil,
	time_touch_down = nil,
	--touch_y = nil,
	tip_help = nil,

	cleanup = function(self)
		self.layer = nil;
		self.touch_point = nil;
		self.btn_next = nil;
		self.btn_confirm = nil;
		self.btn_skip = nil;
		self.btn_cancel = nil;
		self.ability_target_list = {};
		self.touch_card = {ltype = 0, index = 0};
		self.target_card = nil; -- will init in onTouchMove
		self.p_drag = nil;
		self.p_pointer = nil;
		self.p_hand = nil;
		self.label_count_deck = {};
		self.time_start = nil;
		self.next_timeout = nil;
		self.list_grave = { [SIDE_UP] = nil, [SIDE_DOWN] = nil, };
		self.count_label = nil;
		--self.round_label = nil;
		self.list_player = { [SIDE_UP] = nil, [SIDE_DOWN] = nil, };
		self.touch_func = nil;
		self.should_start_next_after_result = nil;
		self.time_touch_down = nil;
		--self.touch_y = nil;
		self.tip_help = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();
		
		self.layer = cc.Layer:create();
        
		util.reg_handler(self.layer, -ZORDER_LAYER_CARD, self.handler, false);

		self:init_cards();
		--self:add_table_alias();

		-- resource label
		self:init_res_label(g_logic_table, g_ui_table);

		local items = {};
		local item, data;

		item, data = gui_add_item(items, 'btn_right', GUI_MATCH, self.callback_next_side, ANCHOR_NULL);
		--util.add_text_outline_to_sprite(item, '结束', 25, util.c4b_gold, util.c4b_black, 1);
		util.add_text_to_sprite(item, '结束', 28, util.c4b_text);
		self.btn_next = item;
		item:setVisible(false);
		
		item, data = gui_add_item(items, 'btn_center', GUI_MATCH, self.callback_confirm, ANCHOR_NULL);
		--util.add_text_outline_to_sprite(item, '确定', 25, util.c4b_gold, util.c4b_black, 1);
		util.add_text_to_sprite(item, '确定', 28, util.c4b_text);
		self.btn_confirm = item;
		item:setVisible(false);

		item, data = gui_add_item(items, 'btn_right', GUI_MATCH, self.callback_skip_sac, ANCHOR_NULL);
		--util.add_text_outline_to_sprite(item, '跳过', 25, util.c4b_gold, util.c4b_black, 1);
		util.add_text_to_sprite(item, '跳过', 28, util.c4b_text);
		self.btn_skip = item;
		item:setVisible(false);

		item, data = gui_add_item(items, 'btn_right', GUI_MATCH, self.callback_cancel, ANCHOR_NULL);
		--util.add_text_outline_to_sprite(item, '取消', 25, util.c4b_gold, util.c4b_black, 1);
		util.add_text_to_sprite(item, '取消', 28, util.c4b_text);
		self.btn_cancel = item;
		item:setVisible(false);

		--util.add_menu(self.layer, items, ZORDER_MENU);
		util.add_menu(self.layer, items, ZORDER_CARD+10);

		--[[
		local path, pos, info, count, lup, ldown, data;
		path = util.get_path('font3_30.fnt');
		data = gui_get_data('num_deck_up', GUI_MATCH);
		info = g_ui_table[SIDE_UP][T_DECK];
		count = #(g_logic_table[SIDE_UP][T_DECK]);
		--pos = ccp(info.x, info.y);
		pos = ccp(data.x, data.y);
		--lup=util.add_labelbmf(self.layer,count,fullpath,pos,ANCHOR_CENTER_CENTER,ZORDER_COUNT_DECK);
		lup=util.add_labelbmf(self.layer,count,path,pos,ANCHOR_LEFT_DOWN,data.zorder);
		lup:setScale(0.8);
		info = g_ui_table[SIDE_DOWN][T_DECK];
		data = gui_get_data('num_deck_down', GUI_MATCH);
		count = #(g_logic_table[SIDE_DOWN][T_DECK]);
		--pos = ccp(info.x, info.y);
		pos = ccp(data.x, data.y);
		--ldown=util.add_labelbmf(self.layer,count,fullpath,pos,ANCHOR_CENTER_CENTER,ZORDER_COUNT_DECK);
		ldown=util.add_labelbmf(self.layer,count,path,pos,ANCHOR_LEFT_DOWN,data.zorder);
		ldown:setScale(0.8);
		self.label_count_deck = { [SIDE_UP] = lup, [SIDE_DOWN] = ldown };
		]]--

		self:init_deck_num(g_logic_table);
		
		--self:set_name_btn();
		
		return self.layer, self.name;
	end,

	set_wait_result = function(self)
		self.should_start_next_after_result = true;
	end,


	show_tip_help = function(self, tips)
		self:remove_tip_help();

		tips = tips or '';

--		local size = cc.size(wfix(200), hfix(64));--realsize
		local size = cc.size(FULL_WIDTH/4*3, HALF_HEIGHT/4);
		if size.height < 64 then size.height = 64; end
		local path = util.get_path('pop_up.png');
		local frect = cc.rect(0, 0, 64, 64); -- fullrect
		local irect = cc.rect(30, 30, 4, 4); -- insetrect
		local pos = cc.p(HALF_WIDTH, FULL_HEIGHT - 30);
		local bg = util.add_scale9sprite(self.layer, path, pos, ANCHOR_CENTER_UP, frect, irect, size, 100); 
		self.tip_help = bg;
		local label = util.add_labeloutline(bg, tips, nil, 25, cc.p(size.width/2, size.height/2), util.c4b_gold, util.c4b_black, 2, ANCHOR_CENTER_CENTER, 10, cc.size(size.width-40, size.height-30), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
	end,

	remove_tip_help = function(self)
		if nil ~= self.tip_help then
			self.tip_help:removeFromParent(true);
			self.tip_help = nil;
		end
	end,



	init_deck_num = function(self, logic_table)
		local path = util.get_path(FNT_CARD);
		local scale = 0.8;

		local function set_label(side, key)
			local data = gui_get_data(key, GUI_MATCH);
			local count = #(g_logic_table[side][T_DECK]);
			--pos = ccp(data.x, data.y);
			--label=util.add_labelbmf(self.layer,count,path,pos,ANCHOR_LEFT_DOWN,data.zorder);
			pos = cc.p(data.x+data.width/2, data.y);
			if key == "num_deck_down" then
				pos.y = pos.y + data.height;
			end
			label=util.add_labelbmf(self.layer,count,path,pos,ANCHOR_LEFT_CENTER,data.zorder);
			label:setScale(scale);
			return label;
		end
		local lup = set_label(SIDE_UP, 'num_deck_up');
		local ldown = set_label(SIDE_DOWN, 'num_deck_down');
		self.label_count_deck = { [SIDE_UP] = lup, [SIDE_DOWN] = ldown };
	end,

	add_table_alias = function(self, data, title)
		gui_add_sprite(self.layer, 'l_ally_down', GUI_MATCH);
		gui_add_sprite(self.layer, 'l_ally_up', GUI_MATCH);
		gui_add_sprite(self.layer, 'l_supp_down', GUI_MATCH);
		gui_add_sprite(self.layer, 'l_supp_up', GUI_MATCH);
	end,

	add_clock = function(self, layer)
		local sprite, data, pos;
		-- 回合倒计时
		--sprite, data = gui_add_sprite(layer,'time',GUI_MATCH,ANCHOR_LEFT_UP);
		gui_add_sprite(layer,'bg_time', GUI_MATCH, ANCHOR_UP);
		local data, scale = gui_get_data('t_time', GUI_MATCH, ANCHOR_UP);
		--pos = ccp(data.x+80, data.height/2);
		--pos = ccp(data.x+60, data.height/2);
		local pos = cc.p(data.x, data.y);
		--local fontpath = util.get_fullpath(F_FONT, FNT_TIME);
		local path = util.get_path(FNT_TIME);
		self.count_label = util.add_labelbmf(layer,'--',path, pos, ANCHOR_LEFT_DOWN, data.zorder);
		self.count_label:setScale(scale);

		--pos = ccp(data.x+120, data.height/2);
		--self.round_label = util.add_labelbmf(sprite,'',fontpath, pos, ANCHOR_LEFT_CENTER);
	end,

	update_player_info = function(self, data)
		local channel = data.channel;
		local room_id = data.room_id;
		local st = data.st;
		local texture_cache = CCTextureCache:sharedTextureCache();
		local texture_cache = cc.Director:getInstance():getTextureCache();
		local guest_list = data.guest_list;
		for i = 1, #guest_list do
			local info = guest_list[i];
			local icon = info.icon;
			local uinfo = self.list_player[i];
			if nil ~= uinfo then
				local avatar = uinfo.icon;
				local size = uinfo.size;
				local fullpath = get_icon_path(icon);
				local texture = texture_cache:addImage(fullpath);
				avatar:setTexture(texture);
				local s = avatar:getContentSize();
				avatar:setScaleX(size.width/s.width);
				avatar:setScaleY(size.height/s.height);
			end
		end
	end,

	init_res_label = function(self, logic_table, ui_table)
		local path = util.get_path(FNT_CARD);
		local scale = 0.6;

		local function set_label(side, key)
			local label, pos, str;
			local t = logic_table[side];
			local data = gui_get_data(key, GUI_MATCH);
			pos = cc.p(data.x+34, data.y);
			str = string.format("%d", t.resource); 
			label = util.add_labelbmf(self.layer,str,path,pos,ANCHOR_RIGHT_DOWN,data.zorder,cc.TEXT_ALIGNMENT_RIGHT,0);
			label:setScale(scale);
			ui_table.label_res[side] = label;

			pos = cc.p(data.x+35, data.y);
			label = util.add_labelbmf(self.layer,"/",path,pos,ANCHOR_LEFT_DOWN,data.zorder,cc.TEXT_ALIGNMENT_CENTER,0);
			label:setScale(scale);

			pos = cc.p(data.x+44, data.y);
			str = string.format("%d", t.resource_max); 
			label = util.add_labelbmf(self.layer,str,path,pos,ANCHOR_LEFT_DOWN,data.zorder,cc.TEXT_ALIGNMENT_LEFT,0);
			label:setScale(scale);
			ui_table.label_res_max[side] = label;
		end

		set_label(SIDE_UP, 'res_num_up');
		set_label(SIDE_DOWN, 'res_num_down');
	end,

	--[[
	init_res_label = function(self, logic_table, ui_table, side)
		local fullpath, label, str, data, pos, size;
		fullpath = util.get_fullpath(F_FONT, FNT_CARD);
		-- res value
		local t = logic_table[side];
		data = ui_table[side][T_RES];
		local hhh, y;
		if side == SIDE_UP then
			hhh = ANCHOR_DOWN;
			y = data.y+data.height/2+hfix(15);
		else
			hhh = ANCHOR_UP;
			y = data.y-data.height/2-hfix(15);
		end

		pos = cc.p(data.x - data.width/2 - wfix(16), y);
		str = string.format("%d", t.resource); 
		label = util.add_labelbmf(self.layer,str,fullpath,pos,cc.p(ANCHOR_RIGHT, hhh), data.zorder, cc.TEXT_ALIGNMENT_RIGHT, 0);
		ui_table.label_res[side] = label;

		pos = cc.p(data.x - data.width/2 - wfix(8), y);
		label = util.add_labelbmf(self.layer,"/",fullpath,pos,cc.p(ANCHOR_CENTER, hhh), data.zorder, cc.TEXT_ALIGNMENT_CENTER, 0);

		pos = cc.p(data.x - data.width/2, y);
		str = string.format("%d", t.resource_max); 
		label = util.add_labelbmf(self.layer,str,fullpath,pos,cc.p(ANCHOR_LEFT, hhh), data.zorder, cc.TEXT_ALIGNMENT_LEFT, 0);
		ui_table.label_res_max[side] = label;
	end,
	]]--

	update_res_label = function(self, logic_table, ui_table, side)
		if g_scene:is_stage(STAGE_PVG) then
			if side == SIDE_UP then
				return;
			end
		end
		local label_res, label_res_max;
		local t = logic_table[side];
		label_res = ui_table.label_res[side];
		label_res:setString(t.resource);
		label_res_max = ui_table.label_res_max[side];
		label_res_max:setString(t.resource_max);
	end,

	update_count_label = function(self, logic_table)
		local list = self.label_count_deck;
		local slist = { SIDE_UP, SIDE_DOWN };
		for i = 1, #slist do
			local side = slist[i];
			local label = list[side];
			if nil ~= label then
				local count = #(logic_table[side][T_DECK]);
				label:setString(count);
			end
		end
	end,

	hide_all_btn = function(self)
		if g_scene:is_stage(STAGE_REPLAY) then
			return;
		end
		if g_euser.side == SIDE_GUEST then
			return;
		end
		if true == self.btn_skip:isVisible() then
			enable_btn(self.btn_skip, false);
			--self.btn_next:setVisible(false);
			self.btn_next:setVisible(true);
			enable_btn(self.btn_next, false);
			self.btn_confirm:setVisible(false);
			self.btn_cancel:setVisible(false);
		elseif true == self.btn_confirm:isVisible() and true == self.btn_cancel:isVisible() then
			enable_btn(self.btn_confirm, false);
			enable_btn(self.btn_cancel, false);
			self.btn_next:setVisible(false);
			self.btn_skip:setVisible(false);
		else
			self.btn_next:setVisible(true);
			enable_btn(self.btn_next, false);
			self.btn_confirm:setVisible(false);
			self.btn_skip:setVisible(false);
			self.btn_cancel:setVisible(false);
		end
	end,

	set_to_table = function(self, side, _table)
		local logic_table = g_logic_table[side][_table];
		local ui_table = g_ui_table[side][_table];
		local cwidth = CARD_SIZE_2.width;
		local cheight = CARD_SIZE_2.height;
		local cscale = ui_table.cscale;
		local gap;
		if ui_table.ltype == UP_GRAVE or ui_table.ltype == DOWN_GRAVE or 
		   ui_table.ltype == UP_DECK or ui_table.ltype == DOWN_DECK then
			gap = 0;
		else
			gap = calculate_gap(#logic_table, cwidth * cscale, ui_table.width, ui_table.ltype);
		end
		
		for i = 1, #logic_table do
			local card = logic_table[i]; 
			local pos;
			local rotation = 0;
			pos, rotation = get_card_pos_rotation(ui_table, gap, i, #logic_table);
			add_ui_card(self.layer, ui_table, pos, rotation, card);
		end
	end,

	init_cards = function(self)
        -- ===down side start===
		local side = SIDE_DOWN;
		-- deck
		self:set_to_table(side, T_DECK);
		-- grave
		self:set_to_table(side, T_GRAVE);
		-- hero
		self:set_to_table(side, T_HERO);
		-- hand
		self:set_to_table(side, T_HAND);
		-- support
		self:set_to_table(side, T_SUPPORT);
		-- ally
		self:set_to_table(side, T_ALLY);
        -- ===down side end===
        -- ===up side start===
		side = SIDE_UP;
		-- deck
		self:set_to_table(side, T_DECK);
		-- grave
		self:set_to_table(side, T_GRAVE);
		-- hero
		self:set_to_table(side, T_HERO);
		-- hand
		self:set_to_table(side, T_HAND);
		-- support
		self:set_to_table(side, T_SUPPORT);
		-- ally
		self:set_to_table(side, T_ALLY);
        -- ===up side end===
	end,
	
	clean_menu = function(self)
		self:change_btn(self.btn_next);
	end,

	update_next_count = function(dt)
		local self = layer_card;
		local t = os.time() - self.time_start;
		--print('os.time: ', t);
		local str = self.next_timeout - t;
		if t > self.next_timeout then
			self:stop_timeout();
			if PHASE_SACRIFICE ~= g_phase or g_euser.side ~= g_current_side then
				enable_btn(self.btn_next, true);
			end
			str = '--';
		end
		local label = self.count_label;
		if nil == label then return; end
		label:setString(str);
	end,

	stop_timeout = function(self)
		self.next_timeout = nil;
		self.time_start = nil;
		self.count_label:setString('--');
		self.layer:unscheduleUpdate();
	end,

	check_timeout = function(self)
		if g_euser.side ~= g_current_side then
			if nil == self.next_timeout then
				enable_btn(self.btn_next, true);
			end
		end
	end,

	show_timeout = function(self, timeout)
		--print("---- show_timeout");
		self:stop_timeout();
		timeout = timeout or 30;
		self.count_label:setString(timeout);
		self.next_timeout = timeout;
		self.time_start = os.time();
		self.layer:scheduleUpdateWithPriorityLua(self.update_next_count, 1);
	end,

	handle_next_timeout = function(self, timeout)
		--self.round_label:setString(g_round or '');
		--print("---- handle_next_timeout");
		if g_scene:is_stage(STAGE_PVG) then
			return;
		end
		if g_scene:is_stage(STAGE_REPLAY) then
			return;
		end
		local dtimeout = tonumber(g_constant.max_timeout) or 60;
		timeout = tonumber(timeout or dtimeout);
		--print('timeout: ', timeout);
		if true == LOCAL_TEST or true ~= g_scene:is_online() then
			if PHASE_SACRIFICE ~= g_phase then
				self:change_btn(self.btn_next);
			end
			enable_btn(self.btn_next, true);
			return;
		end
		local s1 = g_euser.side;
		local s2 = g_current_side;
		self:show_timeout(timeout);
		if g_euser.side == SIDE_GUEST then
			return;
		end
		if nil ~= timeout and g_euser.side ~= g_current_side then
			self:change_btn(self.btn_next);
			self:hide_all_btn();
		end
	end,

	-- a, b, n
	visible_btn_by_cmd = function(self, cmd_type, is_show)
		if 'n' == cmd_type then
			self:change_btn(self.btn_next);
			self:hide_all_btn();
		end
	end,

	refresh_virtual = function(self, sprite, card)
		--[[
		local s = sprite:getChildByTag(TAG_STATUS_SPRITE);
		if nil ~= s then
			local e = s:getActionByTag(TAG_STATUS_EFF);
			print('e: ', e);
		end

		local action = sprite:getActionByTag(TAG_VIRTUAL_ACTION);
		if nil ~= action then
			local is_done = action:isDone();
		end
		local particle = sprite:getChildByTag(TAG_VIRTUAL_PARTICLE);
		if nil ~= particle then
			particle:removeFromParentAndCleanup(true);
		end
		local vtype = card.vtype or 0;
		create_virtual_particle(sprite, vtype);
		]]--
		update_attachment_timer(sprite, card);
		return sprite;
	end,

	refresh_card_attach = function(self, sprite, card)
		local new_alist = { cscale = 1 }; -- new attach_list
		local alist = card.attach_list or {};
		local a_index = 1;
		local v_index = 1;
		for i=1, #alist do
			local ac = alist[i];
			local ac_sprite = g_sprite_cache[ac];
			local size = sprite:getContentSize();
			local pos = ccp(size.width / 2, size.height / 2);
			if ac.id > 1000 then -- virtual card
				local ainfo;
				if nil ~= ac_sprite then
					ac_sprite = self:refresh_virtual(ac_sprite, ac);
					ainfo = add_ui_card(sprite, new_alist, pos, 0, ac, ac_sprite);
					ainfo:reset_zorder(v_index);
				else
					local ainfo = add_ui_card(sprite, new_alist, pos, 0, ac);
					ainfo:reset_zorder(v_index);
				end
				v_index = v_index + 1;
			else  -- not virtual card
				pos.y = pos.y + a_index * math.floor(size.height / 7);
				if nil ~= ac_sprite then
					ac_sprite:removeFromParentAndCleanup(true);
					g_sprite_cache[ac] = nil;
				end
				local ainfo = add_ui_card(sprite, new_alist, pos, 0, ac);
				ainfo:reset_zorder(ZORDER_CARD_ATTACH-a_index);
				a_index = a_index + 1;
			end
		end
		return new_alist;
	end,

	refresh_hero_attach = function(self, sprite, card)
		local new_alist = { cscale = 0.4 }; -- new attach_list
		local alist = card.attach_list or {};
		local a_index = 1;
		local v_index = 1;
		for i=1, #alist do
			local ac = alist[i];
			local ac_sprite = g_sprite_cache[ac];
			local size = sprite:getContentSize();
			local pos = ccp(size.width / 2, size.height / 2);
			if ac.id > 1000 then -- virtual card
				local ainfo;
				if nil ~= ac_sprite then
					ac_sprite = self:refresh_virtual(ac_sprite, ac);
					ainfo = add_ui_card(sprite, new_alist, pos, 0, ac, ac_sprite);
					ainfo:reset_zorder(v_index);
				else
					local ainfo = add_ui_card(sprite, new_alist, pos, 0, ac);
					ainfo:reset_zorder(v_index);
				end
				v_index = v_index + 1;
			else  -- not virtual card
				pos.y = pos.y + math.floor(size.height / 7);
				if nil ~= ac_sprite then
					ac_sprite:removeFromParentAndCleanup(true);
					g_sprite_cache[ac] = nil;
				end
				pos.x = pos.x + size.width/5 + (a_index-1)*20;
				local rotation = 15 + (a_index-1)*20;
				local ainfo = add_ui_card(sprite, new_alist, pos, rotation, ac);
				ainfo:reset_zorder(ZORDER_CARD_ATTACH-a_index);
				a_index = a_index + 1;
			end
		end
		return new_alist;
	end,

	refresh_card = function(self, sprite, card, pos, rotation, scale)
		local new_alist = { cscale = 1 }; -- new attach_list
		if nil == card then
			kerror("refresh_card card is nil");
			return sprite, new_alist;
		end
		if nil == sprite then
			kerror("refresh_card sprite is nil");
			return sprite, new_alist;
		end

		sprite:setRotation(rotation or 0);
		local width = sprite:getContentSize().width;
		local height = sprite:getContentSize().height;
		sprite:setAnchorPoint(ANCHOR_CENTER_CENTER);
		sprite:setPosition(ccp(pos.x, pos.y));
		sprite:setScale(scale);
		if card.ctype == HERO then
			new_alist = self:refresh_hero_attach(sprite, card);
		else
			new_alist = self:refresh_card_attach(sprite, card);
		end

		-- refresh card info label
		local label;
		label = sprite:getChildByTag(TAG_COST);
		tolua.cast(label, "cc.Label");
		if nil ~= label then -- T_DECK, sprite is cover.png has no label on it
			label:setString(card.cost);
		end
		
		label = sprite:getChildByTag(TAG_HP);
		tolua.cast(label, "cc.Label");
		if nil ~= label then -- T_DECK, sprite is cover.png has no label on it
			label:setString(card.hp);
		end

		label = sprite:getChildByTag(TAG_POWER);
		tolua.cast(label, "cc.Label");
		if nil ~= label then -- T_DECK, sprite is cover.png has no label on it
			local ppp;
			if card.ctype == HERO then
				ppp = card.energy;
			else
				ppp = card.power;
			end
			label:setString(ppp);
		end

		refresh_card_status(sprite, card, width, height);

		return sprite, new_alist;
	end,

	-- refresh sprite in table list 
	--  such as hp, cost, power (CCLabelBMFont)
	--  if do not have the sprite, create a new one
	-- TODO create a method to check which sprite is deprecated and remove it
	refresh_table_list = function(self, logic_table, ui_table)
		local cwidth = CARD_SIZE_2.width;
		local cheight = CARD_SIZE_2.height;
		local cscale = ui_table.cscale;
		local gap;
		if ui_table.ltype == UP_GRAVE or ui_table.ltype == DOWN_GRAVE or 
		   ui_table.ltype == UP_DECK or ui_table.ltype == DOWN_DECK then
			gap = 0;
		else
			gap = calculate_gap(#logic_table, cwidth*cscale, ui_table.width, ui_table.ltype);
		end

		local newlist = object_uitable:new(ui_table.ltype);
		newlist.cscale = cscale;

		for i = 1, #logic_table do
			local card = logic_table[i];
			local sprite = g_sprite_cache[card];
			local attach_list, pos;
			local rotation = 0;
			local ci = cindex(card);
			local table_index = index_table_num(ci);
			local side_index = index_side(ci);
			local ni, ns; -- new info, new sprite
			if nil ~= sprite then
				pos,rotation = get_card_pos_rotation(ui_table,gap,i,#logic_table);
				sprite,attach_list = self:refresh_card(sprite,card,pos,rotation,cscale);
				ni, ns = add_ui_card(self.layer,newlist,pos,rotation,card,sprite,attach_list);
			else
				pos,rotation = get_card_pos_rotation(ui_table,gap,i,#logic_table);
				ni, ns = add_ui_card(self.layer, newlist, pos, rotation, card);
			end
			--print('card.name: ', ni.card.name, ci, table_index, T_DECK);
			if nil ~= ns then
				if true == USE_ANIM then
					if table_index == T_DECK then
						ni:flip_to_cover();
					elseif table_index == T_HAND then
						if true == data_handler.show_all_card or 
						   true == SHOW_ALL or
						   (side_index == SIDE_DOWN and g_euser.side == SIDE_DOWN) then
							ni:flip_to_front();
						else
							ni:flip_to_cover();
						end
					end
				else
					if true == LOCAL_TEST and table_index ~= T_HERO and 
					   table_index ~= T_GRAVE then
						ni:flip_to_front();
					elseif table_index == T_DECK or 
						(side_index == SIDE_UP and table_index == T_HAND) then
						ni:flip_to_cover();
					elseif table_index == T_ALLY or table_index == T_SUPPORT or
						   (side_index == SIDE_DOWN and table_index == T_HAND) then
						ni:flip_to_front();
					end
				end
			end
		end
		local total;
		total = #ui_table;
		for i = 1, total do
			table.remove(ui_table, 1);
		end
		total = #newlist;
		for i = 1, total do
			table.insert(ui_table, newlist[i]);
		end
		return newlist;
	end,

	-- refresh one card_list' zorder e.g. g_ui_table[SIDE_DOWN][T_HAND]
	refresh_clist_zorder = function(self, clist, new_zorder)
		clist = clist or {};
		local start_idx = 1;
		local end_idx = #clist;
		local inc = 1;
		if clist.ltype == UP_DECK or clist.ltype == DOWN_DECK then
			start_idx = #clist;
			end_idx = 1;
			inc = -1;
		end
		for i=start_idx, end_idx, inc do
			local obj = clist[i];
			local zorder;
			local sprite;
			sprite = obj:get_sprite(true);	
			if nil ~= new_zorder then
				zorder = new_zorder;
			else
				zorder = obj.frame.zorder;
			end
			if nil ~= sprite then
				-- TODO maybe bug if use the same zorder
				self.layer:reorderChild(sprite, zorder);
			end
		end
	end,

	refresh_table = function(self, side, _table)
		local logic_table = g_logic_table[side][_table];
		local ui_table = g_ui_table[side][_table];
		self:refresh_table_list(logic_table, ui_table);
		self:refresh_clist_zorder(ui_table, ZORDER_CARD);
	end,

	-- refresh card sprite's attribute(hp, cost, power, attach_list)
	-- and create new card if need
	refresh_layer = function(self)
		self.touch_point = nil;
		g_src_index = 0;  -- this is global
		self:change_btn(self.btn_next);
		self:hide_all_btn();
		
		remove_hl();
		local lside = { SIDE_DOWN, SIDE_UP };
		local ltable = { T_DECK, T_GRAVE, T_HERO, T_HAND, T_SUPPORT, T_ALLY };
		for i = 1, #lside do
			for j = 1, #ltable do
				self:refresh_table(lside[i], ltable[j]);
			end
		end
		if g_euser.side == SIDE_DOWN then
			local ui_deck_table = g_ui_table[SIDE_DOWN][T_DECK];
			if is_view_top() and #ui_deck_table > 0
			and ui_deck_table[1].status == CARD_COVER then
				ui_deck_table[1]:flip_to_front();
			end

			local ui_oppo_hand_table = g_ui_table[SIDE_UP][T_HAND];
			if is_view_oppo() then
				local hidx;
				for hidx = 1, #ui_oppo_hand_table do
					if ui_oppo_hand_table[hidx].status == CARD_COVER then
						ui_oppo_hand_table[hidx]:flip_to_front();
					end
				end
			end
		end

		self:update_res_label(g_logic_table, g_ui_table, SIDE_DOWN);
		self:update_res_label(g_logic_table, g_ui_table, SIDE_UP);
		self:update_count_label(g_logic_table);
		self:refresh_grave();
		clean_sprite_cache();

		if true == LOCAL_TEST or g_euser.side == g_current_side then
			self:init_wait_action(g_phase);
		end
		self:check_timeout();
	end,

	refresh_card_list = function(self)
		if nil == self.layer then
			return;
		end
		-- refresh all card list in order to remove g_showing_card
		for i=1, #g_all_card_list do
			local list = g_all_card_list[i];
			self:refresh_clist_zorder(list, ZORDER_CARD);
		end
	end,

	change_btn = function(self, btn)
		if g_scene:is_stage(STAGE_REPLAY) then
			return;
		end
		if g_euser.side == SIDE_GUEST then
			return;
		end
		if btn == self.btn_skip then
			self.btn_skip:setVisible(true);
			enable_btn(self.btn_skip, true);
			--self.btn_next:setVisible(false);
			self.btn_next:setVisible(true);
			enable_btn(self.btn_next, false);
			self.btn_confirm:setVisible(false);
			self.btn_cancel:setVisible(false);
		elseif btn == self.btn_confirm then
			self.btn_cancel:setVisible(true);
			enable_btn(self.btn_cancel, true);
			self.btn_confirm:setVisible(true);
			enable_btn(self.btn_confirm, true);
			self.btn_skip:setVisible(false);
			self.btn_next:setVisible(false);
		elseif btn == self.btn_cancel then
			self.btn_cancel:setVisible(true);
			enable_btn(self.btn_cancel, true);
			self.btn_confirm:setVisible(false);
			enable_btn(self.btn_confirm, false);
			self.btn_skip:setVisible(false);
			self.btn_next:setVisible(false);
		else
			self.btn_next:setVisible(true);
			enable_btn(self.btn_next, true);
			self.btn_skip:setVisible(false);
			self.btn_confirm:setVisible(false);
			self.btn_cancel:setVisible(false);
		end
	end,

	callback_cancel = function(...)
		play_tap_1();
		local self = layer_card;
		local args = {...};
		local item = args[2];
		item:setVisible(false);

		self.ability_target_list = {} 	-- global
		g_src_index = 0				-- global
		g_action_type = TYPE_NONE	-- global
		
		self:refresh_layer();
	end,

	callback_confirm = function(...)
		play_tap_1();
		local self = layer_card;
		local args = {...};
		local item = args[2];
		item:setVisible(false);

		local cmd = 'b ' .. g_src_index ;
		for i=1, #self.ability_target_list do
			cmd = cmd .. ' ' .. self.ability_target_list[i];
		end
		play_game_cmd(cmd);

		self.ability_target_list = {};  -- reset it
		return;
	end,

	callback_skip_sac = function(...)
		play_tap_1();
		local args = {...};
		local item = args[2];
		item:setVisible(false);
		local cmd = 's ' .. 0;
		play_game_cmd(cmd);
		return;
	end,

	callback_next_side = function(...)
		play_tap_1();
		local self = layer_card;
		local args = {...};
		local item = args[2];
		item:setVisible(false);
		local sprite = item:getChildByTag(TAG_BTN_NEXT_EFF_1);
		if nil ~= sprite then
			sprite:removeFromParent(true);
		end
		sprite = item:getChildByTag(TAG_BTN_NEXT_EFF_2);
		if nil ~= sprite then
			sprite:removeFromParent(true);
		end

		local cmd;
		if true == LOCAL_TEST or g_euser.side == g_current_side then
			cmd = 'n';
		else
			-- @see in play_game_cmd
			cmd = 'f';
		end
		play_game_cmd(cmd);
		util.upload_tutor();
		return;
	end,

	check_touch_grave = function(self, x, y)
		if nil == g_ui_table then return 0; end
		local list = { SIDE_UP, SIDE_DOWN };
		for i = 1, #list do
			local side = list[i];
			if nil ~= g_ui_table[side] then 
				local grave = g_ui_table[side][T_GRAVE];
				local sx = grave.x;
				local sy = grave.y;
				if nil ~= grave.origin_y then
					sy = grave.origin_y;
				end
				local h_dwidth = grave.width/2;
				local h_dheight = grave.height/2;
				local sx1 = sx-h_dwidth;
				local sx2 = sx+h_dwidth;
				local sy1 = sy-h_dheight;
				local sy2 = sy+h_dheight;
				if x > sx1 and x < sx2 and y > sy1 and y < sy2 then
					return side;
				end
			end
		end
		return 0;
	end,

	remove_p_hand = function(self, is_reset)
		if nil == self.p_hand then
			return;
		end
		local info = self.p_hand;
		self.p_hand = nil;
		if true == is_reset then
			self:touch_small(info);
		end
	end,

	remove_drag_line = function(self)
		if nil == self.p_drag then
			return;
		end
		self.p_drag.batch:removeFromParentAndCleanup(true);
		self.p_drag = nil;
		if nil ~= self.p_pointer then
			self.p_pointer.batch:removeFromParentAndCleanup(true);
			self.p_pointer = nil;
		end
	end,

	is_drag_card = function(self, touch_card)
		local list = get_card_list(self.touch_card.ltype); 
		local info = get_ui_card(touch_card.index);
		if nil == info then
			kdebug("DEBUG is_drag_card nil info index[%d]", touch_card.index);
			return false;
		end
		local card = info.card;
		local kind = check_kind(card, g_logic_table, g_current_side, g_phase);
		if kind == AKIND_SAC or kind == AKIND_TALLY or kind == AKIND_TSUPPORT then
			return true;
		end
		return false;
	end,

	is_my_card = function(self, touch_card, side)
		local list = get_card_list(self.touch_card.ltype); 
		--local info = list[self.touch_card.index];
		local info = get_ui_card(self.touch_card.index);
		if nil == info then
			return false;
		end
		local card = info.card;
		local index = cindex(card);
		local cside = index_side(index);
		if cside == side then
			return true;
		else
			return false;
		end
	end,

	switch_action = function(self, touch_card, x, y)
		if true ~= LOCAL_TEST and g_euser.side ~= g_current_side then
			return;
		end
		if nil == touch_card or 0 == touch_card.index then
			return;
		end
		if nil == self.touch_point then return; end
		local list = get_card_list(touch_card.ltype); 
		local tcard = get_ui_card(touch_card.index); -- the selected card
		local ff = tcard.frame;
		local cpos = cc.p(ff.x, ff.y); -- center point of selected card
		--local offsety = math.abs(y - cpos.y);
		--local offsetx = math.abs(x - cpos.x);
		--local fingerx = wfix(60);
		local fingery = hfix(15);
		--if offsetx < fingerx and offsety < fingery then
		--local offsety = y - cpos.y;
		local offsety = y - self.touch_point.y;
		if offsety < fingery then
			return true;
		end
		return false;
	end,

	drag_action = function(self, touch_card, x, y)
		if true ~= LOCAL_TEST and g_euser.side ~= g_current_side then
			return;
		end
		if nil == touch_card or 0 == touch_card.index then
			return;
		end
		local list = get_card_list(touch_card.ltype); 
		local tcard = get_ui_card(touch_card.index); -- the selected card
		local ff = tcard.frame;
		local cpos = ccp(ff.x, ff.y); -- center point of selected card
		local offsety = math.abs(y - cpos.y);
		local offsetx = math.abs(x - cpos.x);
		local fingerx = wfix(30);
		local fingery = hfix(15);
		if nil == self.p_drag then
			if offsetx < fingerx and offsety < fingery then
				return;
			end
			if nil ~= layer_action.layer then
				return;
			end
			local card = tcard.card;
			local index = cindex(card);
			local kind = check_kind(card, g_logic_table, g_current_side, g_phase);
			
			if kind == AKIND_NONE or 0 ~= g_src_index then
				return;
			end
			if kind == AKIND_ABILITY then
				local num, err = total_target(index,g_logic_table,g_current_side);
				if 0 == num then
					return;
				end
				if 0 == target_num(index,g_logic_table,g_current_side) then
					return;
				end
			end

			-- implicit: offsetx > fingerx or offsety > fingery (drag far enough)
			-- implicit: kind ~= 0,  g_src_index == 0 
			-- note: g_src_index = selected card index
			local path;
			path = util.get_path('dragline.plist');	
			self.p_drag = util.add_particle(self.layer, path, cpos,ZORDER_EFFECT);
			self.p_drag.pos = cpos;
			path = util.get_path('drag_pointer.plist');	
			self.p_pointer = util.add_particle(self.layer, path, ccp(cpos.x+40, cpos.y+40), ZORDER_EFFECT);
			local csprite = tcard.sprite;
			csprite:setRotation(0);
			self.layer:reorderChild(csprite, ZORDER_SHOWING);
			if true == is_target_grave(index, g_logic_table, g_current_side) then
				g_src_index = index;
				hl_table(self.layer, AKIND_TGRAVE, g_ui_table, g_current_side);
			elseif kind == AKIND_ATTACK then
				hl_at_target(index, 'move');
			elseif kind == AKIND_ABILITY then
				hl_ab_target(index, 'move');
			elseif kind == AKIND_BOTH then
				hl_both_target(index);
			else
				hl_table(self.layer, kind, g_ui_table, g_current_side);
			end
			return;
		else
			if offsetx < fingerx and offsety < fingery then
				disable_touch();
				remove_hl();
				self:remove_drag_line();
				self.ability_target_list = {} 	-- global
				g_src_index = 0				-- global
				g_action_type = TYPE_NONE	-- global

				self:init_wait_action(g_phase);
				enable_touch();
				return;
			end
			local ttt = self.p_drag.pos;
			local pp = cc.p(x-ttt.x, y-ttt.y);
			local r = math.atan2(pp.y, pp.x);
			local r1 = r * 360 / ( 2 * 3.14 );
			local r2 = 90 - r1;
			local offset = math.sqrt(math.pow(pp.x, 2) + math.pow(pp.y, 2));
			local spos = self.p_drag.emitter:getPosVar();
			spos.y = offset*0.5;
			self.p_drag.emitter:setPosVar(spos);
			local pos = cc.p(pp.x/2+ttt.x, pp.y/2+ttt.y);
			self.p_drag.batch:setPosition(pos);
			self.p_drag.batch:setRotation(r2);

			pos.x = x + math.cos(r) * 80;
			pos.y = y + math.sin(r) * 80;
			self.p_pointer.batch:setPosition(pos);
			self.p_pointer.batch:setRotation(r2);

			local target_card=self:check_target(g_all_card_list,ccp(pos.x,pos.y));
			local tinfo = get_ui_card(target_card.index);
			return target_card;
		end
		return;
	end,

	hand_action = function(self, touch_card, x, y)
		if true ~= LOCAL_TEST and g_euser.side ~= g_current_side then
			return;
		end
		if nil == touch_card or 0 == touch_card.index then
			return;
		end
		local list = get_card_list(touch_card.ltype); 
		--local tcard = list[touch_card.index]; -- the selected card
		local tcard = get_ui_card(touch_card.index); -- the selected card
		local ff = tcard.frame;
		local cpos = ccp(ff.x, ff.y); -- center point of selected card
		local offsety = math.abs(y - cpos.y);
		local offsetx = math.abs(x - cpos.x);
		local fingerx = wfix(60);
		local fingery = hfix(60);
		if nil == self.p_hand then
			if offsetx < fingerx and offsety < fingery then
				return;
			end
			local kind = check_kind(tcard.card, g_logic_table, g_current_side, g_phase);
			if (kind ~= AKIND_TSUPPORT and kind ~= AKIND_TALLY and kind ~= AKIND_SAC) or 0 ~= g_src_index then
				return;
			end
			local csprite = tcard.sprite;
			self.p_hand = tcard;
			csprite:setRotation(0);
			self:touch_big(tcard);
			self.layer:reorderChild(csprite, ZORDER_SHOWING);
			hl_table(self.layer, kind, g_ui_table, g_current_side);
		else
			if offsetx < fingerx and offsety < fingery then
				disable_touch();
				remove_hl();
				self:remove_p_hand(true);
				self.ability_target_list = {} 	-- global
				g_src_index = 0				-- global
				g_action_type = TYPE_NONE	-- global

				self:init_wait_action(g_phase);
				enable_touch();
				return;
			end
			local info = self.p_hand;
			local sprite = info.sprite;
			local pos = cc.p(x, y+hfix(40));
			sprite:setPosition(pos);
			local scale = sprite:getScale();
			local s = sprite:getContentSize();
			local size = cc.size(s.width*scale, s.height*scale);
			local target_card=self:check_target(g_all_card_list,pos,size);
			return target_card;
		end
	end,

	-- beg_card is card in touch begin
	-- end_card is move to new one
	handle_touch_move = function(self, beg_card, end_card, x, y)
		if 0 == end_card.ltype or 0 == end_card.index then
			-- move to outside
			if 0 ~= beg_card.index then
				local list = get_card_list(beg_card.ltype); 
				self:refresh_clist_zorder(list, ZORDER_CARD);
				self:touch_small(list[beg_card.index]);
			end
			beg_card.ltype = 0;
			beg_card.index = 0;
			return true;
		end
		if 0 == beg_card.ltype or 0 == beg_card.index then
			-- move into card list from outside
			local list = get_card_list(end_card.ltype); 
			self:refresh_clist_zorder(list, ZORDER_CARD_TOUCH);
			self:touch_big(list[end_card.index]);

			beg_card.ltype = end_card.ltype;
			beg_card.index = end_card.index;
			return true;
		end
		if beg_card.ltype==end_card.ltype and beg_card.index == end_card.index then
			return true;
		end
		-- change card
		local blist = get_card_list(beg_card.ltype);
		self:refresh_clist_zorder(blist, ZORDER_CARD);
		self:touch_small(blist[beg_card.index]);

		local elist = get_card_list(end_card.ltype);
		self:refresh_clist_zorder(elist, ZORDER_CARD_TOUCH);
		self:touch_big(elist[end_card.index]);

		return false;
	end,

	check_touch = function(self, all_card_list, x, y)
		for i = 1, #all_card_list do
			local list = all_card_list[i] or {};
			if list.ltype == UP_GRAVE or list.ltype == DOWN_GRAVE then
				list = {}; -- use as break;
			end
			for j = #list, 1, -1 do
				local is_touched = check_in_card(list[j], x, y);
				if true ~= LOCAL_TEST and true ~= data_handler.show_all_card and 
				   ((list.ltype == DOWN_HAND and g_euser.side ~= SIDE_DOWN) or 
				   (list.ltype == UP_HAND and g_euser.side ~= SIDE_UP)) then

				   is_touched = false;
				end
				if true == is_touched then
					local index = cindex(list[j].card);
					return { ltype = list.ltype, index = index };
				end
			end
		end
		return { ltype = 0, index = 0 };
	end,

	check_target = function(self, all_card_list, cpos, csize)
		cpos = cpos or cc.p(0, 0);
		csize = csize or cc.size(0, 0);
		-- check table
		local sprite = self.layer:getChildByTag(TAG_HIGHLIGHT);
		--print('-------- ', tolua.type(sprite));
		if nil ~= sprite then
			local pos = ccp(sprite:getPositionX(), sprite:getPositionY());
			local size = sprite:getContentSize();
			local rect = { x1 = pos.x - size.width/2, x2 = pos.x + size.width/2,
						   y1 = pos.y - size.height/2,y2 = pos.y + size.height/2};
			local x1 = cpos.x-csize.width/2;
			local x2 = cpos.x+csize.width/2;
			local y1 = cpos.y-csize.height/2;
			local y2 = cpos.y+csize.height/2;
			if x2 > rect.x1 and x1 < rect.x2 and y2 > rect.y1 and y1<rect.y2 then
				return { ltype = 'table' , index = 0 };
			end
			if g_euser.side == g_current_side and g_phase == PHASE_SACRIFICE then
				local list = g_ui_table[g_euser.side][T_ALLY];
				local data = gui_get_data('ally_down', GUI_MATCH);
				local pos = cc.p(data.x+data.width/2, data.y+data.height/2);
				local size = cc.size(data.width, data.height);
				local rect = { x1 = pos.x-size.width/2, x2 = pos.x+size.width/2,
							   y1 = pos.y-size.height/2,y2 = pos.y+size.height/2};
				local x1 = cpos.x-csize.width/2;
				local x2 = cpos.x+csize.width/2;
				local y1 = cpos.y-csize.height/2;
				local y2 = cpos.y+csize.height/2;
				if x2 > rect.x1 and x1 < rect.x2 and y2 > rect.y1 and y1<rect.y2 then
					return { ltype = 'table' , index = 0 };
				end
			end
			sprite:setScale(1);
		end

		for i = 1, #all_card_list do
			local list = all_card_list[i] or {};
			if list.ltype == UP_GRAVE or list.ltype == DOWN_GRAVE then
				list = {}; -- use as break;
			end
			for j = #list, 1, -1 do
				local l = list[j];
				if nil ~= g_sprite_cache[l.card] then
					local sprite = l.sprite;
					local hl = sprite:getChildByTag(TAG_HIGHLIGHT);
					local is_touched = check_in_card(l, cpos.x, cpos.y);
					if nil ~= hl then
						if true == is_touched then
							--return { ltype = list.ltype, index = j };
							local index = cindex(l.card);
							return { ltype = list.ltype, index = index };
						end
					end
					local la = l.card_attach_list or {};
					if true ~= is_touched then
						la = {};
					end
					local count = 0;
					local aindex = 0;
					for k = 1, #la do
						local a = la[k];
						if nil ~= g_sprite_cache[a.card] then
							local sprite = a.sprite;
							local hl = sprite:getChildByTag(TAG_HIGHLIGHT);
							if nil ~= hl then
								count = count + 1;
								aindex = cindex(a.card);
							end
						end
					end
					if 1 == count then
						return { ltype = list.ltype, index = aindex };
					elseif count > 1 then
						-- has more than 1 attach card hl, show the main card
						local index = cindex(l.card);
						return { ltype = list.ltype, index = index };
					end
				end
			end
		end
		return { ltype = 0, index = 0 };
	end,

	touch_big = function(self, cinfo)
		if nil == cinfo then
			return;
		end
		local card = cinfo.card;
		local tindex = index_table_num(cindex(card));
		local sprite = cinfo.sprite;
		local frame = cinfo.frame;
		local sscale = frame.scale;
		local sx = frame.x;
		local sy = frame.y;

		-- scale to 1.2
		if true ~= DRAG_MODE then
			if T_HERO ~= tindex then
				sprite:setScale(sscale * 1.5);
			else
				sprite:setScale(sscale * 1.1);
			end
		end

		-- move up 
		local pos;
		local pos = cc.p(sx, sy);
		sprite:setPosition(pos);
	end,

	touch_small = function(self, cinfo)
		if nil == cinfo then
			return;
		end
		local c = cinfo.card;
		local sprite = cinfo.sprite;
		local frame = cinfo.frame;
		local sscale = frame.scale;
		local sx = frame.x;
		local sy = frame.y;

		if true ~= DRAG_MODE then
			sprite:setScale(sscale);
		end
		sprite:setPosition(ccp(sx, sy));

	end,

	touch_up = function(self, tinfo, callback_list)
		if nil == tinfo then
			return false;
		end
		local list = get_card_list(tinfo.ltype); 
		if nil == list then
			return false;
		end
		callback_list = callback_list or {};
		self:refresh_clist_zorder(list, ZORDER_CARD);
		local cinfo = list[tinfo.index];
		if nil == cinfo then
			return false;
		end
		disable_touch();
		local c = cinfo.card;
		local sprite = cinfo.card_sprite;
		local finfo = cinfo.frame_info;
		local npos = cc.p(finfo.posx, finfo.posy);
		local animation = {};
		local action = cc.MoveTo:create(0.1, npos);
		table.insert(animation, cc.EaseIn:create(action, 0.1));
		table.insert(animation, cc.RotateTo:create(0.1, finfo.rotation));
		table.insert(animation, cc.ScaleTo:create(0.1, finfo.scale));
		local action_final = {};
		table.insert(action_final, cc.Sequence:create(animation));
		for i = 1, #callback_list do
			local cb = callback_list[i];
			table.insert(action_final, cc.CallFunc:create(cb));
		end
		table.insert(action_final, cc.CallFunc:create(enable_touch));
		sprite:runAction( cc.Sequence:create( action_final ) );
		return true;
	end,

	remove_preview = function(self)
		if nil == layer_preview.layer then return; end
		layer_preview:remove();
	end,

	handler = function(event, x, y)
		local self = layer_card;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			if true == g_scene:is_online() then
				if nil == layer_result.layer then
					layer_menu.ask_fold();
				else
					g_scene:login();
				end
			end
		end
	end,

	onTouchBegan = function (self, x, y)
		self.time_touch_down = nil;
		--self.touch_y = nil;
		if true == g_is_in_tutor then
			self.touch_point = nil;
			return true;
		end
		if false == is_touchable() then
			self.touch_point = nil;
			return true;
		end
		-- no need to check and return, just go ahead is ok
		if nil ~= self.touch_point then
			print('DBEUG layer_card onTouchBegan touch_point not nil');
			self:reset_touch_data();
			self:remove_p_hand(true);
			self:remove_drag_line();
			self.touch_point = nil;
			refresh_layer_card();
			return false;
		end
		self:reset_touch_data();
		self.touch_point = {x = x, y = y};

		if 0 ~= self:check_touch_grave(x, y) then
			return true;
		end
		self.cinfo = nil;
		self.target_card = { ltype = 0, index = 0 };
		self.touch_card = self:check_touch(g_all_card_list, x, y);
		if 0 == self.touch_card.index then
			self.touch_point = nil;
			return false;
		end

		local list = get_card_list(self.touch_card.ltype); 
		self:refresh_clist_zorder(list, ZORDER_CARD_TOUCH);
		local tt = get_ui_card(self.touch_card.index);
		self:touch_big(tt);
		self.touch_func = nil;
		local s = index_side(self.touch_card.index);
		local tn = index_table_num(self.touch_card.index);
		if s == SIDE_DOWN and g_euser.side == SIDE_DOWN and tn == T_HAND then
			--self.touch_y = y;
			self.time_touch_down = os.time();
			--print("------- t1: ", self.time_touch_down);
			g_scene:add_layer(ZORDER_LAYER_PREVIEW, layer_preview:create(tt));
		end
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		if nil == self.touch_point then
			return;
		end

		if true ~= LOCAL_TEST then
			if false == self:is_my_card(self.touch_card, g_current_side) then
				return;
			end
		end

		if nil == self.p_drag and 0 ~= self:check_touch_grave(x, y) then
			if 0 ~= self.touch_card.index then
				local list = get_card_list(self.touch_card.ltype); 
				self:refresh_clist_zorder(list, ZORDER_CARD);
				self:touch_small(get_ui_card(self.touch_card.index));
			end
			self.touch_card.ltype = 0;
			self.touch_card.index = 0;
			return;
		end

		local s = index_side(self.touch_card.index);
		local tn = index_table_num(self.touch_card.index);
		if s == SIDE_DOWN and g_euser.side == SIDE_DOWN and tn == T_HAND then
			if true == self:switch_action(self.touch_card, x, y) then
				local touch_card = self:check_touch(g_all_card_list, x, y);
				if 0 < touch_card.index and touch_card.index ~= self.touch_card.index then
					self:reset_touch_data();
					self.touch_card = touch_card;
					local list = get_card_list(self.touch_card.ltype); 
					self:refresh_clist_zorder(list, ZORDER_CARD_TOUCH);
					local tt = get_ui_card(self.touch_card.index);
					self:touch_big(tt);
					self.touch_func = nil;
					--self.time_touch_down = os.time();
					--print("------- t1: ", self.time_touch_down);
					g_scene:add_layer(ZORDER_LAYER_PREVIEW, layer_preview:create(tt));
					return;
				end
			end
		end

		local target_card = nil;
		if true == self:is_drag_card(self.touch_card) then
			target_card = self:hand_action(self.touch_card, x, y);
		else
			target_card = self:drag_action(self.touch_card, x, y);
		end

		--local target_card = self:drag_action(self.touch_card, x, y);
		if nil == target_card then
			return;
		end
		self:remove_preview();
		local nltype = target_card.ltype;
		local nindex = target_card.index;
		local oltype = self.target_card.ltype;
		local oindex = self.target_card.index;
		if nltype == oltype and nindex == oindex then
			return;
		end
		self.target_card = target_card;
		if 'table' == nltype then	
			return;
		end
		if 0 ~= oltype and 0 ~= oindex then
			local list = get_card_list(oltype); 
			self:refresh_clist_zorder(list, ZORDER_CARD_TOUCH);
			self:touch_small(get_ui_card(oindex));
		end
		if 0 ~= nltype and 0 ~= nindex then
			local list = get_card_list(nltype); 
			self:refresh_clist_zorder(list, ZORDER_CARD_TOUCH);
			self:touch_big(get_ui_card(nindex));
		end

	end,

	onTouchEnded = function(self, x, y)
		if nil == self.touch_point then
			return;
		end
		--self.touch_y = nil;
		self.touch_point = nil;

		self:remove_preview();
		if true == self:handle_touch_end() then
			return;
		end

		-- move to handle_touch_end, need test
		--self:refresh_layer();
		--

		local flag_grave = self:check_touch_grave(x, y);
		if 0 ~= flag_grave then
			if flag_grave == SIDE_UP or flag_grave == SIDE_DOWN then
				local list = g_ui_table[flag_grave][T_GRAVE];
				if nil ~= list and 0 < #list then
					play_tap_2();
					open_grave(flag_grave);
				end
				return;
			end
		end

	end,

	reset_touch_card = function(self, tinfo)
		if nil == tinfo then
			return false;
		end
		local ltype = tinfo.ltype;
		if nil == tonumber(ltype) then
			return;
		end
		local list = get_card_list(tinfo.ltype); 
		if nil == list then
			return false;
		end
		callback_list = callback_list or {};
		self:refresh_clist_zorder(list, ZORDER_CARD);
		local cinfo = get_ui_card(tinfo.index);
		if nil == cinfo then
			return false;
		end
		cinfo:reset();
	end,

	reset_touch_data = function(self)
		self:reset_touch_card(self.touch_card);
		self:reset_touch_card(self.target_card);
		self.touch_card = { ltype = 0, index = 0 };
		self.target_card = { ltype = 0, index = 0 };
	end,

	handle_touch_target = function(self, sinfo, tinfo, target_ltype)
		local scard, tcard, src_index, target_index;
		if sinfo then scard = sinfo.card end;
		if tinfo then tcard = tinfo.card end;
		if scard then src_index = cindex(scard) end;
		if tcard then target_index = cindex(tcard) end;

		local kind = check_kind(scard, g_logic_table, g_current_side, g_phase);
		if 'table' == target_ltype then
			local index = cindex(scard);
			local f, s = is_target_grave(index,g_logic_table,g_current_side);
			if kind == AKIND_SAC then -- sac
				action_sac(src_index);	
				return true;
			elseif kind == AKIND_TALLY or kind == AKIND_TSUPPORT then --table ally
				hl_ab_target(src_index, 'action');	
				return true;
			elseif true == f then
				open_grave(s);
				return true;
			end
		elseif 0 ~= target_ltype and nil ~= tcard then
			local ret = false;
			local sprite = tinfo.sprite;
			local hl = sprite:getChildByTag(TAG_HIGHLIGHT);
			if nil ~= hl then
				ret = action_target(layer_card, g_action_type, g_src_index, target_index);
				--print('ret: ', ret);
			else
				local count = 0;
				local ainfo = nil;
				local alist = tinfo.card_attach_list or {};
				for i = 1, #alist do
					ainfo = alist[i];
					local sprite = ainfo.sprite;
					local hl = sprite:getChildByTag(TAG_HIGHLIGHT);
					count = count + 1;
				end
				if 1 == count then
					ret = self:handle_touch_target(sinfo, ainfo);
				elseif count > 1 then
					create_btn_cancel();
					local layer = layer_action:create(tinfo);
					g_scene:add_layer(ZORDER_LAYER_ACTION, layer);
					ret = true;
				end
			end
			--print('ret:     ', ret);
			if true == ret then
				self:reset_touch_data();
				return true;
			end
		end
		return false;
	end,

	handle_touch_end = function(self, x, y)
		local touch_info = get_ui_card(self.touch_card.index);
		local target_info = get_ui_card(self.target_card.index);
		local target_ltype = nil;
		local need_pop = true;
		if nil ~= self.p_hand then
			self:remove_p_hand(false);
			need_pop = false;
		end
		if nil ~= self.p_drag then
			self:remove_drag_line();
			need_pop = false;
		end
		if self.target_card then target_ltype = self.target_card.ltype end;
		local scard, tcard;
		if touch_info then scard = touch_info.card end;
		if target_info then tcard = target_info.card end;
		local ret = false;
		ret = self:handle_touch_target(touch_info, target_info, target_ltype);
		if true == ret then
			return true;
		end

		if false == need_pop then
			refresh_layer_card();
			return false;
		end

		self:reset_touch_data();

		if nil ~= touch_info then
			if nil ~= self.time_touch_down then
				local t = os.time() - self.time_touch_down;
				if t > 1 then
					return true;
				end
			end
			local sss = touch_info.sprite;
			local layer, name = layer_action:create(touch_info);
			g_scene:add_layer(ZORDER_LAYER_ACTION, layer, name);
			return true;
		end
		-- need??
		--self.ability_target_list = {} 	-- global
		--g_src_index = 0				-- global
		--g_action_type = TYPE_NONE	-- global
		return false;
	end,

	-- use in play_to_anim
	clean_for_touch_end = function(self)
		if nil ~= self.p_hand then
			self:remove_p_hand(false);
		end
		if nil ~= self.p_drag then
			self:remove_drag_line();
		end
		remove_hl();
		self.ability_target_list = {} 	-- global
		g_src_index = 0				-- global
		g_action_type = TYPE_NONE	-- global
		if nil ~= self.touch_point then
			self:reset_touch_data();
		end
		self.touch_point = nil;
	end,
	
    -- init wait to action
	init_wait_action = function(self, phase)
		self:refresh_grave();
		if true ~= LOCAL_TEST and g_euser.side ~= g_current_side then
			return;
		end
		local t = g_ui_table[g_current_side];
		local list = {};
		table.insert(list, t[T_HAND]);
		table.insert(list, t[T_ALLY]);
		table.insert(list, t[T_SUPPORT]);
		table.insert(list, t[T_HERO]);

		local has_hl = false;
		for i = 1, #list do
			local l = list[i];
			for k, info in ipairs(l) do
				local card = info.card;
				if nil ~= card then
					local kind = nil;
					kind = check_kind(card,g_logic_table,g_current_side, g_phase);
					local index = cindex(card);
					if kind == AKIND_SAC then
						hl_card(index, HL_SAC);
						has_hl = true;
					elseif kind == AKIND_BOTH then
						hl_card(index, HL_BOTH);
						has_hl = true;
					elseif kind == AKIND_ATTACK then
						hl_card(index, HL_ATTACK);
						has_hl = true;
					elseif kind == AKIND_ABILITY then
						hl_card(index, HL_ABILITY);
						has_hl = true;
					elseif kind == AKIND_TALLY then
						hl_card(index, HL_ABILITY);
						has_hl = true;
					elseif kind == AKIND_TSUPPORT then
						hl_card(index, HL_ABILITY);
						has_hl = true;
					end
				end
			end
		end
		local list_move_hand = {};
		for i=1, #g_ui_table[g_current_side][T_HAND] do
			local info = g_ui_table[g_current_side][T_HAND][i];
			local cs = info.sprite;
			local hl = cs:getChildByTag(TAG_HIGHLIGHT);
			if nil == hl then
				table.insert(list_move_hand, info);
			end
		end
		if #list_move_hand ~= #g_ui_table[g_current_side][T_HAND] then
			for i = 1, #list_move_hand do
				local info = list_move_hand[i];
				local cs = info.sprite;
				local y = cs:getPositionY();
				y = y - 20;
				cs:setPositionY(y);
				info.frame.y = y;
			end
		end

		if g_last_phase ~= phase then
			g_last_phase = phase
			layer_table:update_phase(-1, phase);
			--pop_phase(phase);
		end
		if PHASE_SACRIFICE == phase then
			self:change_btn(self.btn_skip);	

			if g_euser.side == g_current_side then
				local flag = false;

				if false == flag then
					flag = util.trigger_tutor(TUTOR_INTRO);
				end

				if false == flag then
					flag = util.trigger_tutor(TUTOR_SECOND_SAC);
				end

				if false == flag and g_euser.level < 5 then
					layer_card:show_tip_help("继续弃除手牌获得更多可用资源")
				end

			end

			--[[
			if g_euser.side == g_current_side then
				local flag = false;
				if false == flag then
					flag = util.trigger_tutor(TUTOR_RES);
				end
				if false == flag then
					flag = util.trigger_tutor(TUTOR_TAP_SKIP);
				end
			end
			]]--
		else
			self:change_btn(self.btn_next);	

			if g_euser.side == g_current_side then
				local flag = false;

				layer_card:remove_tip_help();
				if layer_dragtutorial ~= nil then
					layer_dragtutorial:remove();
				end

				if nil ~= g_net_win_data then
					flag = true;
				end

				if false == flag then
					flag = util.trigger_tutor(TUTOR_HIGHLIGHT_CARD);
				end

				if false == flag then
					flag = util.trigger_tutor(TUTOR_ATTACK);
				end

				if false == flag then
					flag = util.trigger_tutor(TUTOR_WYLD_SKILL);
				end

				if false == flag then
					flag = util.trigger_tutor(TUTOR_REST);
				end

				if false == flag then
					flag = util.trigger_tutor(TUTOR_WAIT_NEXT_SAC);
				end

				if false == flag then
					flag = util.trigger_tutor(TUTOR_PVP_CAN_ATTACK);
				end

				if false == flag then
					flag = show_svg_help();
				end

				if false == flag and false == has_hl then
					self:eff_btn_next();
				end

--				if false == flag then
--					flag = util.trigger_tutor(TUTOR_WAIT_NEXT);
--				end

				
			end
			--[[
			if g_euser.side == g_current_side then
				local flag = false;
				if false == flag then
					flag = util.trigger_tutor(TUTOR_PLAY);
				end
				if false == flag then
					flag = util.trigger_tutor(TUTOR_HL_ALLY);
				end
				if false == flag then
					flag = util.trigger_tutor(TUTOR_HL_HERO);
				end
				if false == flag then
					flag = util.trigger_tutor(TUTOR_NEXT);
				end
			end
			]]--
		end
		change_step(STEP_CHOOSE);
	end,

	eff_btn_next = function(self)
		local btn = self.btn_next;
		if nil == btn then return; end
		local scale = btn:getScale();
		local size = btn:getContentSize();
		local x1 = 0;
		local x2 = size.width * scale;
		local y1 = 0;
		local y2 = size.height * scale;
		local speed = 250;
		local tx = (x2 - x1) / speed;
		local ty = (y2 - y1) / speed;

		local sprite = btn:getChildByTag(TAG_BTN_NEXT_EFF_1);
		if nil == sprite then
			path = util.get_path('tutor_star.png');
			pos = cc.p(x1, y1);
			sprite = util.add_sprite(btn, path, pos, ANCHOR_CENTER_CENTER, 40);
			sprite:setTag(TAG_BTN_NEXT_EFF_1);

			array = {};
			table.insert(array, cc.MoveTo:create(ty, cc.p(x1, y2)));
			table.insert(array, cc.MoveTo:create(tx, cc.p(x2, y2)));
			table.insert(array, cc.MoveTo:create(ty, cc.p(x2, y1)));
			table.insert(array, cc.MoveTo:create(tx, cc.p(x1, y1)));
			sprite:runAction(cc.RepeatForever:create(cc.Sequence:create(array)));
			sprite:runAction(cc.RepeatForever:create(cc.RotateBy:create(1, 360)));
		end

		sprite = btn:getChildByTag(TAG_BTN_NEXT_EFF_2);
		if nil == sprite then
			path = util.get_path('tutor_tail.plist');
			pos = cc.p(x1, y1);
			local p = util.add_particle(btn, path, pos, 20);
			sprite = p.batch;
			sprite:setTag(TAG_BTN_NEXT_EFF_2);

			array = {};
			table.insert(array, cc.MoveTo:create(ty, cc.p(x1, y2)));
			table.insert(array, cc.MoveTo:create(tx, cc.p(x2, y2)));
			table.insert(array, cc.MoveTo:create(ty, cc.p(x2, y1)));
			table.insert(array, cc.MoveTo:create(tx, cc.p(x1, y1)));
			sprite:runAction(cc.RepeatForever:create(cc.Sequence:create(array)));
		end
	end,

	refresh_grave_by_side = function(self, side)
		local zorder = 8;
		local ui_table = g_ui_table[side][T_GRAVE];
		if nil == ui_table then
			return;
		end
		local height = ui_table.pic_height;
		if nil == height then
			return;
		end
		local len = ui_table.pic_len;
		local scale = ui_table.pic_scale;
		local index = 1;
		for i = #ui_table, 1, -1 do
			local info = ui_table[i];
			local pos = info:get_grave_pos(ui_table, index);
			if nil ~= pos then
				info:change_grave(pos, scale);
			end
			index = index + 1;
			if index > len then
				break;
			end
		end
		for i = #ui_table - len, 1, -1 do
			local info = ui_table[i];
			info:remove_sprite();
		end
	end,

	refresh_grave = function(self)
		self:refresh_grave_by_side(SIDE_UP);
		self:refresh_grave_by_side(SIDE_DOWN);
	end,

} -- layer_card end 

layer_action = {
	name = 'layer_action',
	layer = nil, -- @see init
	obj = nil,	
	list = nil,
	menu = nil,
	tcount = 0,

	cleanup = function(self)
		self.layer = nil;
		self.obj = nil;
		self.list = nil;
		self.menu = nil;
		self.tcount = 0;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, obj)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_ACTION, self.handler, true);

		self.tcount = 0;
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 120));

		if nil == obj then
			kerror("layer_action:create  obj=nil");
			return self.layer, self.name;
		end

		self.obj = obj;

		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		local rotation = 0;
		local cwidth = FULL_WIDTH - wfix(50);
		local cheight = FULL_HEIGHT - hfix(300);
		local scale = get_card_scale(cwidth, cheight, CARD_SIZE);
		local sprite = obj:get_action_sprite(self.layer, pos, rotation, scale);
		self.layer:reorderChild(sprite, ZORDER_SHOWING);
		local size = sprite:getContentSize();

		self.list = {};
		table.insert(self.list, { obj = obj, sprite = sprite });
		for i = 1, #obj.attach_list do
			local o = obj.attach_list[i];
			local c = o.card;
			if c.id < 1000 then
				table.insert(self.list, { obj = o, sprite = nil });
			end
		end
		local callback_list = { self.show_menu };
		
		if #self.list > 1 then

			for i = 2, #self.list do
				local o = self.list[i].obj;
				local p = cc.p(pos.x, pos.y+(i-1)*50+hfix(80));
				if i == 1 then
				elseif i == #self.list then
				elseif 0 == i%2 then
					p.x = p.x + i * 10;
				else -- 0 ~= i%2
					p.x = p.x - i * 10;
				end
				local rotation = 0; 
				local scale = sprite:getScale();
				local s = o:get_action_sprite(self.layer, p, rotation, scale);
				self.layer:reorderChild(s, ZORDER_SHOWING-i);
				self.list[i].sprite = s;
			end

			local items = {};
			local item;

			pos = cc.p(HALF_WIDTH, 0);
			item = add_item_1(items, '下一张', nil, 30, self.show_next, ANCHOR_CENTER_DOWN, pos);
			
			util.add_menu(self.layer, items);
		end

		local pos_to = cc.p(HALF_WIDTH, HALF_HEIGHT+hfix(80));
		self.tdisable();
		local farray = {};
		local action;
		action = cc.EaseIn:create(cc.MoveTo:create(0.2, pos_to), 0.2);
		table.insert(farray, action);

		for i=1, #callback_list do
			local callback = callback_list[i];
			table.insert(farray, cc.CallFunc:create(callback));
		end
		table.insert(farray, cc.CallFunc:create(self.tenable));
		--table.insert(farray, cc.CallFunc:create(self.for_tutor));

		action = cc.Sequence:create(farray);
		sprite:runAction( cc.Sequence:create(farray));

		local items = {};
		local item;

		if true == is_show_tip_btn() then
			item, data = gui_add_item(items, 'btn_tip', GUI_MATCH, self.tip, ANCHOR_NULL);
			util.add_text_outline_to_sprite(item, '提示', 25, cc.c4b(data.r, data.g, data.b, 255), cc.c4b(data.sr, data.sg, data.sb, 255), 1);
		end

		util.add_menu(self.layer, items, 100);
		
		return self.layer, self.name;
	end, 

	for_tutor = function(...)
		if g_euser.side == SIDE_GUEST then
			return;
		end
		local args = {...};
		local sprite = args[1];
		local self = layer_action;
		local ctype = self.obj.card.ctype;
		if true == g_is_in_tutor then
			story_2();
			return;
		end
		local step = nil;
		local flag = util.trigger_tutor(TUTOR_USE);
		if true == flag then return; end
		--if ctype == ALLY then
		if index_table_num(cindex(self.obj.card)) == T_ALLY then
			flag = util.trigger_tutor(TUTOR_TAP_ATTACK);
			if true == flag then return; end
		end
		if nil ~= g_src_index and g_src_index > 0 then
			if g_action_type == TYPE_ATTACK then
				flag = util.trigger_tutor(TUTOR_TAP_ATTARGET);
				if true == flag then return; end
			end
		end
		if ctype == HERO then
			flag = util.trigger_tutor(TUTOR_TAP_ABHERO);
			if true == flag then return; end
		end
		if ctype == HERO then
			step = TUTOR_HERO_POWER;
		elseif ctype == ALLY then
			step = TUTOR_ALLY_ATTACK;
		elseif ctype == WEAPON then
			step = TUTOR_WEAPON_ATK;
		elseif ctype == ARMOR then
			step = TUTOR_ARMOR_DEF;
		else
			step = TUTOR_COST;
		end
		flag = util.trigger_tutor(step);
		if false == flag then
			util.trigger_tutor(TUTOR_SAC_TAP);
		end
	end,

	tip = function()
		play_tap_1();
		local self = layer_action;
		if false == is_touchable() then
			return;
		end
		if true ~= g_scene:is_online() then
			return;
		end
		if g_euser.side ~= g_current_side then
			show_msg(t_lang("TIP_WAIT_OPPONENT"));
			return;
		end
		local ctype = self.obj.card.ctype;
		if ctype == HERO then
			step = TUTOR_HERO_POWER;
		elseif ctype == ALLY then
			step = TUTOR_ALLY_ATTACK;
--			util.set_tutor(TUTOR_COST, false, false);
		elseif ctype == WEAPON then
			step = TUTOR_WEAPON_ATK;
--			util.set_tutor(TUTOR_COST, false, false);
		elseif ctype == ARMOR then
			step = TUTOR_ARMOR_DEF;
--			util.set_tutor(TUTOR_COST, false, false);
		else
			step = TUTOR_COST;
		end
--		util.set_tutor(step, false, false);
--		util.set_tutor(TUTOR_DESC, false, false);
		util.trigger_tutor(step);
	end,

	tdisable = function()
		local self = layer_action;
		self.tcount = self.tcount + 1;
	end,

	tenable = function()
		local self = layer_action;
		self.tcount = self.tcount - 1;
		if 0 > self.tcount then
			self.tcount = 0;
		end
	end,

	is_enable = function()
		local self = layer_action;
		if 0 == self.tcount then
			return true;
		end
		return false;
	end,

	show_next = function(...)
		if false == is_touchable() then
			return;
		end
		local self = layer_action;
		local args = {...};
		local index = args[2]:getTag();
		local next_index = index + 1;

		if 0 == #(self.list or {}) then
			return;
		end
		if next_index > #self.list then
			next_index = 1;
		end
		local last_object = self.list[#self.list];
		table.remove(self.list, #self.list);
		table.insert(self.list, 1, last_object);

		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		for i = 1, #self.list do
			local obj = self.list[i].obj;
			local sprite = self.list[i].sprite;

			self.layer:reorderChild(sprite, ZORDER_SHOWING-i);

			local p = cc.p(pos.x, pos.y+(i-1)*50+hfix(80));
			if i == 1 then
			elseif i == #self.list then
			elseif 0 == i%2 then
				p.x = p.x + i * 10;
			else -- 0 ~= i%2
				p.x = p.x - i * 10;
			end
			local animation = {};
			table.insert(animation, cc.MoveTo:create(0.3, p));

			local actions_final = {};
			table.insert(actions_final, cc.Spawn:create(animation));

			self.tdisable();
			table.insert(actions_final, cc.CallFunc:create(self.tenable));
			sprite:runAction( cc.Sequence:create( actions_final ) );
		end

		self:show_menu();
	end,

	show_menu = function()
		local self = layer_action; --now we put attack/ability/sac on layer_action

		if nil ~= self.menu then
			self.menu:removeFromParentAndCleanup(true);
			self.menu = nil;
		end

		local btn_height = hfix(120);
		
		--local obj = get_ui_card(index);  -- like index_card(index, logic_table)
		local obj = self.list[1].obj;
		if nil == obj then
			kdebug("======= show_btn obj is nil");
			return;
		end
		--print('DEBUG handle_scale_max: index, obj = ', index, obj);
		local f_info = obj.frame; --list_object[1]
		local card = obj.card;  -- logic card data
		local index = cindex(card);
		local temp_sprite = obj.sprite;
		--local a_list = obj.attach_list or {};

		if nil == temp_sprite:getChildByTag(TAG_HIGHLIGHT) then
			-- this is normal because some card is not selectable
			-- e.g. cannot attack and cannot use ability
			return ;
		end

		kdebug("handle_scale_max:g_phase[%d]g_src_index[%d]",g_phase,g_src_index);

		local list_btn = {};
		if g_src_index > 0 then
			
			if g_action_type == TYPE_ATTACK then
				local l = { title = '目标', cb = callback_target };
				table.insert(list_btn, l);
			elseif g_action_type == TYPE_ABILITY then
				local l = { title = '目标', cb = callback_target };
				table.insert(list_btn, l);
			else

				local target_indexs, in_list;
				target_indexs = list_attack_target(g_src_index, g_logic_table, g_current_side);
				if nil ~= table_find(target_indexs or {}, index) then
					local l = { title = '攻击目标', cb = callback_target_t };
					table.insert(list_btn, l);
				end

				target_indexs = list_ability_target(g_src_index, g_logic_table, g_current_side, layer_card.ability_target_list, #layer_card.ability_target_list + 1);
				if nil ~= table_find(target_indexs or {}, index) then
					local l = { title = '技能目标', cb = callback_target_b };
					table.insert(list_btn, l);
				end
			end

		else --  implicit: g_src_index <= 0 

			local card = index_card(index, g_logic_table);
			local kind = nil;
			if nil ~= card then
				kind = check_kind(card, g_logic_table,g_current_side, g_phase);
			end
			local l = nil;
			if kind == AKIND_SAC then
				l = { title = '弃牌', cb = callback_sac };
				table.insert(list_btn, l);
			end
			if kind == AKIND_ATTACK or kind == AKIND_BOTH then
				l = { title = '攻击', cb = callback_attack };
				table.insert(list_btn, l);
			end
			if kind == AKIND_ABILITY or kind == AKIND_BOTH then
				l = { title = '技能', cb = callback_ability };
				table.insert(list_btn, l);
			end
			if kind == AKIND_TALLY or kind == AKIND_TSUPPORT then
				l = { title = '出牌', cb = callback_ability };
				table.insert(list_btn, l);
			end
		end
		if 0 == #list_btn then
			return;
		end
		local items = {};
		local item;

		local offsetx = FULL_WIDTH/(#list_btn+1);
		for i = 1, #list_btn do
			local l = list_btn[i];
			local title = l.title;
			local cb = l.cb;
			local pos = cc.p(offsetx * i, btn_height);
			item = add_item_1(items, title, nil, 30, cb, ANCHOR_CENTER_DOWN, pos);
			item:setTag(index);
		end
		if #(items or {}) > 0 then
			local menu = util.add_menu(self.layer, items, 1);
			menu:setTag(index);
			self.menu = menu;
		end
	end,

	close = function(self, callback_list)
		if nil == self.layer then
			layer_card:refresh_card_list();
			return;
		end
		self:remove();
		if true == is_step(STEP_CHOOSE) then
			g_src_index = 0;
		end
		for i = 1, #(callback_list or {}) do
			local cb = callback_list[i];
			cb();
		end
		if g_euser.side == SIDE_GUEST then
			return;
		end
		--[[
		if PHASE_SACRIFICE == g_phase then
			util.trigger_tutor(TUTOR_SAC);
		end
		]]--
	end,

	handler = function(event, x, y)
		local self = layer_action;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function (self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)
		if false == self.is_enable() then
			return;
		end
		self:close();
	end,

} -- layer_action end

layer_preview = {
	name = 'layer_preview',
	layer = nil,

	cleanup = function(self)
		self.layer = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, obj)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_ACTION, self.handler, false, nil, true);

		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		local rotation = 0;
		local cwidth = FULL_WIDTH - wfix(50);
		local cheight = FULL_HEIGHT - hfix(300);
		local scale = get_card_scale(cwidth, cheight, CARD_SIZE);
		local sprite = obj:get_action_sprite(self.layer, pos, rotation, scale);
		self.layer:reorderChild(sprite, ZORDER_SHOWING);

		--[[
		local pos_to = cc.p(HALF_WIDTH, HALF_HEIGHT+hfix(80));
		self.tdisable();
		local farray = {};
		local action;
		action = cc.EaseIn:create(cc.MoveTo:create(0.2, pos_to), 0.2);
		table.insert(farray, action);

		for i=1, #callback_list do
			local callback = callback_list[i];
			table.insert(farray, cc.CallFunc:create(callback));
		end
		table.insert(farray, cc.CallFunc:create(self.tenable));
		--table.insert(farray, cc.CallFunc:create(self.for_tutor));

		action = cc.Sequence:create(farray);
		sprite:runAction( cc.Sequence:create(farray));

		]]--
		
		return self.layer, self.name;
	end, 

	handler = function(event, x, y)
		local self = layer_preview;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function (self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)
	end,

} -- layer_preview end

layer_menu = {
	name = 'layer_menu',
	layer = nil,
	btn1 = nil,
	btn2 = nil,
	btn3 = nil,
	bg_btn = nil,
	is_replay = nil,

	cleanup = function(self)
		self.layer = nil;
		self.btn1 = nil;
		self.btn2 = nil;
		self.btn3 = nil;
		self.bg_btn = nil;
		self.is_replay = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, stage)
		self:remove();
		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_MENU, self.handler, false);

		local items = {};
		local item, pos;

		if stage == STAGE_PVE or stage == STAGE_PVP or stage == STAGE_PVG then
			local sprite, data;

			-- count time for per round
			layer_card:add_clock(self.layer);

			item, data = gui_add_item(items,'btn_more',GUI_MATCH,self.cb_match_more, ANCHOR_UP);
			if true == g_is_in_tutor then
				enable_btn(item, false);
			end
			self:create_match_more(stage, data);

		elseif stage == STAGE_REPLAY then
			self.is_replay = true;
			item, data = gui_add_item(items,'btn_more',GUI_MATCH, self.cb_match_more, ANCHOR_UP);
			self:create_match_more(stage, data);

		elseif stage == STAGE_BLANK then
			local size = cc.size(172, 52);
			pos = ccp(FULL_WIDTH, FULL_HEIGHT);
			item = add_item_1(items, '退出', nil, 20, self.blank_back, ANCHOR_RIGHT_UP, pos, size);
			table.insert(items, item);
		end

		util.add_menu(self.layer, items);

		return self.layer, self.name;
	end,

	create_match_more = function(self, stage, data)
		local items = {};
		local item, data, pos, cb;

		local is_back = false;
		if stage == STAGE_PVP or stage == STAGE_PVG then
			if g_euser.side == SIDE_GUEST then
				is_back = true;
			end
			cb = self.ask_fold;
		elseif stage == STAGE_REPLAY then
			is_back = true;
			cb = self.to_playerinfo;
		elseif stage == STAGE_PVE and g_scene:is_online() then
			cb = self.to_map;
		else
			cb = self.to_login;
		end
		item, data = gui_add_item(items, 'more3', GUI_MATCH, cb, ANCHOR_UP);
		if true == is_back then
			util.add_text_outline_to_sprite(item, '返回', 25, util.c4b_gold, util.c4b_black, 1);
		else
			util.add_text_outline_to_sprite(item, '投降', 25, util.c4b_gold, util.c4b_black, 1);
		end
		--[[
		if true == is_back then
			item, data = gui_add_item(items, 'more4', GUI_MATCH, cb, ANCHOR_UP);
		else
			item, data = gui_add_item(items, 'more1', GUI_MATCH, cb, ANCHOR_UP);
		end
		]]--
		pos = cc.p(data.x, FULL_HEIGHT);
		item:setPosition(pos);
		self.btn1 = item;
		local count = 1;

		if true == g_scene:is_online() and stage ~= STAGE_REPLAY and stage ~= STAGE_PVE then
			cb = self.rgame;
			item, data = gui_add_item(items, 'more2', GUI_MATCH, cb, ANCHOR_UP);
			util.add_text_outline_to_sprite(item, '刷新', 25, util.c4b_gold, util.c4b_black, 1);
			pos = cc.p(data.x, FULL_HEIGHT);
			item:setPosition(pos);
			self.btn2 = item;
			count = count + 1;
		end

		self.bg_btn = gui_add_sprite(self.layer, 'bg_more', GUI_MATCH, ANCHOR_UP);
		self.bg_btn:setVisible(false);
		local x = self.bg_btn:getPositionX();
		local size = self.bg_btn:getContentSize();
		self.bg_btn:setPositionX(x+size.width/3*(3-count));
		self.bg_btn:setContentSize(cc.size(size.width/3*count, size.height));

		--[[
		cb = nil;
		item, data = gui_add_item(items, 'more3', GUI_MATCH, cb, ANCHOR_UP);
		pos = cc.p(data.x, FULL_HEIGHT);
		item:setPosition(pos);
		self.btn3 = item;
		]]--

		util.add_menu(self.layer, items, data.zorder);
	end,

	cb_match_more = function(tag, sender)
		play_tap_3();
		-- sindex 0: off, 1: on
		local sindex = tolua.cast(sender, "cc.MenuItemToggle"):getSelectedIndex();
		local self = layer_menu;
		if 0 == sindex then
			self.bg_btn:setVisible(false);
			y = FULL_HEIGHT;
		else
			self.bg_btn:setVisible(true);
			local data = gui_get_data('more1', GUI_MATCH, ANCHOR_UP);
			y = data.y;
		end
		local list = { self.btn1, self.btn2, self.btn3 };
		local delay = 0;
		for i = 1, #list do
			local btn = list[i];
			if nil ~= btn then
				delay = delay + 0.1;
				btn:stopAllActions();
				local array = {};
				table.insert(array, cc.DelayTime:create(delay));
				local action = cc.MoveTo:create(0.1, cc.p(btn:getPositionX(), y));
				table.insert(array, action);
				btn:runAction(cc.Sequence:create(array));
			end
		end
	end,

	blank_back = function()
		play_tap_1();
		g_scene:debug();
	end,

	to_login = function()
		play_tap_1();
		g_scene:login();
	end,

	to_playerinfo = function()
		play_tap_1();
		clean_for_replay();
		--[[
		cc.Director:getInstance():getScheduler():setTimeScale(1);
		layer_anim:remove();
		layer_card:remove();
		data_handler:cleanup();
		g_euser.side = nil;
		g_euser.room_data = nil;
		g_scene:map();
		g_scene:add_layer(ZORDER_LAYER_INFO, layer_info:create(g_euser));
		local eid = layer_video.eid or '';
		local cmd = 'lreplay ' .. eid;
		net_send(cmd);
		]]--
	end,

	to_map = function()
		play_tap_1();
		g_scene:map();
	end,

	rgame = function()
		play_tap_1();
		if nil ~= g_net_win_data then
			-- already get net_win, don't send leave or fold
			-- otherwise will get st not_enough and jump to login
			return;
		end
		local cmd = 'ginfo';
		net_send(cmd);
	end,

	ask_fold = function()
		play_tap_1();
		local self = layer_menu;
		local is_npc = false;
		local is_my = false;
		local list = g_euser.room_data.guest_list or {};
		if #list >= 2 then
			for i = 1, 2 do
				local info = list[i];
				if info.eid < 500 then
					is_npc = true;
				end
				if info.eid == g_euser.eid then
					is_my = true;
				end
			end
		end
		local hp = g_logic_table[SIDE_DOWN][T_HERO][1].hp or 0;
		local str;
		if true == is_my and hp > 5
		and nil ~= g_euser.room_data
		and nil ~= g_euser.room_data.game_type
		and (g_euser.room_data.game_type == GAME_SOLO_GOLD
		or g_euser.room_data.game_type == GAME_VS_GOLD
		or g_euser.room_data.game_type == GAME_VS_CRYSTAL
		or g_euser.room_data.game_type == GAME_VS_FREE
		or g_euser.room_data.game_type == GAME_SOLO_PLUS) then
--			print('game_type:', g_euser.room_data.game_type, ' stage: ', stage);
			str = "你的英雄血量高于5点，投降将不能获得奖励，是否退出？";
		else
			str = "是否退出？";
		end
		g_scene:add_layer(ZORDER_LAYER_TIP, layer_tip:create(str, self.fold));
	end,

	-- tag 1->confirm 0->cancel
	fold = function(tag)
		local self = layer_menu;
		if true == self.is_replay then
			self.to_playerinfo();
			return;
		end
		if nil ~= g_net_win_data then
			-- already get net_win, don't send leave or fold
			-- otherwise will get st not_enough and jump to login
			return;
		end
		if g_euser.side == SIDE_GUEST then
			local cmd = 'leave';
			net_send(cmd);
			return;
		end
		local cmd = 'fold';
		net_send(cmd);
	end,

	handler = function(event, x, y)
		local self = layer_menu;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
} -- layer_menu end

layer_result = {
	name = 'layer_result',
	layer = nil,
	TAG_WIN = 1,
	TAG_LOSE = 2,
	TAG_DRAW = 3,
	TAG_GUEST = 4,
	is_done = false,
	cid = nil,

	cleanup = function(self)
		self.layer = nil;
		self.is_done = false;
		self.cid = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	-- if result == guest , offset_rating will be the winner's name
	--create = function(self, result, offset_rating, offset_gold, offset_exp, level, exp_next)
	create = function(self, result, info)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_RESULT, self.handler, true);

		local fullpath = util.get_fullpath(F_IMAGE, 'res_result.plist');
		util.add_frames(fullpath);

		self.is_done = false;
		self.cid = info.card_id;
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 210));

		local delay = 0.2;
		delay = self:show_popup(delay);

		if result == self.TAG_WIN then
			delay = self:show_light(delay);
		end

		delay = self:show_mark(delay, result);

		if nil ~= info.exp and g_euser.side ~= SIDE_GUEST then
			delay = self:show_exp(delay, info);
			g_euser.level = info.level;
		end

		delay = self:show_info(delay, result, info);

		delay = self:show_next(delay);

		util.stop_bgmusic();
		local fname = nil;
		if result == self.TAG_WIN then
			fname = 'eff_win.mp3';
		elseif result == self.TAG_LOSE then
			fname = 'eff_lose.mp3';
		else
			fname = 'eff_draw.mp3';
		end
		-- do preload in layer_preload loadres
		--util.preload_effect(path)
		local path = util.get_path(fname);
		--print('result music path: ', path);
		--util.preload_effect(path);
		util.play_effect(path);

		return self.layer, self.name;
	end,

	show_popup = function(self, delay)
		local fname, pos, sprite, array;
		fname = 'result_center.png';
		pos = cc.p(HALF_WIDTH, HALF_HEIGHT + 100);
		sprite=util.add_sprite_frame(self.layer,fname,pos,ANCHOR_CENTER_CENTER,5);
		sprite:setVisible(false);
		sprite:setScale(1.5);
		array = {};
		table.insert(array, cc.DelayTime:create(delay));
		table.insert(array, cc.Show:create());
		table.insert(array, cc.EaseOut:create(cc.ScaleTo:create(0.2, 1), 0.2));
		sprite:runAction(cc.Sequence:create(array));

		delay = delay + 0.2;

		local p1 = cc.p(HALF_WIDTH, HALF_HEIGHT + 100 + 70);
		local p2 = cc.p(HALF_WIDTH, HALF_HEIGHT + 100 - 20);
		fname = 'result_left.png';
		sprite = util.add_sprite_frame(self.layer,fname,p1,ANCHOR_CENTER_DOWN,3);
		sprite:setVisible(false);
		array = {};
		table.insert(array, cc.DelayTime:create(delay));
		table.insert(array, cc.Show:create());
		table.insert(array, cc.EaseOut:create(cc.MoveTo:create(0.1, p2), 0.1));
		table.insert(array, cc.EaseOut:create(cc.RotateTo:create(0.2, -45), 0.2));
		sprite:runAction(cc.Sequence:create(array));

		fname = 'result_right.png';
		sprite = util.add_sprite_frame(self.layer,fname,p1,ANCHOR_CENTER_DOWN,3);
		sprite:setVisible(false);
		array = {};
		table.insert(array, cc.DelayTime:create(delay));
		table.insert(array, cc.Show:create());
		table.insert(array, cc.EaseOut:create(cc.MoveTo:create(0.1, p2), 0.1));
		table.insert(array, cc.EaseOut:create(cc.RotateTo:create(0.2, 45), 0.2));
		sprite:runAction(cc.Sequence:create(array));

		delay = delay + 0.2;

		return delay;
	end,

	show_light = function(self, delay)
		local fname, pos, sprite, array;
		fname = 'result_light.png';
		pos = cc.p(HALF_WIDTH, HALF_HEIGHT + 100);
		sprite=util.add_sprite_frame(self.layer,fname,pos,ANCHOR_CENTER_CENTER,1);
		sprite:setVisible(false);
		array = {};
		table.insert(array, cc.DelayTime:create(delay));
		table.insert(array, cc.Show:create());
		sprite:runAction(cc.Sequence:create(array));
		sprite:runAction(cc.RepeatForever:create(cc.RotateBy:create(7, 360)));

		return delay;
	end,

	show_mark = function(self, delay, result)
		local fname, pos, sprite, array;
		if result == self.TAG_WIN then
			fname = 'result_win_1.png';
		elseif result == self.TAG_GUEST then
			return delay;
		else
			fname = 'result_lose_1.png';
		end
		pos = cc.p(HALF_WIDTH, HALF_HEIGHT + 100 - 40);
		sprite=util.add_sprite_frame(self.layer,fname,pos,ANCHOR_CENTER_UP,7);
		sprite:setVisible(false);
		sprite:setScaleX(0);
		array = {};
		table.insert(array, cc.DelayTime:create(delay));
		table.insert(array, cc.Show:create());
		table.insert(array, cc.ScaleTo:create(0.2, 1.2));
		table.insert(array, cc.ScaleTo:create(0.2, 1));
		sprite:runAction(cc.Sequence:create(array));

		delay = delay + 0.1;

		if result == self.TAG_WIN then
			fname = 'result_win_2.png';
		elseif result == self.TAG_DRAW then
			fname = 'result_draw_2.png';
		else
			fname = 'result_lose_2.png';
		end
		pos = cc.p(HALF_WIDTH, HALF_HEIGHT + 100 - 60);
		sprite=util.add_sprite_frame(self.layer,fname,pos,ANCHOR_CENTER_CENTER,9);
		sprite:setVisible(false);
		sprite:setScale(1.5);
		array = {};
		table.insert(array, cc.DelayTime:create(delay));
		table.insert(array, cc.Show:create());
		table.insert(array, cc.EaseOut:create(cc.ScaleTo:create(0.2, 1), 0.2));
		sprite:runAction(cc.Sequence:create(array));

		delay = delay + 0.1;

		return delay;
	end,

	show_info = function(self, delay, result, info)
		local fname, pos, sprite, array;
		if result == self.TAG_GUEST then
			local name = info.winnername;
			if nil ~= name then
				pos = cc.p(HALF_WIDTH, HALF_HEIGHT + 100 + 40);
				name = '胜利者：' .. name;
				sprite = util.add_labeloutline(self.layer, name, nil, 25, pos, util.c4b_white, util.c4b_black, 1, ANCHOR_CENTER_CENTER, 9);
				sprite:setVisible(false);
				array = {};
				table.insert(array, cc.DelayTime:create(delay));
				table.insert(array, cc.Show:create());
				sprite:runAction(cc.Sequence:create(array));
			end
			return delay;
		end
		local fontpath = util.get_fullpath(F_FONT, 'font_result.fnt');
		local rating = info.rating or '0';
		local gold = info.gold or '0';
		local crystal = info.crystal or '0';
		local show_rating = true;
		if 0 == tonumber(rating) then
			show_rating = false;
		end
		--[[
		local grd = g_euser.room_data;
		if nil ~= grd then
			local list = grd.guest_list or {};
			if #list > 1 then
				for i = 1, 2 do
					local info = list[i];
					if info.eid < 500 then
						show_rating = false;
						break;
					end
				end
			end
		end
		]]--
		if true == show_rating then
			fname = 'result_evil.png';
			pos = cc.p(HALF_WIDTH-84, HALF_HEIGHT + 100 + 70);
			sprite=util.add_sprite_frame(self.layer,fname,pos,ANCHOR_LEFT_UP,9);
			sprite:setVisible(false);
			array = {};
			table.insert(array, cc.DelayTime:create(delay));
			table.insert(array, cc.Show:create());
			sprite:runAction(cc.Sequence:create(array));

			pos.x = HALF_WIDTH;
			if rating >= 0 then
				rating = '+' .. rating;
			end
			sprite = util.add_labelbmf(self.layer, rating, fontpath, pos, ANCHOR_LEFT_UP, 9);
			sprite:setVisible(false);
			array = {};
			table.insert(array, cc.DelayTime:create(delay));
			table.insert(array, cc.Show:create());
			sprite:runAction(cc.Sequence:create(array));
			local len = sprite:getStringLength();
			for i = 0, len - 1 do
				local t = sprite:getLetter(i);
				local x, y = t:getPosition();
				array = {};
				table.insert(array, cc.DelayTime:create(delay + i * 0.1));
				table.insert(array, cc.JumpTo:create(0.15, cc.p(x, y), 15, 1));
				t:runAction(cc.Sequence:create(array));
			end
		end

		pos = cc.p(HALF_WIDTH-84, HALF_HEIGHT + 100 + 30);
		if crystal > 0 then
			fname = 'crystal.png';
			sprite = util.add_sprite(self.layer, fname, pos, ANCHOR_LEFT_UP, 9);
		else
			fname = 'result_coin.png';
			sprite=util.add_sprite_frame(self.layer,fname,pos,ANCHOR_LEFT_UP,9);
		end
		sprite:setVisible(false);
		array = {};
		table.insert(array, cc.DelayTime:create(delay));
		table.insert(array, cc.Show:create());
		sprite:runAction(cc.Sequence:create(array));

		pos.x = HALF_WIDTH;
		if crystal > 0 then
			crystal = '+' .. crystal;
			sprite = util.add_labelbmf(self.layer, crystal, fontpath, pos, ANCHOR_LEFT_UP, 9);
		else
			if gold >= 0 then
				gold = '+' .. gold;
			end
			sprite = util.add_labelbmf(self.layer, gold, fontpath, pos, ANCHOR_LEFT_UP, 9);
		end
		sprite:setVisible(false);
		array = {};
		table.insert(array, cc.DelayTime:create(delay));
		table.insert(array, cc.Show:create());
		sprite:runAction(cc.Sequence:create(array));
		len = sprite:getStringLength();
		for i = 0, len - 1 do
			local t = sprite:getLetter(i);
			local x, y = t:getPosition();
			array = {};
			table.insert(array, cc.DelayTime:create(delay + i * 0.09));
			table.insert(array, cc.JumpTo:create(0.15, cc.p(x, y), 15, 1));
			t:runAction(cc.Sequence:create(array));
		end

		return delay;
	end,

	show_exp = function(self, delay, info)
		local exp_offset = info.exp or 0;
		local exp_next = info.exp_next or 0;
		local level = info.level or 0;
		local exp_player = info.exp_player or 0;

		local fullpath, pos, sprite, array;
		--fullpath = util.get_fullpath(F_IMAGE, 'label_exp.png');
		pos = cc.p(HALF_WIDTH - 140, HALF_HEIGHT - 200);
		--sprite=util.add_sprite(self.layer,fullpath,pos,ANCHOR_CENTER_CENTER,5);
		sprite = util.add_labeloutline(self.layer, "EXP", nil, 25, pos, util.c4b_white, util.c4b_black, 2, ANCHOR_CENTER_CENTER, 5);
		sprite:setVisible(false);
		array = {};
		table.insert(array, cc.DelayTime:create(delay));
		table.insert(array, cc.Show:create());
		sprite:runAction(cc.Sequence:create(array));

		pos = cc.p(HALF_WIDTH, HALF_HEIGHT - 200);
		fullpath = util.get_fullpath(F_IMAGE, 'bar_exp_1.png');
		sprite=util.add_sprite(self.layer,fullpath,pos,ANCHOR_CENTER_CENTER,1);
		sprite:setVisible(false);
		array = {};
		table.insert(array, cc.DelayTime:create(delay));
		table.insert(array, cc.Show:create());
		sprite:runAction(cc.Sequence:create(array));

		fullpath = util.get_fullpath(F_IMAGE, 'bar_exp_3.png');
		sprite=util.add_sprite(self.layer,fullpath,pos,ANCHOR_CENTER_CENTER,5);
		sprite:setVisible(false);
		array = {};
		table.insert(array, cc.DelayTime:create(delay));
		table.insert(array, cc.Show:create());
		sprite:runAction(cc.Sequence:create(array));

		fullpath = util.get_fullpath(F_IMAGE, 'bar_exp_2.png');
		sprite = util.add_progress_bar(self.layer, util.create_sprite(fullpath), pos, cc.PROGRESS_TIMER_TYPE_BAR, ccp(0, 1), ccp(1, 0), 0, 3);
		sprite:setVisible(false);
		local exp_bar = sprite;

		local fontpath = util.get_fullpath(F_FONT, 'font_exp.fnt');
		local num_add = 0;
		pos.x = pos.x + 200;
		sprite = util.add_labelbmf(self.layer, '+0', fontpath, pos, ANCHOR_LEFT_CENTER, 9);
		sprite:setVisible(false);
		array = {};
		table.insert(array, cc.DelayTime:create(delay));
		table.insert(array, cc.Show:create());
		sprite:runAction(cc.Sequence:create(array));
		local exp_label = sprite;

		-- set current exp bar
		local exp_total = g_euser.exp_next;
		local exp = g_euser.exp;
		local level_offset = level - g_euser.level;
		local percent = 0;
		if exp < 0 then exp = 0; end
		if 0 == exp_total or exp >= exp_total then
			percent = 100;
		else
			percent = exp / exp_total * 100;
		end
		exp_bar:setPercentage(percent);

		local function level_up()
			local fname = 'result_level_up.png';
			local pos = cc.p(HALF_WIDTH, HALF_HEIGHT + 100 + 200);
			local sprite=util.add_sprite_frame(self.layer,fname,pos,ANCHOR_CENTER_CENTER,10);
			local array = {};
			pos.y = pos.y + 40;
			table.insert(array, cc.MoveTo:create(0.6, pos));
			table.insert(array, cc.CallFunc:create(callback_remove_sprite));
			sprite:runAction(cc.Sequence:create(array));
		end

		local num_exp = 0;
		local speed = 5;
		local line = exp_player / exp_next * 100;
		local function update_exp()
			percent = percent + speed;
			num_exp = num_exp + 1;
			if level_offset > 0 then
				if percent > 100 then 
					level_up();
					percent = 100; 
					level_offset = level_offset - 1;
					percent = 0;
					speed = 5;

					if is_ver(VER_LJSDK) then
						ljsdk_submit_data("levelUp");
					end

				end
			else
				if percent >= line then
					percent = line;
					self.layer:unscheduleUpdate();
					num_exp = exp_offset;
				end
			end
			exp_bar:setPercentage(percent);
			local t_exp = '+' .. num_exp;
			exp_label:setString(t_exp);

			speed = speed + 0.4;
		end

		local function start_update()
			self.layer:scheduleUpdateWithPriorityLua(update_exp, 1);
		end

		array = {};
		table.insert(array, cc.DelayTime:create(delay));
		table.insert(array, cc.Show:create());
		table.insert(array, cc.CallFunc:create(start_update));
		exp_bar:runAction(cc.Sequence:create(array));

		return delay;
	end,

	show_next = function(self, delay)
		local pos = cc.p(HALF_WIDTH, hfix(100));
		local str = '点击屏幕继续';
		--local label = util.add_labelglow(self.layer, str, nil, 35, pos, util.c4b_white, util.c4b_red, ANCHOR_CENTER_CENTER, 100, cc.size(FULL_WIDTH, hfix(200)), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
		local label = util.add_labelttf(self.layer, str, nil, 35, pos, util.c4b_white, ANCHOR_CENTER_CENTER, 100, cc.size(FULL_WIDTH, hfix(200)), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
		label:setVisible(false);

		local function do_next()
			self.is_done = true;
			if true == layer_card.should_start_next_after_result then
				net_send('ginfo');
				return;
			end
		end

		local action, array;
		array = {};
		table.insert(array, cc.DelayTime:create(delay));
		table.insert(array, cc.Show:create());
		table.insert(array, cc.CallFunc:create(do_next));
		label:runAction(cc.Sequence:create(array));
		
		array = {};
		action = cc.FadeIn:create(1);
		table.insert(array, action);
		action:setReverseAction(action);
		table.insert(array, action);
		action = cc.Sequence:create(array);
		action = cc.RepeatForever:create(action);
		label:runAction(action);
	end,

	show_card = function(self)
		local card = clone_card_by_id(self.cid);
		if nil == card then
			self:show_next(0);
			return;
		end
		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		local cinfo = object_card:new(self.layer, card, nil, nil, pos, 0, 0);
		local sprite = cinfo:get_front();
		
		local scale = wfix(1);
		if hfix(1) < scale then
			scale = hfix(1);
		end
		local function do_next()
			self.is_done = true;
			self.cid = nil;
			if true == layer_card.should_start_next_after_result then
				net_send('ginfo');
				return;
			end
		end
		scale = scale * 1.2;
		local array, action;
		array = {};
		table.insert(array, cc.ScaleTo:create(1, scale));
		table.insert(array, cc.RotateBy:create(1, 360 * 3));
		action = cc.Spawn:create(array);
		array = {};
		table.insert(array, action);
		table.insert(array, cc.CallFunc:create(do_next));
		action = cc.Sequence:create(array);
		sprite:runAction(action);
	end,

	close = function(self)
		data_handler:cleanup();
		g_euser.side = nil;
		g_euser.room_data = nil;
		if true == g_scene:is_online() then
			if g_scene:is_stage(STAGE_REPLAY) then
				--[[
				cc.Director:getInstance():getScheduler():setTimeScale(1);
				g_scene:map();
				g_scene:add_layer(ZORDER_LAYER_INFO, layer_info:create(g_euser));
				local eid = layer_video.eid or '';
				local cmd = 'lreplay ' .. eid;
				net_send(cmd);
				]]--
				clean_for_replay();
				return;
			end
			g_scene:map();
		else
			self:remove();
		end
	end,

	handler = function(event, x, y)
		local self = layer_result;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		if true ~= self.is_done then
			return;
		end
		if nil ~= self.cid and 0 ~= self.cid then
			self.is_done = false;
			self:show_card();
			return;
		end
		self:close();
	end,
} -- layer_result end

layer_preload = {
	name = 'layer_reload',
	layer = nil,
	callback = nil,
	WAIT = 1,
	START = 2,
	list = nil,
	label_num = nil,
	label_tip = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.label_num = nil;
		self.label_tip = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	--create = function(self, callback, tag, list_pl)
	create = function(self, callback, action, stage)
		self:remove();
		
		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_PRELOAD, self.handler, true);

		self.callback = callback;
		self.list = self:get_list(stage);

		local path, sprite, pos, str;
		path = util.get_path('bg_8.png');
		pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		sprite = util.add_sprite(self.layer, path, pos, ANCHOR_CENTER_CENTER);
		if wfix(1) > hfix(1) then
			sprite:setScale(wfix(1));
		else
			sprite:setScale(hfix(1));
		end

		path = util.get_path('pop_up.png');
		local fullrect = cc.rect(0, 0, 64, 64);
		local insetrect = cc.rect(30, 30, 4, 4);
		local bgsize = cc.size(wfix(512), hfix(80));
		pos = cc.p(HALF_WIDTH, HALF_HEIGHT-hfix(100));
		local bg = util.add_scale9sprite(self.layer, path, pos, ANCHOR_CENTER_CENTER, fullrect, insetrect, bgsize); 

		str = "加载中...";
		pos = cc.p(20, bgsize.height/2);
		self.label_tip = util.add_labeloutline(bg, str, nil, 30, pos, util.c4b_white, util.c4b_black, 2, ANCHOR_LEFT_CENTER, 50, cc.size(bgsize.width-40, bgsize.height), cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);

		path = util.get_path(FNT_1);
		pos = cc.p(bgsize.width-20, bgsize.height/2);
		str = "0%";
		self.label_num=util.add_labelbmf(bg,str,path,pos,ANCHOR_RIGHT_CENTER,50);

		if action == self.START then
			self:start();
		end
			
		return self.layer, self.name;
	end,

	start = function(self)
		self.layer:scheduleUpdateWithPriorityLua(self.load_res, 1);
	end,

	finish = function(self)
		self:remove();
		self.callback();
	end,

	get_list = function(self, stage)
		local list = {};
		if stage == STAGE_PVP or stage == STAGE_PVE or stage == STAGE_PVG then
			self:get_gui_res(list, GUI_MATCH);
		end
		return list;
	end,

	get_gui_res = function(self, list, ltype)
		local res_list = gui_get_list(ltype);
		for k, v in pairs(res_list) do
			if nil ~= v then
				if nil ~= v.filename1 and "0" ~= v.filename1 then
					local path = util.get_fullpath(F_IMAGE, v.filename1);
					table.insert(list, path);
				end
				if nil ~= v.filename2 and "0" ~= v.filename2 then
					local path = util.get_fullpath(F_IMAGE, v.filename1);
					table.insert(list, path);
				end
			end
		end
	end,

	load_res = function(dt)
		--util.preload_effect(util.get_fullpath(F_MUSIC, 'eff_win.mp3'));
		--util.preload_effect(util.get_fullpath(F_MUSIC, 'eff_lose.mp3'));
		--util.preload_effect(util.get_fullpath(F_MUSIC, 'eff_draw.mp3'));
		util.preload_effect(util.get_path('eff_win.mp3'));
		util.preload_effect(util.get_path('eff_lose.mp3'));
		util.preload_effect(util.get_path('eff_draw.mp3'));
		local self = layer_preload;
		local list = self.list or {};
		local count = 0;
		local total = #list;
		kdebug("load_res total[%d]", total);
		if 0 == total then
			self.layer:unscheduleUpdate();
			self:finish();
			return;
		end
		local function cb_load(texture)
			count = count + 1;
			local p = string.format("%.2f%%", count / total * 100);
			self.label_num:setString(p);
			if count >= total then
				self:finish();
			end
			return;
		end
		local cache = cc.Director:getInstance():getTextureCache();
		for i = 1, #list do
			local path = list[i];
			cache:addImageAsync(path, cb_load);
		end
		self.layer:unscheduleUpdate();
	end,

	handler = function(event, x, y)
		local self = layer_preload;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
			util.free_ram();
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
} -- layer_preload end

layer_solo = {
	name = 'layer_solo',
	layer = nil,
	tableview = nil,
	list = nil,
	cwidth = nil,
	cheight = nil,
	theight = nil,
	bar = nil,
	tap = nil,
	data_cell = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.tableview = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.theight = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_SOLO, self.handler, true);

		self.list = {};
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));
		local sprite, data;
		local offsetheight = init_bg_for_view(self.layer, GUI_PRACTICE, '练习', self.back);

		data = gui_get_data('cell', GUI_PRACTICE, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height + 10;
		data = gui_get_data('table', GUI_PRACTICE, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		self.theight = size.height;
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos,cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		return self.layer, self.name;
	end,

	reload = function(self)
		self.tableview:reloadData();
	end,

	add_list = function(self, list)
		self.list = list or {};
		self:reload();
	end,

	challenge = function(...)
		local args = {...};
		local sid = args[2]:getTag();
		local cmd = 'solo ' .. sid;
		net_send(cmd);
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_solo;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			--local cell = args[3];
			--local idx = cell:getIdx();
			--local info = self.list[idx + 1];
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell();
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new();
			local width = self.cwidth;
			local height = self.cheight;
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local info = self.list[idx + 1];
			local icon = info.icon;
			local eid = info.eid;
			local alias = info.alias;
			local level = info.level;
			local gold = info.gold;
			local data2, sprite, path, pos, size, str;

			sprite, data2 = gui_add_sprite_on_cell(cell, data, 'icon', GUI_PRACTICE, ANCHOR_DOWN);
			path = get_icon_path(icon);
			sprite = util.add_sprite(sprite, path,cc.p(0,0),ANCHOR_LEFT_DOWN,-1);
			sprite:setScale(data2.width/sprite:getContentSize().width);

			gui_add_sprite_on_cell(cell,data,'bg_alias',GUI_PRACTICE,ANCHOR_DOWN);
			str = alias;
			gui_add_label_on_cell(cell,data,str,28,'c_alias',GUI_PRACTICE,ANCHOR_DOWN);

			gui_add_sprite_on_cell(cell, data, 'bg_lv', GUI_PRACTICE,ANCHOR_DOWN);

			path = util.get_path('font_lv.fnt');
			str = 'LV.' .. level;
			gui_add_labelbmf_on_cell(cell,data,str,path,'lv',GUI_PRACTICE,ANCHOR_DOWN);

			str = '奖励:';
			gui_add_label_on_cell(cell,data,str,24,'t_reward',GUI_PRACTICE,ANCHOR_DOWN);
			gui_add_sprite_on_cell(cell, data, 'icon_gold', GUI_PRACTICE,ANCHOR_DOWN);
			path = util.get_path(FNT_1);
			str = gold;
			gui_add_labelbmf_on_cell(cell,data,str,path,'num_gold',GUI_PRACTICE,ANCHOR_DOWN);

			local items = {};
			local item;

			item, data2 = gui_add_item_on_cell(items, data, 'btn_play', GUI_PRACTICE, self.challenge, ANCHOR_DOWN);
			item:setTag(eid);
			gui_add_text_on_sprite(item,'挑战','t_play',GUI_PRACTICE,ANCHOR_DOWN,30);

			util.add_menu(cell, items, data2.zorder);
			return cell;
		end
	end, -- tableview_handler end }

	back = function()
		local self = layer_solo;
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_solo;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
} -- layer_solo end



layer_solo_plus = {
	name = 'layer_solo_plus',
	layer = nil,
	tableview = nil,
	list = nil,
	cwidth = nil,
	cheight = nil,
	theight = nil,
	bar = nil,
	tap = nil,
	data_cell = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.tableview = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.theight = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_SOLO_PLUS, self.handler, true);

		self.list = {};
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));
		local sprite, data;
		local offsetheight = init_bg_for_view(self.layer, GUI_PRACTICE, '练习', self.back);

		data = gui_get_data('cell', GUI_PRACTICE, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height + 10;
		data = gui_get_data('table', GUI_PRACTICE, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		self.theight = size.height;
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos,cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		return self.layer, self.name;
	end,

	reload = function(self)
		self.tableview:reloadData();
	end,

	add_list = function(self, list)
		self.list = list or {};
		self:reload();
	end,

	challenge = function(...)
		local args = {...};
		local sid = args[2]:getTag();
		local cmd = 'solo_plus ' .. sid;
		net_send(cmd);
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_solo_plus;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			--local cell = args[3];
			--local idx = cell:getIdx();
			--local info = self.list[idx + 1];
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell();
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new();
			local width = self.cwidth;
			local height = self.cheight;
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local info = self.list[idx + 1];
			local icon = '' .. info.hero_id;
			local eid = info.id;
			local alias = info.alias;
--			local level = info.level;
--			local gold = info.gold;
			local data2, sprite, path, pos, size, str;

			sprite, data2 = gui_add_sprite_on_cell(cell, data, 'icon', GUI_PRACTICE, ANCHOR_DOWN);
			path = get_icon_path(icon);
			sprite = util.add_sprite(sprite, path,cc.p(0,0),ANCHOR_LEFT_DOWN,-1);
			sprite:setScale(data2.width/sprite:getContentSize().width);

			gui_add_sprite_on_cell(cell,data,'bg_alias',GUI_PRACTICE,ANCHOR_DOWN);
			str = alias;
			gui_add_label_on_cell(cell,data,str,28,'c_alias',GUI_PRACTICE,ANCHOR_DOWN);

--			gui_add_sprite_on_cell(cell, data, 'bg_lv', GUI_PRACTICE,ANCHOR_DOWN);

--			path = util.get_path('font_lv.fnt');
--			str = 'LV.' .. level;
--			gui_add_labelbmf_on_cell(cell,data,str,path,'lv',GUI_PRACTICE,ANCHOR_DOWN);

--			str = '奖励:';
--			gui_add_label_on_cell(cell,data,str,24,'t_reward',GUI_PRACTICE,ANCHOR_DOWN);
--			gui_add_sprite_on_cell(cell, data, 'icon_gold', GUI_PRACTICE,ANCHOR_DOWN);
--			path = util.get_path(FNT_1);
--			str = gold;
--			gui_add_labelbmf_on_cell(cell,data,str,path,'num_gold',GUI_PRACTICE,ANCHOR_DOWN);

			local items = {};
			local item;

			item, data2 = gui_add_item_on_cell(items, data, 'btn_play', GUI_PRACTICE, self.challenge, ANCHOR_DOWN);
			item:setTag(eid);
			gui_add_text_on_sprite(item,'挑战','t_play',GUI_PRACTICE,ANCHOR_DOWN,30);

			util.add_menu(cell, items, data2.zorder);
			return cell;
		end
	end, -- tableview_handler end }

	back = function()
		local self = layer_solo_plus;
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_solo_plus;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
} -- layer_solo_plus end



layer_gate = {
	name = 'layer_gate',
	PAGE_SIZE = 15,
	layer = nil,
	tableview = nil,
	list = nil,
	cwidth = nil,
	cheight = nil,
	theight = nil,
	bar = nil,
	tap = nil,
	data_cell = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.tableview = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.theight = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_GATE, self.handler, true);

		self.list = {};
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));
		local sprite, data, rect;
		local offsetheight, sprite, rect = init_bg_for_view(self.layer, GUI_GATE, '闯关', self.back);

		self:add_tip(rect);

		data = gui_get_data('cell', GUI_GATE, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height + 10;
		data = gui_get_data('table', GUI_GATE, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		self.theight = size.height;
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos,cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		return self.layer, self.name;
	end,

	reload = function(self)
		self.tableview:reloadData();
	end,

	add_tip = function(self, rect)
		local size = cc.size(rect.x2-rect.x1, FULL_HEIGHT-rect.y2-20);
		if size.height > 150 then size.height = 150; end
		if size.height < 64 then size.height = 64; end
		local path = util.get_path('pop_up.png');
		local frect = cc.rect(0, 0, 64, 64); -- fullrect
		local irect = cc.rect(30, 30, 4, 4); -- insetrect
		local pos = cc.p(HALF_WIDTH, rect.y2+20);
		local bg = util.add_scale9sprite(self.layer, path, pos, ANCHOR_CENTER_DOWN, frect, irect, size, 10); 
		self.phase = bg;
		local str = "1.闯关模式下只要清除敌方所有盟军即可胜利\n2.闯关模式下我方英雄不能受到任何伤害，否则挑战失败"
		local label = util.add_labeloutline(bg, str, nil, 20, cc.p(size.width/2, size.height/2), util.c4b_gold, util.c4b_black, 2, ANCHOR_CENTER_CENTER, 10, cc.size(size.width-40, size.height-30), cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
	end,

	add_list = function(self, list, start_id, total_size, is_full)
		--self.list = list or {};
		--self:reload();
		self.list = self.list or {};
		if 1 == start_id then
			self.list = {};
		end
		local offset = nil;
		if #self.list > 0 then
			offset = self.tableview:getContentOffset();
		end
		list = list or {};
		local more_cell = { flag_more_cell = true };
		if 0 < #self.list then
			local m = self.list[#self.list];
			if true == m.flag_more_cell then
				table.remove(self.list, #self.list);
			end
		end
		for i = 1, #list do
			table.insert(self.list, list[i]);
		end
		if true ~= is_full and self.PAGE_SIZE == #list then
			table.insert(self.list, more_cell);
		end
		self:reload();
		if nil ~= offset then
			offset.y = offset.y - #list * self.cheight;
			self.tableview:setContentOffset(offset);
		end
	end,

	challenge = function(...)
		local self = layer_gate;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		if nil == info then return; end
		local cmd = 'gate ' .. info.gate_id;
		net_send(cmd);
	end,

	get_more = function()
		play_tap_1();
		local self = layer_gate;
		local len = #(self.list or {});
		if self.list[len].flag_more_cell == true then
			len = len - 1;
		end
		if len < 0 then len = 0; end
		local info = self.list[len];
		if nil == info then return; end
		local cmd = string.format("lgate %d %d", info.gate_id-1, self.PAGE_SIZE);
		net_send(cmd);
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_gate;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			--local cell = args[3];
			--local idx = cell:getIdx();
			--local info = self.list[idx + 1];
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell();
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new();
			local width = self.cwidth;
			local height = self.cheight;
			local info = self.list[idx+1];
			if true == info.flag_more_cell then
				local items = {};
				local pos = cc.p(width/2, height/2);
				local size = cc.size(172, 52);
				local item = add_item_1(items, '更多', nil, 20, self.get_more, ANCHOR_CENTER_CENTER, pos, size);
				item:setTag(idx + 1);

				util.add_menu(cell, items, 1);
				return cell;
			end
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local icon = info.focus_card;
			local title = info.title;
			local exp = info.exp;
			local gold = info.gold;
			local data2, sprite, path, pos, size, str;

			sprite, data2 = gui_add_sprite_on_cell(cell, data, 'icon', GUI_GATE, ANCHOR_DOWN);
			--path = get_icon_path(icon);
			--sprite = util.add_sprite(sprite, path,cc.p(0,0),ANCHOR_LEFT_DOWN,-1);
			--sprite:setScale(data2.width/sprite:getContentSize().width);
			local fname = string.format("card%d.png", icon);
			path = util.get_path(fname, 'picon_1_0.png');
			sprite = util.add_sprite(sprite, path,cc.p(data2.width/2,data2.height/2),ANCHOR_CENTER_CENTER,-1);
			sprite:setScaleX((data2.width-0)/sprite:getContentSize().width);
			sprite:setScaleY((data2.height-8)/sprite:getContentSize().height);

			gui_add_sprite_on_cell(cell,data,'bg_alias',GUI_GATE,ANCHOR_DOWN);
			str = title;
			gui_add_label_on_cell(cell,data,str,28,'c_alias',GUI_GATE,ANCHOR_DOWN);

			--[[
			gui_add_sprite_on_cell(cell, data, 'bg_lv', GUI_PRACTICE,ANCHOR_DOWN);

			path = util.get_path('font_lv.fnt');
			str = 'LV.' .. level;
			gui_add_labelbmf_on_cell(cell,data,str,path,'lv',GUI_GATE,ANCHOR_DOWN);
			]]--
			str = '经验:';
			gui_add_label_on_cell(cell,data,str,24,'t_exp',GUI_GATE,ANCHOR_DOWN);
			path = util.get_path(FNT_1);
			str = exp;
			gui_add_labelbmf_on_cell(cell,data,str,path,'num_exp',GUI_GATE,ANCHOR_DOWN);

			str = '奖励:';
			gui_add_label_on_cell(cell,data,str,24,'t_reward',GUI_GATE,ANCHOR_DOWN);
			gui_add_sprite_on_cell(cell, data, 'icon_gold', GUI_GATE,ANCHOR_DOWN);
			str = gold;
			gui_add_labelbmf_on_cell(cell,data,str,path,'num_gold',GUI_GATE,ANCHOR_DOWN);

			local items = {};
			local item;

			item, data2 = gui_add_item_on_cell(items, data, 'btn_play', GUI_GATE, self.challenge, ANCHOR_DOWN);
			item:setTag(idx+1);
			gui_add_text_on_sprite(item,'挑战','t_play',GUI_PRACTICE,ANCHOR_DOWN,30);

			util.add_menu(cell, items, data2.zorder);
			return cell;
		end
	end, -- tableview_handler end }

	back = function()
		local self = layer_gate;
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_gate;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
} -- layer_gate end

layer_mail = {
	name = 'layer_mail',
	layer = nil,
	list_toggle = nil,
	ctab = nil,
	sub_layer = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list_toggle = nil;
		self.ctab = nil;
		self.sub_layer = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_MAIL, self.handler, true);

		self.list = {};
		self.list_toggle = {};
		-- btn back set in g_scene.deck
		init_bg_for_full_view(self.layer, GUI_PRANK, '信件');

		local sprite, data, pos, size;
		local d1 = gui_get_data('bg_table', GUI_MAIL, ANCHOR_UP);
		local d2 = gui_get_data('bg_table', GUI_MAIL, ANCHOR_DOWN);
		local offsety = d1.y - d2.y;
		gui_add_sprite(self.layer, 'bg_table', GUI_MAIL,ANCHOR_DOWN,nil,offsety);

		local items = {};
		local item;

		local list_tab = { -- tab_id, unselected data index, selected data index
			{ 1, '收件箱' }, 
		};

		for i = 1, #list_tab do
			local info = list_tab[i];
			local key = 'tag' .. i;
			item, data = gui_add_item(items, key, GUI_MAIL, self.cb_toggle, ANCHOR_UP);
			key = 'tag_text' .. i;
			gui_add_text_outline_on_sprite(item, info[2], key, GUI_MAIL, ANCHOR_UP, 30);
			item:setTag(info[1]);
			table.insert(self.list_toggle, item);

			if i == #list_tab then
				util.add_labelttf(self.layer, '点击查看后自动删除信件', nil, 23, cc.p(data.x+data.width+10, data.y), util.c4b_black, ANCHOR_LEFT_DOWN, data.zorder+10);
			end
		end

		util.add_menu(self.layer, items, data.zorder);

		self:change_tab(1);

		return self.layer, self.name;
	end,

	show_mailbox = function(self)
		self.sub_layer = layer_mail_box;
		g_scene:add_layer(ZORDER_LAYER_MAIL_BOX, layer_mail_box:create());
	end,

	cb_toggle = function(tag, sender)
		play_tap_3();
		local self = layer_mail;
		-- self.toggle_info:getSelectedIndex()  0 : off     1 : on
		--sender = tolua.cast(sender, "cc.MenuItemToggle");
		--print('selected item:tag:%d, index:%d', tag, sender:getSelectedIndex());
		self:change_tab(tag);
	end,

	change_tab = function(self, tab)
		for i = 1, #self.list_toggle do
			local toggle = self.list_toggle[i];
			local tag = toggle:getTag();
			if tag ~= tab then
				toggle:setSelectedIndex(0);
			else
				toggle:setSelectedIndex(1);
			end
		end
		--print('tab: ', tab, self.ctab);
		if tab == self.ctab then
			return;
		end
		self.ctab = tab;
		if nil ~= self.sub_layer then
			self.sub_layer:back();
			self.sub_layer = nil;
		end
		if 1 == self.ctab then
			local cmd = string.format("list_message 0 %d", layer_mail_box.PAGE_SIZE);
			net_send(cmd);
		end
	end,

	back = function()
		play_tap_1();
		g_scene:map();
	end,

	handler = function(event, x, y)
		local self = layer_mail;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
} -- layer_mail end

layer_mail_box = {
	name = 'layer_mail_box',
	PAGE_SIZE = 10, -- server max page_size is 10
	layer = nil,
	tableview = nil,
	list = nil,
	cwidth = nil,
	cheight = nil,
	theight = nil,
	bar = nil,
	tap = nil,
	data_cell = nil,
	read_index = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.tableview = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.theight = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell = nil;
		self.read_index = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_MAIL_BOX, self.handler, false);

		self.list = {};
		local sprite, data, pos, size;
		local d1 = gui_get_data('bg_table', GUI_MAIL, ANCHOR_UP);
		local d2 = gui_get_data('bg_table', GUI_MAIL, ANCHOR_DOWN);
		local offsety = d1.y - d2.y;

		local line_data = gui_get_data('line', GUI_MAIL, ANCHOR_DOWN);
		data = gui_get_data('cell', GUI_MAIL, ANCHOR_DOWN);
		self.cwidth = data.width;
		--self.cheight = data.height;
		self.cheight = data.y + data.height - line_data.y;
		self.data_cell = data;

		data = gui_get_data('table', GUI_MAIL, ANCHOR_DOWN);
		size = cc.size(data.width, data.height + offsety);
		self.theight = size.height;
		pos = cc.p(data.x, data.y);
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, ccp(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+10);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		return self.layer, self.name;
	end,

	reload = function(self)
		self.tableview:reloadData();
	end,

	add_list = function(self, list, start_pos, total)
		list = list or {};
		local more_cell = { flag_more_cell = true };
		self.list = self.list or {};
		if 0 == start_pos then
			self.list = {};
		end
		if 0 < #self.list then
			local m = self.list[#self.list];
			if true == m.flag_more_cell then
				table.remove(self.list, #self.list);
			end
		end
		for i = 1, #list do
			table.insert(self.list, list[i]);
		end
		if 0 < #list and total > #list and self.PAGE_SIZE == #list then
			table.insert(self.list, more_cell);
		end

		self:reload();
	end,

	get_more = function()
		play_tap_1();
		local self = layer_mail_box;
		local len = #(self.list or {}) - 1;
		if len < 0 then len = 0; end
		local cmd = string.format("list_message %d %d", len, self.PAGE_SIZE);
		net_send(cmd);
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_mail_box;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell();
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new();
			local width = self.cwidth;
			local height = self.cheight;
			local info = self.list[idx + 1];
			if true == info.flag_more_cell then
				local items = {};
				local pos = cc.p(width/2, height/2);
				local size = cc.size(172, 52);
				local item = add_item_1(items, '更多', nil, 20, self.get_more, ANCHOR_CENTER_CENTER, pos, size);
				item:setTag(idx + 1);

				util.add_menu(cell, items, 1);
				return cell;
			end
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local title = info.title;
			local time = info.time;
			local data2, sprite, path, pos, size, str;

			gui_add_sprite_on_cell(cell,data,'line',GUI_MAIL,ANCHOR_DOWN);
			str = title;
			gui_add_label_on_cell(cell,data,str,28,'c_title',GUI_MAIL,ANCHOR_DOWN);

			local t = os.date("*t", time);
			str = string.format("%02d月%02d日 %02d:%02d:%02d", t.month, t.day, t.hour, t.min, t.sec);
			gui_add_label_on_cell(cell,data,str,22,'c_time',GUI_MAIL,ANCHOR_DOWN);

			local items = {};
			local item;

			item, data2 = gui_add_item_on_cell(items, data, 'btn_check', GUI_MAIL, self.check, ANCHOR_DOWN);
			item:setTag(idx+1);
			gui_add_text_on_sprite(item,'查看','t_check',GUI_MAIL,ANCHOR_DOWN,30);

			util.add_menu(cell, items, data2.zorder);

			return cell;
		end
	end, -- tableview_handler end }

	check = function(...)
		local self = layer_mail_box;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		if nil == info then return; end
		self.read_index = index;
		local mid = info.message_id;
		local cmd = string.format("read_message %d", mid);
		net_send(cmd);
	end,

	delete_read_cell = function(self)
		if nil == self.layer then return; end
		if nil == self.read_index then return; end
		local toffset = self.tableview:getContentOffset();
		local cnum = math.floor(self.theight / self.cheight);
		if self.read_index < cnum then
			toffset.y = toffset.y + self.cheight;
		end
		table.remove(self.list, self.read_index);
		self.read_index = nil;
		self:reload();
		self.tableview:setContentOffset(toffset);
	end,

	back = function()
		local self = layer_mail_box;
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_mail_box;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
} -- layer_mail_box end

layer_prank = {
	name = 'layer_prank',
	layer = nil,
	list_toggle = nil,
	ctab = nil,
	sub_layer = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list_toggle = nil;
		self.ctab = nil;
		self.sub_layer = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_PRANK, self.handler, true);

		self.list = {};
		self.list_toggle = {};
		-- btn back set in g_scene.deck
		init_bg_for_full_view(self.layer, GUI_PRANK, '竞技场');

		local sprite, data, pos, size;
		local d1 = gui_get_data('bg_table', GUI_PRANK, ANCHOR_UP);
		local d2 = gui_get_data('bg_table', GUI_PRANK, ANCHOR_DOWN);
		local offsety = d1.y - d2.y;
		gui_add_sprite(self.layer, 'bg_table', GUI_PRANK,ANCHOR_DOWN,nil,offsety);

		local items = {};
		local item;

		local list_tab = { -- tab_id, unselected data index, selected data index
			{ 1, '竞技场' }, { 2, '排行榜' }, 
		};

		for i = 1, #list_tab do
			local info = list_tab[i];
			local key = 'tag' .. i;
			item, data = gui_add_item(items, key, GUI_PRANK, self.cb_toggle, ANCHOR_UP);
			key = 'tag_text' .. i;
			gui_add_text_outline_on_sprite(item, info[2], key, GUI_PRANK, ANCHOR_UP, 30);
			item:setTag(info[1]);
			table.insert(self.list_toggle, item);

		end

		util.add_menu(self.layer, items, data.zorder);

		self:change_tab(1);

		return self.layer, self.name;
	end,

	show_challenge = function(self, list, gold, crystal, remain_time, rank, challenge_time)
		self.sub_layer = layer_prank_c;
		g_scene:add_layer(ZORDER_LAYER_PRANK_C, layer_prank_c:create(list, gold, crystal, remain_time, rank, challenge_time));
	end,

	show_rank = function(self, list, gold, crystal, remain_time, rank, challenge_time)
		self.sub_layer = layer_prank_r;
		g_scene:add_layer(ZORDER_LAYER_PRANK_R, layer_prank_r:create(list, gold, crystal, remain_time, rank, challenge_time));
	end,

	cb_toggle = function(tag, sender)
		play_tap_3();
		local self = layer_prank;
		-- self.toggle_info:getSelectedIndex()  0 : off     1 : on
		--sender = tolua.cast(sender, "cc.MenuItemToggle");
		--print('selected item:tag:%d, index:%d', tag, sender:getSelectedIndex());
		self:change_tab(tag);
	end,

	change_tab = function(self, tab)
		for i = 1, #self.list_toggle do
			local toggle = self.list_toggle[i];
			local tag = toggle:getTag();
			if tag ~= tab then
				toggle:setSelectedIndex(0);
			else
				toggle:setSelectedIndex(1);
			end
		end
		--print('tab: ', tab, self.ctab);
		if tab == self.ctab then
			return;
		end
		self.ctab = tab;
		if nil ~= self.sub_layer then
			self.sub_layer:back();
			self.sub_layer = nil;
		end
		if 1 == self.ctab then
			net_send('rtarlist');
		else
			net_send('rlist');
		end
	end,

	back = function()
		play_tap_1();
		g_scene:map();
	end,

	handler = function(event, x, y)
		local self = layer_prank;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
} -- layer_prank end

layer_prank_c = {
	name = 'layer_prank_c',
	layer = nil,
	tableview = nil,
	list = nil,
	cwidth = nil,
	cheight = nil,
	theight = nil,
	bar = nil,
	tap = nil,
	data_cell = nil,
	rtime = nil,
	systime = nil,
	t_rtime = nil,
	ctime = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.tableview = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.theight = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell = nil;
		self.rtime = nil;
		self.systime = nil;
		self.t_rtime = nil;
		self.ctime = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, list, gold, crystal, remain_time, rank, challenge_time)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_PRANK_C, self.handler, false);

		self.list = list or {};
		self.ctime = challenge_time or 0;
		self.rtime = remain_time or 0;
		self.systime = os.time();
		local sprite, data, pos, size;
		local d1 = gui_get_data('bg_table', GUI_PRANK, ANCHOR_UP);
		local d2 = gui_get_data('bg_table', GUI_PRANK, ANCHOR_DOWN);
		local offsety = d1.y - d2.y;

		gui_add_label(self.layer, '当前排名:', 24, 't_rank', GUI_PRANK,ANCHOR_UP);
		gui_add_label(self.layer, '奖励:', 24, 't_reward', GUI_PRANK, ANCHOR_UP);
		gui_add_label(self.layer, '发奖倒计时:', 24, 't_time', GUI_PRANK, ANCHOR_UP);
		gui_add_label(self.layer, '剩余次数:', 24, 't_left',GUI_PRANK, ANCHOR_UP);

		local path = util.get_path(FNT_1);
		str = rank .. '';
		gui_add_labelbmf(self.layer, str, path, 'n_rank', GUI_PRANK, ANCHOR_UP);
		local icon = nil;
		if crystal > 0 then
			icon = gui_add_sprite(self.layer, 'crystal', GUI_PRANK, ANCHOR_UP);
			str = crystal .. '';
		elseif gold > 0 then
			icon = gui_add_sprite(self.layer, 'gold', GUI_PRANK, ANCHOR_UP);
			str = gold .. '';
		else
			str = '';
		end
		sprite, data = gui_add_labelbmf(self.layer, str, path, 'n_reward', GUI_PRANK, ANCHOR_UP);
		if nil ~= icon then
			icon:setPositionX(data.x+sprite:getContentSize().width+4);
		end
		if nil ~= remain_time then
			local r = remain_time;
			local sec = r % 60;
			local min = math.floor(r / 60);
			local hour = math.floor(min / 60);
			min = min % 60;
			str = string.format("%02d:%02d:%02d", hour, min, sec);
		else
			str = '';
		end
		self.t_rtime = gui_add_labelbmf(self.layer, str, path, 'n_time', GUI_PRANK, ANCHOR_UP);
		str = challenge_time .. '';
		gui_add_labelbmf(self.layer, str, path, 'n_left', GUI_PRANK, ANCHOR_UP);

		gui_add_sprite(self.layer, 'line', GUI_PRANK, ANCHOR_UP);

		data = gui_get_data('c_cell', GUI_PRANK, ANCHOR_DOWN);
		self.cwidth = data.width;
		self.cheight = data.height;
		self.data_cell = data;

		data = gui_get_data('c_table', GUI_PRANK, ANCHOR_DOWN);
		size = cc.size(data.width, data.height + offsety);
		pos = cc.p(data.x, data.y);
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, ccp(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+10);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		self.layer:scheduleUpdateWithPriorityLua(self.update_time, 1);

		return self.layer, self.name;
	end,

	update_time = function(delta)
		local self = layer_prank_c;
		if nil == self.t_rtime then return; end

		local ntime = os.time();
		local otime = self.systime;
		local t = self.rtime - (ntime - otime);
		if t <= 0 then
			self.t_rtime:setString('00:00:00');
			self.layer:unscheduleUpdate();
			return;
		end
		local sec = t % 60;
		local min = math.floor(t / 60);
		local hour = math.floor(min / 60);
		min = min % 60;
		local str = string.format("%02d:%02d:%02d", hour, min, sec);
		self.t_rtime:setString(str);
	end,

	reload = function(self)
		self.tableview:reloadData();
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_prank_c;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell();
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new();
			local width = self.cwidth;
			local height = self.cheight;
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local info = self.list[idx + 1];
			local icon = info.icon;
			local eid = info.eid;
			local alias = info.alias;
			local rating = info.rating;
			local level = info.level;
			local rank = info.rank;
			local data2, sprite, path, pos, size, str;

			sprite, data2 = gui_add_sprite_on_cell(cell, data, 'c_icon', GUI_PRANK, ANCHOR_DOWN);
			path = get_icon_path(icon);
			sprite = util.add_sprite(sprite, path,cc.p(0,0),ANCHOR_LEFT_DOWN,-1);
			sprite:setScale(data2.width/sprite:getContentSize().width);

			gui_add_sprite_on_cell(cell,data,'c_bg_alias',GUI_PRANK,ANCHOR_DOWN);
			str = alias;
			gui_add_label_on_cell(cell,data,str,28,'c_alias',GUI_PRANK,ANCHOR_DOWN);

			path = util.get_path(FNT_1);

			str = '排名:';
			gui_add_label_on_cell(cell,data,str,22,'c_t_rank',GUI_PRANK,ANCHOR_DOWN);
			str = rank;
			gui_add_labelbmf_on_cell(cell,data,str,path,'c_n_rank',GUI_PRANK,ANCHOR_DOWN);

			str = '胜率:';
			gui_add_label_on_cell(cell,data,str,22,'c_t_win',GUI_PRANK,ANCHOR_DOWN);
			str = math.floor(rating * 100) .. '%';
			gui_add_labelbmf_on_cell(cell,data,str,path,'c_n_win',GUI_PRANK,ANCHOR_DOWN);

			gui_add_sprite_on_cell(cell, data, 'c_bg_lv', GUI_PRANK, ANCHOR_DOWN);
			path = util.get_path('font_lv.fnt');
			str = 'LV.' .. level;
			gui_add_labelbmf_on_cell(cell,data,str,path,'c_lv',GUI_PRANK,ANCHOR_DOWN);

			local items = {};
			local item;

			item, data2 = gui_add_item_on_cell(items, data, 'c_btn_action', GUI_PRANK, self.challenge, ANCHOR_DOWN);
			item:setTag(idx+1);
			gui_add_text_on_sprite(item,'挑战','c_t_action',GUI_PRANK,ANCHOR_DOWN,30);

			util.add_menu(cell, items, data2.zorder);

			return cell;
		end
	end, -- tableview_handler end }

	challenge = function(...)
		local self = layer_prank_c;
		local t = self.ctime or 0;
		if 0 >= t then
			show_msg('挑战机会已用完');
			return;
		end
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		if nil == info then return; end
		local eid = info.eid;
		local rank = info.rank;
		local cmd = string.format("rgame %d %d", eid, rank);
		net_send(cmd);
	end,

	back = function()
		local self = layer_prank_c;
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_prank_c;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
} -- layer_prank_c end

layer_prank_r = {
	name = 'layer_prank_r',
	layer = nil,
	tableview = nil,
	list = nil,
	cwidth = nil,
	cheight = nil,
	theight = nil,
	bar = nil,
	tap = nil,
	data_cell = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.tableview = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.theight = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, list, gold, crystal, remain_time, rank, challenge_time)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_PRANK_R, self.handler, false);

		self.list = list or {};
		local sprite, data, pos, size;
		local d1 = gui_get_data('bg_table', GUI_PRANK, ANCHOR_UP);
		local d2 = gui_get_data('bg_table', GUI_PRANK, ANCHOR_DOWN);
		local offsety = d1.y - d2.y;

		gui_add_label(self.layer, '当前排名:', 24, 't_rank_2', GUI_PRANK, ANCHOR_UP);

		local path = util.get_path(FNT_1);
		str = rank .. '';
		gui_add_labelbmf(self.layer, str, path, 'n_rank', GUI_PRANK, ANCHOR_UP);

		gui_add_sprite(self.layer, 'line_2', GUI_PRANK, ANCHOR_UP);

		data = gui_get_data('r_cell', GUI_PRANK, ANCHOR_DOWN);
		self.cwidth = data.width;
		self.cheight = data.height;
		self.data_cell = data;

		data = gui_get_data('r_table', GUI_PRANK, ANCHOR_DOWN);
		size = cc.size(data.width, data.height + offsety);
		pos = cc.p(data.x, data.y);
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, ccp(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+10);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		return self.layer, self.name;
	end,

	reload = function(self)
		self.tableview:reloadData();
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_prank_r;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell();
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new();
			local width = self.cwidth;
			local height = self.cheight;
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local info = self.list[idx + 1];
			local icon = info.icon;
			local eid = info.eid;
			local alias = info.alias;
			local rating = info.rating;
			local level = info.level;
			local rank = info.rank;
			local data2, sprite, path, pos, size, str;

			sprite, data2 = gui_add_sprite_on_cell(cell, data, 'r_icon', GUI_PRANK, ANCHOR_DOWN);
			path = get_icon_path(icon);
			sprite = util.add_sprite(sprite, path,cc.p(0,0),ANCHOR_LEFT_DOWN,-1);
			sprite:setScaleX(data2.width/sprite:getContentSize().width);
			sprite:setScaleY(data2.height/sprite:getContentSize().height);

			gui_add_sprite_on_cell(cell,data,'r_bg_alias',GUI_PRANK,ANCHOR_DOWN);
			str = alias;
			gui_add_label_on_cell(cell,data,str,28,'r_alias',GUI_PRANK,ANCHOR_DOWN);

			path = util.get_path(FNT_1);

			str = '胜率:';
			gui_add_label_on_cell(cell,data,str,22,'r_t_win',GUI_PRANK,ANCHOR_DOWN);
			str = math.floor(rating * 100) .. '%';
			gui_add_labelbmf_on_cell(cell,data,str,path,'r_n_win',GUI_PRANK,ANCHOR_DOWN);

			gui_add_sprite_on_cell(cell, data, 'r_bg_lv', GUI_PRANK, ANCHOR_DOWN);
			path = util.get_path('font_lv.fnt');
			str = 'LV.' .. level;
			gui_add_labelbmf_on_cell(cell,data,str,path,'r_lv',GUI_PRANK,ANCHOR_DOWN);

			local key;
			if rank < 4 then
				key = 'r_cup' .. rank;
			else
				key = 'r_cup4';
			end
			gui_add_sprite_on_cell(cell, data, key, GUI_PRANK, ANCHOR_DOWN);
			path = util.get_path('rank.fnt');
			str = rank .. '';
			if rank < 4 then
				key = 'r_n_cup';
			else
				key = 'r_n_cup4';
			end
			sprite, data2 = gui_add_labelbmf_on_cell(cell,data,str,path,key,GUI_PRANK,ANCHOR_DOWN);
			sprite:setAnchorPoint(ANCHOR_CENTER_DOWN);
			sprite:setPositionX(data2.x+data2.width/2);

			return cell;
		end
	end, -- tableview_handler end }

	back = function()
		local self = layer_prank_r;
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_prank_r;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
} -- layer_prank_r end

layer_prank_tip = {
	name = 'layer_prank_tip',
	layer = nil,
	data = nil,
	TYPE_WAIT = 1,
	TYPE_REPLY = 2,
	count = nil,
	otime = nil,

	cleanup = function(self)
		self.layer = nil;
		self.callback = nil;
		self.data = nil;
		self.count = nil;
		self.otime = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, msg, tip_type, data)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_PRANK_TIP, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));

		self.otime = os.time();
		local path = util.get_path('pop_up.png');
		local frect = cc.rect(0, 0, 64, 64); -- fullrect
		local irect = cc.rect(30, 30, 4, 4); -- insetrect
		local size = cc.size(wfix(505), hfix(302));--realsize
		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		local bg = util.add_scale9sprite(self.layer, path, pos, ANCHOR_CENTER_CENTER, frect, irect, size, 10); 

    	if nil ~= msg then
			pos = cc.p(size.width/2, size.height-50);
			local lsize = cc.size(size.width-40, 70);
			util.add_labeloutline(bg, msg, nil, 25, pos, util.c4b_white, util.c4b_black, 1, ANCHOR_CENTER_UP, 1, lsize, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_TOP);
    	end

		local path = util.get_path(FNT_1);
		self.count = util.add_labelbmf(bg, '10', path, cc.p(size.width/2, size.height-100), ANCHOR_CENTER_UP, 10);
		self.layer:scheduleUpdateWithPriorityLua(self.update_time, 1);

		if tip_type == self.TYPE_WAIT then
			self:init_btn_for_wait(bg, size, data);
			return self.layer, self.name;
		end
		if tip_type == self.TYPE_REPLY then
			self:init_btn_for_reply(bg, size, data);
			return self.layer, self.name;
		end

		local items = {};

		pos = cc.p(size.width/2, 28);
		add_item_1(items, '取消',nil,30,self.remove,ANCHOR_CENTER_DOWN,pos);
		
		util.add_menu(bg, items, 1);

		return self.layer, self.name;
	end,

	update_time = function(delta)
		local self = layer_prank_tip;
		local ntime = os.time();
		local c = 10 - (ntime - self.otime);
		local label = self.count;
		if nil == label then
			self.layer:unscheduleUpdate();
			return;
		end
		--local c = tonumber(label:getString());
		if nil == c then
			label:setString(0);
			self.layer:unscheduleUpdate();
			return;
		end
		c = c - 1;
		if c < 0 then
			self.layer:unscheduleUpdate();
			self:remove();
			return;
		end
		label:setString(c);
	end,

	cancel_wait = function()
		local self = layer_prank_tip;
		local data = self.data;
		self:remove();
		local cmd = string.format("rcancel %d", data.eid);
		net_send(cmd);
	end,

	init_btn_for_wait = function(self, bg, size, data)
		self.data = data;
		local items = {};
		local item, p1, p2, pos;

		pos = cc.p(size.width/2, 28);
		add_item_1(items, '取消',nil,30,self.cancel_wait,ANCHOR_CENTER_DOWN,pos);
		
		util.add_menu(bg, items, 1);
	end,

	accept_fight = function()
		local self = layer_prank_tip;
		local data = self.data;
		self:remove();
		local cmd = string.format("rresp %d 1", data.eid);
		net_send(cmd);
	end,

	refuse_fight = function()
		local self = layer_prank_tip;
		local data = self.data;
		self:remove();
		local cmd = string.format("rresp %d 0", data.eid);
		net_send(cmd);
	end,

	init_btn_for_reply = function(self, bg, size, data)
		self.data = data;
		local items = {};

		pos = cc.p(size.width/4*3, 28);
		add_item_1(items, '接受',nil,30,self.accept_fight,ANCHOR_CENTER_DOWN,pos);

		pos = cc.p(size.width/4, 28);
		add_item_1(items, '拒绝',nil,30,self.refuse_fight,ANCHOR_CENTER_DOWN,pos);
		
		util.add_menu(bg, items, 1);
	end,

	handler = function(event, x, y)
		local self = layer_prank_tip;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
	end,

} -- layer_prank_tip end

layer_anim = { -- start
	name = 'layer_anim',
	layer = nil, 

	cleanup = function(self)
		self.layer = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_ANIM, self.handler, false);
		
		return self.layer, self.name;
	end, 

	handler = function(event, x, y)
		local self = layer_anim;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)
	end,

} -- layer_anim end

layer_loading = { -- start
	name = 'layer_loading',
	layer = nil, 

	cleanup = function(self)
		self.layer = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, text)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_LOADING, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 128));

		local path = util.get_path('title_popup.png');
		local fullrect = cc.rect(0, 0, 64, 56);
		local insetrect = cc.rect(30, 26, 4, 4);
		local size = cc.size(wfix(300), wfix(120));
		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		local bg = util.add_scale9sprite(self.layer, path, pos, ANCHOR_CENTER_CENTER, fullrect, insetrect, size, 10); 

		path = util.get_path('icon_loading.png');
		pos = cc.p(wfix(60), size.height/2);
		sprite = util.add_sprite(bg, path, pos, ANCHOR_CENTER_CENTER);
		sprite:runAction(cc.RepeatForever:create(cc.RotateBy:create(0.1, 30)));

		text = text or '...';
		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		pos = cc.p(wfix(130), size.height/2);
		util.add_label(bg, text, 30, pos, util.c_black, ANCHOR_LEFT_CENTER);

		return self.layer, self.name;
	end, 

	handler = function(event, x, y)
		local self = layer_loading;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)
	end,

} -- layer_anim end

layer_deck = {
	name = 'layer_deck',
	layer = nil,
	list_pick_deck = nil,
	list_pick_slot = {
		{ tag = 1, title = '所有分类', },
		{ tag = 2, title = '附加', },
		{ tag = 3, title = '技能', },
		{ tag = 4, title = '盟军', },
		{ tag = 5, title = '武器', },
		{ tag = 6, title = '防具', },
		{ tag = 7, title = '支援', },
		{ tag = 8, title = '牌库', },
	},
	in_slot_pick = nil,
	total_deck_label = nil,
	total_slot_label = nil,
	label_deck_pick = nil,
	label_slot_pick = nil,
	eb_name = nil,
	deck_sid = nil,
	deck_name = nil,
	has_modify = nil,
	list_hero = nil,
	list_deck = nil,
	list_slot = nil,
	list_slot_total = nil,
	hero_id = nil,
	tableview_deck = nil,
	tableview_slot = nil,
	cwidth_deck = nil,
	cheight_deck = nil,
	twidth_deck = nil;
	cwidth_slot = nil,
	cheight_slot = nil,
	twidth_slot = nil,
	cscale = nil,
	clarrow_deck = nil,
	crarrow_deck = nil,
	clarrow_slot = nil,
	crarrow_slot = nil,
	touch_card = nil,
	touch_point = nil,
	line_deck = nil,
	line_slot = nil,
	is_touching = nil,
	is_should_quit = nil,
	b_slot_id = nil,
	b_slot_gold = nil,
	b_slot_crystal = nil,
	btn_back = nil, -- set in scene deck init

	cleanup = function(self)
		self.layer = nil;
		self.list_pick_deck = nil;
		self.in_slot_pick = nil;
		self.total_deck_label = nil;
		self.total_slot_label = nil;
		self.label_deck_pick = nil;
		self.label_slot_pick = nil;
		self.eb_name = nil;
		self.has_modify = false;
		--self.deck_sid = nil; -- no need to reset
		self.deck_name = nil;
		self.list_hero = nil;
		self.list_deck = nil;
		self.list_slot = nil;
		self.list_slot_total = nil;
		self.hero_id = nil;
		self.tableview_deck = nil;
		self.tableview_slot = nil;
		self.cwidth_deck = nil;
		self.cheight_deck = nil;
		self.twidth_deck = nil;
		self.cwidth_slot = nil;
		self.cheight_slot = nil;
		self.twidth_slot = nil;
		self.cscale = nil;
		self.clarrow_deck = nil;
		self.crarrow_deck = nil;
		self.clarrow_slot = nil;
		self.crarrow_slot = nil;
		self.touch_card = nil;
		self.touch_point = nil;
		self.line_deck = nil;
		self.line_slot = nil;
		self.is_touching = nil;
		self.is_should_quit = nil;
		self.b_slot_id = nil;
		self.b_slot_gold = nil;
		self.b_slot_crystal = nil;
		self.btn_back = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();
		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_DECK, self.handler, true);

		self.is_should_quit = false;
		self.list_pick_deck = {};

		-- btn back set in g_scene.deck
		init_bg_for_full_view(self.layer, GUI_DECK, '牌堆');
		local sprite, path, pos, size, data, items, item;
		sprite, data = gui_add_sprite(self.layer, 'bg_slot', GUI_DECK, ANCHOR_UP);
		-- add book btn
		items = {};

		add_item_1(items, '图鉴', nil, 25, show_book, ANCHOR_LEFT_DOWN, cc.p(data.x, data.y+data.height), cc.size(120, 64));

		util.add_menu(self.layer, items, 90);
		--
		gui_add_label(self.layer, '上阵卡数:', 24, 't_slot', GUI_DECK, ANCHOR_UP);
		self.total_deck_label = gui_add_label(self.layer, '( )', 24, 'n_slot', GUI_DECK, ANCHOR_UP);

		items = {};
		item, data = gui_add_item(items, 'bg_cslot', GUI_DECK, self.pick_deck_check, ANCHOR_UP);
		util.add_menu(self.layer, items, data.zorder);

		self.label_deck_pick, data = gui_add_label(self.layer, '切换牌堆', 22, 't_cslot', GUI_DECK, ANCHOR_UP);
		self.eb_name = util.add_editbox_blank(self.layer, 
			cc.size(data.width, data.height), ANCHOR_LEFT_DOWN, 
			cc.p(data.x, data.y), util.f_default, 22, util.c_white, 
			cc.EDITBOX_INPUT_MODE_SINGLELINE, cc.KEYBOARD_RETURNTYPE_DONE, 
			nil, self.editbox_handler, 8, '', util.c_gray, data.zorder);
		self.eb_name:setVisible(false);

		local d1 = gui_get_data('bg_other', GUI_DECK, ANCHOR_UP);
		local d2 = gui_get_data('bg_other', GUI_DECK, ANCHOR_DOWN);
		local offsety = d1.y - d2.y;

		gui_add_sprite(self.layer, 'bg_other', GUI_DECK, ANCHOR_UP, -offsety/2);
		gui_add_label(self.layer, '闲置卡牌:', 24, 't_other', GUI_DECK, ANCHOR_UP, nil, -offsety/2);
		self.total_slot_label = gui_add_label(self.layer, '( )', 24, 'n_other', GUI_DECK, ANCHOR_UP, nil, -offsety/2);
		gui_add_sprite(self.layer, 'bg_cother', GUI_DECK, ANCHOR_UP, -offsety/2);
		self.label_slot_pick = gui_add_label(self.layer, '', 22, 't_cother', GUI_DECK, ANCHOR_UP, nil, -offsety/2);

		data = gui_get_data('table_slot', GUI_DECK, ANCHOR_UP);
		pos = cc.p(data.x, data.y - offsety/2);
		size = cc.size(data.width, data.height + offsety/2);
		self.cscale = size.height / CARD_SIZE.height * 0.9;
		self.cwidth_deck = CARD_SIZE.width * self.cscale * 1.3;
		self.cheight_deck = size.height;
		self.twidth_deck = size.width;
		self.line_deck = pos.y;
		self.tableview_deck = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_HORIZONTAL, self.tableview_deck_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, data.zorder);
		self.clarrow_deck, self.crarrow_deck = util.add_arrows(self.layer, pos, size, self.cwidth_deck, 0, cc.p(0, 0));

		data = gui_get_data('table_other', GUI_DECK, ANCHOR_UP);
		pos = cc.p(data.x, data.y - offsety);
		size = cc.size(data.width, data.height + offsety/2);
		self.cwidth_slot = CARD_SIZE.width * self.cscale * 1.3;
		self.cheight_slot = size.height;
		self.twidth_slot = size.width;
		self.line_slot = pos.y + size.height;
		self.tableview_slot = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_HORIZONTAL, self.tableview_slot_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, data.zorder);
		self.clarrow_slot, self.crarrow_slot = util.add_arrows(self.layer, pos, size, self.cwidth_slot, 0, cc.p(0, 0));

		items = {};

		item, data = gui_add_item(items, 'more_slot', GUI_DECK, self.pick_deck, ANCHOR_UP);

		item, data = gui_add_item(items, 'more_other', GUI_DECK, self.pick_slot, ANCHOR_UP, -offsety/2);

		item, data = gui_add_item(items, 'btn_save', GUI_DECK, self.callback_save, ANCHOR_DOWN);
		gui_add_text_on_sprite(item, "保存", 't_save', GUI_DECK, ANCHOR_DOWN, 30);

		item, data = gui_add_item(items, 'btn_clear', GUI_DECK, self.callback_clear, ANCHOR_DOWN);
		gui_add_text_on_sprite(item, "清空", 't_clear', GUI_DECK, ANCHOR_DOWN,30);

		item, data = gui_add_item(items, 'btn_chero', GUI_DECK, self.callback_hero, ANCHOR_DOWN);
		gui_add_text_on_sprite(item, "选英雄", 't_chero',GUI_DECK,ANCHOR_DOWN,30);

		util.add_menu(self.layer, items, data.zorder);

		--[[

		self.line_deck = 0;
		self.line_slot = 0;

		data = gui_get_data('table_deck', GUI_DECK, ANCHOR_CENTER);
		pos = cc.p(data.x, data.y-tvh/2);
		size = cc.size(data.width, data.height+tvh/2);
		self.cscale = size.height / CARD_SIZE.height * 0.9;
		self.cwidth_deck = CARD_SIZE.width * self.cscale * 1.3;
		self.cheight_deck = size.height;
		self.twidth_deck = size.width;
		self.line_deck = pos.y;
		self.tableview_deck = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_HORIZONTAL, self.tableview_deck_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, data.zorder);
		self.clarrow_deck, self.crarrow_deck = util.add_arrows(self.layer, pos, size, self.cwidth_deck, 0, cc.p(0, 0));

		data = gui_get_data('table_slot', GUI_DECK, ANCHOR_CENTER);
		pos = cc.p(data.x, data.y-tvh);
		size = cc.size(data.width, data.height+tvh/2);
		self.cwidth_slot = CARD_SIZE.width * self.cscale * 1.3;
		self.cheight_slot = size.height;
		self.twidth_slot = size.width;
		self.line_slot = pos.y + size.height;
		self.tableview_slot = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_HORIZONTAL, self.tableview_slot_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, data.zorder);
		self.clarrow_slot, self.crarrow_slot = util.add_arrows(self.layer, pos, size, self.cwidth_slot, 0, cc.p(0, 0));
		]]--

		return self.layer, self.name;

	end,

	set_slot_list = function(self, list)
		self.list_pick_deck = {};
		for i = 1, #(list or {}) do
			table.insert(self.list_pick_deck, list[i]);
		end
		local list = self.list_pick_deck;
		local cb = self.callback_pick_deck;
		local layer = layer_pick:create(list, cb, 'is_deck');
		g_scene:add_layer(ZORDER_LAYER_PICK, layer);

		net_send('bslot 0 ' .. (#list + 1));
	end,

	set_buy_slot_btn = function(self, sid, gold, crystal)
		local layer = layer_pick.layer;
		if nil == layer then
			return;
		end
		self.b_slot_id = sid;
		self.b_slot_gold = gold;
		self.b_slot_crystal = crystal;

		local items = {};
		local item, pos, size;

		size = cc.size(172, 52);
		if gold > 0 then
			pos = cc.p(HALF_WIDTH/2, hfix(28));
			item = add_item_1(items, '金币开卡槽', nil, 20, self.buy_slot, ANCHOR_CENTER_DOWN, pos, size);
			item:setTag(1);
		end

		if crystal > 0 then
			pos = cc.p(FULL_WIDTH/4*3, hfix(28));
			item = add_item_1(items, '水晶开卡槽', nil, 20, self.buy_slot, ANCHOR_CENTER_DOWN, pos, size);
			item:setTag(2);
		end

		util.add_menu(layer, items, 1);
	end,

	cb_gold_buy_slot = function(tag)
		tag = tag or 0;
		if 0 == tag then return; end
		local self = layer_deck;
		local gold = self.b_slot_gold;
		if gold > g_euser.gold then
			show_err(t_lang("TIP_NOT_ENOUGH_GOLD"));
			return;
		end
		net_send('bslot 1 ' .. (#(self.list_pick_deck or {}) + 1));
	end,

	cb_crystal_buy_slot = function(tag)
		tag = tag or 0;
		if 0 == tag then return; end
		local self = layer_deck;
		local crystal = self.b_slot_crystal;
		if crystal > g_euser.crystal then
			show_err(t_lang("TIP_NOT_ENOUGH_CRYSTAL"));
			return;
		end
		net_send('bslot 2 ' .. (#(self.list_pick_deck or {}) + 1));
	end,

	buy_slot = function(...)
		local self = layer_deck;
		local sid = self.b_slot_id;
		local gold = self.b_slot_gold;
		local crystal = self.b_slot_crystal;
		local args = {...};
		-- 1 is gold, 2 is crystal
		local flag = args[2]:getTag();
		local money, cb;
		if 1 == flag then -- gold
			money = '金币(' .. gold .. ')';
			cb = self.cb_gold_buy_slot;
		elseif 2 == flag then -- crystal
			money = '水晶(' .. crystal .. ')';
			cb = self.cb_crystal_buy_slot;
		else
			return;
		end
		local tip = string.format("确定要用%s购买第%d个卡槽吗？", money, sid);
		g_scene:add_layer(ZORDER_LAYER_TIP,layer_tip:create(tip, cb));
	end,

	get_deck_str = function(self)
		local mod = string.rep('0', CARD_ARRAY_LIST);
		local len = string.len(mod);
		local list = self.list_deck;
		for i = 1, #list do
			local v = list[i];
			local id = v.card.id;
			local count = '' .. v.count;
			assert(string.len(count) == 1, 'ERROR saveslot count[' .. count .. '] id[' .. id .. ']');
			local t1 = string.sub(mod, 1, id - 1);
			local t2 = string.sub(mod, id + 1, len);
			mod = t1 .. count .. t2;
		end
		return mod;
	end,

	save_to_slot = function(self, sid, sname)
		local mod = self:get_deck_str();
		local cmd = string.format("sdeck %d %s", sid, mod);
		net_send(cmd);
	end,

	callback_save_slot = function(tag)
		tag = tag or 0;
		local self = layer_deck;
		if 1 == tag then
			self:save_to_slot(self.deck_sid, self.deck_name);
		end
	end,

	change_to_slot = function(self, list, sid, name)
		self.deck_sid = sid;
		self.deck_name = name;
		self.label_deck_pick:setString(name);
		self.eb_name:setText(name);
		if nil == list then
			-- set title info for selected slot
			return;
		end
		if 0 == #(list or {}) then 
			self.has_modify = true;
			return; 
		end
		self.list_hero = {};
		self.list_deck = {};
		self.list_slot = {};
		self.list_slot_total = {};

		self:set_deck_cards(list, 1, true);

		local deck_str = self:get_deck_str();
		local slot_str = c_get_slot_str(deck_str, g_euser.all_str);
		local slot_array = c_str_array(slot_str);	
		slot_array = self:add_hero_cards(slot_array, true);
		self:init_list_slot(slot_array, 1);
		self.has_modify = true;
	end,
	
	callback_pick_deck = function(index)
		local self = layer_deck;
		net_send('lslot ' .. index);
	end,

	pick_deck = function()
		local self = layer_deck;
		net_send('slotlist');
	end,

	pick_deck_check = function()
		local self = layer_deck;
		if nil == self.deck_sid or -1 == self.deck_sid then
			self.pick_deck();
			return;
		end
		self.label_deck_pick:setVisible(false);
		self.eb_name:setVisible(true);
		self.eb_name:sendActionsForControlEvents(CCControlEventTouchUpInside);
	end,

	set_eb_name = function(self, name)
		self.eb_name:setText(name);
	end,

	editbox_handler = function(eventname, psender)
		local self = layer_deck;
		local edit = tolua.cast(psender, "cc.EditBox");
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
			local str = edit:getText();
			str = util.space_(str);
			if 0 == string.len(str) then
				str = self.deck_name;
			end
			edit:setText(str);
			edit:setVisible(false);
			self.label_deck_pick:setString(str);
			self.label_deck_pick:setVisible(true);
			if str == self.deck_name then return; end
			self.deck_name = str;
			net_send('rslot ' .. self.deck_sid .. ' ' .. str);
		elseif eventname == "changed" then
		end
	end,

	get_offset_in_slot_list = function(self, card_id)
		local index = 1;
		for i = 1, #self.list_slot do
			local cid = self.list_slot[i].card.id;
			if cid == card_id then
				break;
			elseif cid < card_id then
				index = i+1;
			end
		end
		if index > #self.list_slot then
			return -1;
		end
		return index;
	end,

	syn_slot_list = function(self, new_index)
		new_index = (new_index or self.in_slot_pick) or 1;
		local nlist = {};
		local list = self.list_slot_total;
		local info = self.list_pick_slot[new_index];
		local tag = info.tag;
		if 1 == tag then -- all card fit this hero
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(self.hero_id, card.id);
				if true == is_fit then
					table.insert(nlist, list[i]);
				end
			end
		elseif 2 == tag then -- attach
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(self.hero_id, card.id);
				if true == is_fit and ATTACH == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 3 == tag then -- ability
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(self.hero_id, card.id);
				if true == is_fit and ABILITY == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 4 == tag then -- ally
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(self.hero_id, card.id);
				if true == is_fit and ALLY == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 5 == tag then -- weapon
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(self.hero_id, card.id);
				if true == is_fit and WEAPON == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 6 == tag then -- armor
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(self.hero_id, card.id);
				if true == is_fit and ARMOR == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 7 == tag then -- support
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(self.hero_id, card.id);
				if true==is_fit and (SUPPORT==card.ctype or TRAP==card.ctype or ARTIFACT == card.ctype) then
					table.insert(nlist, list[i]);
				end
			end
		elseif 8 == tag then -- total card
			for i = 1, #list do
				table.insert(nlist, list[i]);
			end
		end
		self.list_slot = nlist;
		return self.list_slot;
	end,

	set_slot_name = function(self, new_index)
		return;
	end,

	change_slot = function(self, new_index)
		local titles = self.list_pick_slot or {};
		if 0 == #titles then return; end

		local info = titles[new_index];
		if nil == info then return; end
		self.in_slot_pick = new_index
		local name = info.title;
		self.label_slot_pick:setString(name);

		local list = self.list_slot_total or {};
		--if 0 == #list then return; end

		self:syn_slot_list(new_index);
		self:update_total();
		self.tableview_slot:reloadData();
	end,

	callback_pick_slot = function(index)
		local self = layer_deck;
		self:change_slot(index);
	end,

	pick_slot = function()
		local self = layer_deck;
		local list = self.list_pick_slot or {};
		local cb = self.callback_pick_slot;
		g_scene:add_layer(ZORDER_LAYER_PICK, layer_pick:create(list, cb));
	end,

	set_deck_total = function(self, msg)
		if nil == self.layer or nil == msg then
			return;
		end
		msg = '(' .. msg .. ')';
		self.total_deck_label:setString(msg);
	end,

	set_slot_total = function(self, msg)
		if nil == self.layer or nil == msg then
			return;
		end
		msg = '(' .. msg .. ')';
		self.total_slot_label:setString(msg);
	end,

	callback_return = function(tag)
		tag = tag or 0;
		local self = layer_deck;
		if 1 == tag then
			self.callback_save();
			return;
		end
		g_scene:map();
	end,

	callback_ask_return = function()
		play_tap_1();
		if nil ~= layer_book.layer then
			layer_book:remove();
			return;
		end
		local self = layer_deck;
		if true ~= self.has_modify then
			self.callback_return(0);
			return;
		end
		self.is_should_quit = true;
		local str = "是否保存？";
		g_scene:add_layer(ZORDER_LAYER_TIP, layer_tip:create(str, self.callback_return));
	end,

	callback_save = function()
		play_tap_2();
		local self = layer_deck;
		local mod = string.rep('0', CARD_ARRAY_LIST);
		local len = string.len(mod);
		local list = self.list_deck;
		for i = 1, #list do
			local v = list[i];
			local id = v.card.id;
			local count = '' .. v.count;
			assert(string.len(count) == 1, 'ERROR savedeck count[' .. count .. '] id[' .. id .. ']');
			local t1 = string.sub(mod, 1, id - 1);
			local t2 = string.sub(mod, id + 1, len);
			mod = t1 .. count .. t2;
		end
		local sid = self.deck_sid or 0;
		local cmd = 'sdeck ' .. sid .. ' ' .. mod;
		net_send(cmd);
	end,

	callback_clear = function()
		play_tap_2();
		local self = layer_deck;
		self:reset_for_pick_hero(self.hero_id);
	end,

	callback_hero = function()
		play_tap_2();
		local self = layer_deck;
		g_scene:add_layer(ZORDER_LAYER_CHERO, layer_chero:create());
		layer_chero:add_to_list(self.list_hero);
	end,

	reset_for_pick_hero = function(self, hero_id)
		--print('DEBUG reset_for_pick_hero: ', hero_id);
		local chero = hero_list[hero_id];
		if nil == chero then
			self.callback_return();
			return;
		end
		chero = clone(chero);
		local count = 1;
		local l = { card = chero, count = count };
		self.list_hero = {};
		self.list_deck = {};
		self.list_slot = {};
		self.list_slot_total = {};
		local deck_array = {};
		table.insert(deck_array, l);
		local slot_array = c_str_array(g_euser.all_str);
		slot_array = self:add_hero_cards(slot_array, true);
		self:init_list_deck(deck_array, 1);
		self:init_list_slot(slot_array, 1);
		self.has_modify = true;
	end,

	tableview_deck_handler = function(...)  -- { start
		local self = layer_deck;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list_deck or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_arrows(self.clarrow_deck, self.crarrow_deck, #self.list_deck, self.cwidth_deck, self.twidth_deck, view:getContentOffset());
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			local info = self.list_deck[idx + 1];
			g_scene:add_layer(ZORDER_LAYER_DECKPOP, layer_deckpop:create(info,'deck'));
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight_deck, self.cwidth_deck;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth_deck;
			local height = self.cheight_deck;
			local info = self.list_deck[idx+1];
			local card = clone(info.card);
			local count = info.count;
			local pos = cc.p(width / 2, height / 2);
			local cinfo = object_card:new(cell, card, nil, nil, pos, 0, self.cscale, STYPE_VER_1);
			local sprite = cinfo:get_front();
			sprite:setTag(TAG_CELL_CARD_SPRITE);
			local path = util.get_path('font_deck_num.fnt');
			pos.x = pos.x + width / 4;
			count = '*' .. count;
			util.add_labelbmf(cell, count, path, pos, ANCHOR_CENTER_CENTER, 100);
			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			-- highlight means touch began
			local info = self.list_deck[idx+1];
			self.touch_card = {};	
			self.touch_card.table_type = 'deck';
			self.touch_card.card = info.card;
			self.touch_card.count = info.count;
			local sprite = cell:getChildByTag(TAG_CELL_CARD_SPRITE);
			self.touch_card.sprite = sprite;
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	tableview_slot_handler = function(...)  -- { start
		local self = layer_deck;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list_slot or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_arrows(self.clarrow_slot, self.crarrow_slot, #self.list_slot, self.cwidth_slot, self.twidth_slot, view:getContentOffset());
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			local info = self.list_slot[idx + 1];
			g_scene:add_layer(ZORDER_LAYER_DECKPOP, layer_deckpop:create(info,'slot'));
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight_slot, self.cwidth_slot;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth_slot;
			local height = self.cheight_slot;
			local info = self.list_slot[idx+1];
			local card = clone(info.card);
			local count = info.count;
			local pos = cc.p(width / 2, height / 2);
			local cinfo = object_card:new(cell, card, nil, nil, pos, 0, self.cscale, STYPE_VER_1);
			local sprite = cinfo:get_front();
			sprite:setTag(TAG_CELL_CARD_SPRITE);
			local path = util.get_path('font_deck_num.fnt');
			pos.x = pos.x + width / 4;
			count = '*' .. count;
			util.add_labelbmf(cell, count, path, pos, ANCHOR_CENTER_CENTER, 100);
			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			-- highlight means touch began
			local info = self.list_slot[idx+1];
			self.touch_card = {};	
			self.touch_card.table_type = 'slot';
			self.touch_card.card = info.card;
			self.touch_card.count = info.count;
			local sprite = cell:getChildByTag(TAG_CELL_CARD_SPRITE);
			self.touch_card.sprite = sprite;
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	update_total = function(self) 
		local total = 0;
		for k, v in ipairs(self.list_deck or {}) do
			total = total + v.count;
		end
		self:set_deck_total(total);

		total = 0;
		for k, v in ipairs(self.list_slot or {}) do
			total = total + v.count;
		end
		self:set_slot_total(total);
	end,

	add_hero_cards = function(self, list, is_remove)
		list = list or {};
		local lhero = self.list_hero or {};
		local lremove = {};
		for i = 1, #list do
			local card = list[i].card;
			local count = list[i].count;
			local ctype = card.ctype;
			if ctype == HERO then
				--print('hero name: ', card.name, card.id);
				local c = clone(card);
				local l = { card = c, count = count };
				table.insert(lhero, l);
				if true == is_remove then
					table.insert(lremove, i);
				end
			end
		end
		for i = #lremove, 1, -1 do
			local index = lremove[i];
			table.remove(list, index);
		end
		self.list_hero = lhero;
		return list;
	end,

	init_list_deck = function(self, list, index)
		for i = 1, #list do
			local cid = list[i].card.id;
			local c = hero_list[i];
			if nil ~= c then
				self.hero_id = cid;
				break;
			end
		end
		self.list_deck = list;
		self:update_total();
		self.tableview_deck:reloadData();
	end,

	init_list_slot = function(self, list, index)
		self.list_slot_total = list;
		self:change_slot(1);
		--[[
		self.list_slot = list;
		self:update_total();
		self.tableview_slot:reloadData();
		]]--
	end,

	-- just call it once at begin
	set_deck_cards = function(self, list, index, not_do_lcard)
		if nil == self.layer then
			return;
		end
		-- just call it once at begin
		list = self:add_hero_cards(list);
		self:init_list_deck(list, index);
		
		if true == not_do_lcard then
			return;
		end
		local cmd = 'lcard ' .. CARD_ARRAY_LIST;
		net_send(cmd);
	end,

	-- first set deck card
	-- then load slot card(lcard), then set slot cards
	set_slot_cards = function(self, list, index)
		if nil == self.layer then
			return;
		end
		-- just call it once at begin
		list = self:add_hero_cards(list, true);
		self:init_list_slot(list, index);
	end,

	move_card = function(self, from_type, to_type, card, count)
		kdebug("from[%s] to[%s] card[%d]", from_type, to_type, card.id);
		local list_from, list_to, tableview_from, tableview_to, cwidth_to;
		if 'deck' == from_type and 'slot' == to_type then
			list_from = self.list_deck;
			--list_to = self.list_slot;
			list_to = self.list_slot_total;
			tableview_from = self.tableview_deck;
			tableview_to = self.tableview_slot;
			cwidth_to = self.cwidth_slot;
		elseif 'slot' == from_type and 'deck' == to_type then
			--list_from = self.list_slot;
			list_from = self.list_slot_total;
			list_to = self.list_deck;
			tableview_from = self.tableview_slot;
			tableview_to = self.tableview_deck;
			cwidth_to = self.cwidth_deck;
		else
			return false;
		end
		local card_id = card.id;
		if 'deck' == to_type then
			for i = 1, #list_to do
				local cid = list_to[i].card.id;
				if cid == card_id then
					local c = list_to[i].count;
					if c > 3 then
						show_msg(t_lang("TIP_DECK_MORE_THAN_FOUR"));
						return false;
					end
				end
			end
		end
		for i = 1, #list_from do
			local cid = list_from[i].card.id;
			if cid == card_id then
				local c = list_from[i].count;
				c = c - count;
				list_from[i].count = c;
				if c <= 0 then
					table.remove(list_from, i);
				end
				break;
			end
		end
		local flag = false;
		local index = 1;
		for i = 1, #list_to do
			local cid = list_to[i].card.id;
			if cid == card_id then
				local c = list_to[i].count;
				c = c + count;
				list_to[i].count = c;
				flag = true;
				break;
			elseif cid < card_id then
				index = i+1;
			end
		end
		if false == flag then
			table.insert(list_to, index, { card = clone(card), count = count });
		end
		-- syn list_slot by list_slot_total
		self:syn_slot_list(new_index);
		--
		local offset;
		offset = tableview_from:getContentOffset();
		tableview_from:reloadData();
		tableview_from:setContentOffset(offset, false);
		offset = tableview_to:getContentOffset();
		if 'slot' == to_type then
			index = self:get_offset_in_slot_list(card_id);
		end
		if -1 ~= index then -- -1 means the card donot fit the current slot list
			offset.x = - (index - 1) * cwidth_to;
		end
		tableview_to:reloadData();
		tableview_to:setContentOffset(offset, true);
		self.has_modify = true;
		self:update_total();
		return true;
	end,

	go_change_hero = function(self)
		g_scene:add_layer(ZORDER_LAYER_CHERO, layer_chero:create());
		layer_chero:add_to_list(self.list_hero);
	end,

	handler = function(event, x, y)
		local self = layer_deck;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
			util.free_ram();
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.callback_ask_return();
		end
	end,

	onTouchBegan = function (self, x, y)
		if true == self.is_touching then
			return;
		end
		self.is_touching = true;
		self.touch_point = { x = x, y = y, sprite = nil };
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		if nil == self.touch_card then
			return;
		end
		local tx = self.touch_point.x;
		local ty = self.touch_point.y;
		if math.abs(y-ty) < hfix(60) then
			return;
		end
		local info = self.touch_card;
		local sprite = info.sprite;
		if nil == sprite then
			return;
		end
		local s = self.touch_point.sprite;
		if nil == s then
			local count = info.count;
			local card = clone(info.card);
			local pos = cc.p(tx, ty);
			local scale = sprite:getScale();
			local cinfo = object_card:new(self.layer, card, nil, nil, pos, 0, self.cscale, STYPE_VER_1);
			s = cinfo:get_front();
			self.layer:reorderChild(s, ZORDER_CARD + 100);
			self.touch_point.sprite = s;
			if 1 == count then
				sprite:setVisible(false);
			end
		end
		s:setPosition(x, y);
	end,
	
	onTouchEnded = function(self, x, y)
		self.is_touching = false;
		--kdebug("layer_deck touch_end");
		local touch_point = self.touch_point;
		local touch_card = self.touch_card;
		self.touch_card = nil;	
		self.touch_point = nil;
		local s = touch_point.sprite;
		if nil == s then
			return;
		end
		--s:setPosition(tx, ty);
		s:removeFromParentAndCleanup(true);
		local tx = touch_point.x;
		local ty = touch_point.y;
		local from_type = touch_card.table_type;
		local card = touch_card.card;
		local is_fit = fit_hero_id(self.hero_id, card.id);
		local ret = false;
		if 'slot' == from_type and false == is_fit then
			show_msg(t_lang("TIP_DECK_NOT_FIT_HERO"));
		elseif 'deck' == from_type and y < self.line_slot then
			if card.ctype == HERO then
				self:go_change_hero();
			else
				ret = self:move_card(from_type, 'slot', card, 1);
			end
		elseif 'slot' == from_type and y > self.line_deck then
			ret = self:move_card(from_type, 'deck', card, 1);
		end
		if false == ret then
			if 1 == touch_card.count then
				local sprite = touch_card.sprite;
				sprite:setVisible(true);
			end
		end
	end,
} -- layer_deck end 

-- choose hero is deck
layer_chero = { -- start    
	name = 'layer_chero',
	mark_index = nil, --will set in touch_end,remove in return,use in add_to_list
	layer = nil,
	list = nil,
	touch_x = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.touch_x = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_CHERO, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 158));

		local bgsize = cc.size(FULL_WIDTH-wfix(30), FULL_HEIGHT-hfix(140));
		init_bg_for_popview(self.layer, '选择英雄', bgsize, self.callback_return);

		local items = {};
		local item;

		item = gui_add_item(items,'arrow_left',GUI_ROLE,self.callback_left,ANCHOR_DOWN);
		item:setPositionY(HALF_HEIGHT);

		item = gui_add_item(items, 'arrow_right', GUI_ROLE, self.callback_right, ANCHOR_DOWN);
		item:setPositionY(HALF_HEIGHT);

		local pos = cc.p(HALF_WIDTH, hfix(100));
		local size = cc.size(172, 52);
		add_item_1(items, '选择', nil, 25, self.callback_select, ANCHOR_CENTER_DOWN, pos, size);

		util.add_menu(self.layer, items, 30);

		return self.layer, self.name;

	end,

	callback_return = function()
		play_tap_1();
		local self = layer_chero;
		self.mark_index = nil;
		self:remove();
	end,

	callback_left = function()
		play_tap_1();
		local self = layer_chero;
		local index = self.hindex;
		if index == 1 then
			return;
		end
		self.hindex = index - 1;
		self:refresh_heros(self.hindex);
	end,

	callback_right = function()
		play_tap_1();
		local self = layer_chero;
		local index = self.hindex;
		if index == #(self.list or {}) then
			return;
		end
		self.hindex = index + 1;
		self:refresh_heros(self.hindex);
	end,

	callback_select = function()
		play_tap_1();
		local self = layer_chero;
		if 0 == #self.list then
			return;
		end
		local index = self.hindex;
		local info = self.list[index];
		local card = info.card;
		--print('index: ', index, card.id, card.name);
		self:remove();
		layer_deck:reset_for_pick_hero(card.id);
	end,

	refresh_heros = function(self, index)
		local scale_center = self.list.scale_center;
		local scale_side = self.list.scale_side;
		local lzorder = self.list.zorder;
		local lpos = ccp(self.list.x, self.list.y);
		local gapx = self.list.gapx;
		local gapy = self.list.gapy;
		for i = 1, #self.list do
			local info = self.list[i];
			local sprite = info.sprite;	
			sprite:stopAllActions();
			if math.abs(i-index) > 1 then
				sprite:setVisible(false);
			else
				sprite:setVisible(true);
			end
			local offset = i - index;
			local pos = ccp(lpos.x + gapx*offset, lpos.y + gapy*math.abs(offset));
			local zorder;
			if i ~= index then
				zorder = self.list.zorder_side;
			else
				zorder = self.list.zorder_center;
			end
			self.layer:reorderChild(sprite, zorder);
			
			local action;
			local array = {};
			action = cc.MoveTo:create(0.2, pos);
			table.insert(array, action);
			if i ~= index then
				action = cc.ScaleTo:create(0.2, scale_side);
				table.insert(array, action);
				action = cc.FadeTo:create(0.2, 200);
				table.insert(array, action);
			else
				action = cc.ScaleTo:create(0.2, scale_center);
				table.insert(array, action);
				action = cc.FadeTo:create(0.2, 255);
				table.insert(array, action);
			end
			sprite:runAction(cc.Spawn:create(array));
		end
	end,

	init_list = function(self)
		if 0 == #self.list then
			return;
		end
		local data = gui_get_data('area_center', GUI_ROLE, ANCHOR_DOWN);
		local data2 = gui_get_data('area_right', GUI_ROLE, ANCHOR_DOWN);
		local data3 = gui_get_data('area_center', GUI_ROLE, ANCHOR_UP);
		local data4 = gui_get_data('area_right', GUI_ROLE, ANCHOR_UP);
		local height_center = data3.y+data3.height-data.y;
		local height_side = data4.y+data4.height-data2.y;
		self.list.x = data.x+data.width/2;
		self.list.y = data.y+height_center/2;
		self.list.gapx = data2.x+data2.width/2-self.list.x;
		self.list.gapy = data2.y+height_side/2-self.list.y;
		self.list.y = HALF_HEIGHT; -- move card area to center of the screen
		local pos = cc.p(self.list.x, self.list.y);
		self.list.zorder_center = data.zorder;
		self.list.zorder_side = data2.zorder;
		self.hindex = 1;
		local index = 1;
		local card = nil;
		for i = 1, #self.list do
			local _card = self.list[i].card;
			if nil ~= _card then
				local offset = index - self.hindex;
				local cpos = ccp(pos.x+self.list.gapx*offset, pos.y+self.list.gapy*math.abs(offset));
				local info = object_card:new(self.layer, _card, nil, nil, cpos, 0, 1);
				local sprite = info:get_front();
				self.list[i].sprite = sprite;
				if math.abs(i-self.hindex) > 1 then
					sprite:setVisible(false);
				end
				local zorder;
				if index ~= self.hindex then
					zorder = self.list.zorder_side;
					if nil == self.list.scale_side then
						local w = data2.width/sprite:getContentSize().width;
						local h = height_side/sprite:getContentSize().height;
						local s = w;
						if h < w then
							s = h;
						end
						self.list.scale_side = s;
					end
					sprite:setScale(self.list.scale_side);
				else
					zorder = self.list.zorder_center;
					if nil == self.list.scale_center then
						local w = data.width/sprite:getContentSize().width;
						local h = height_center/sprite:getContentSize().height;
						local s = w;
						if h < w then
							s = h;
						end
						self.list.scale_center = hfix(s);
					end
					sprite:setScale(self.list.scale_center);
					card = _card;
				end
				self.layer:reorderChild(sprite, zorder);
				index = index + 1;
			end
		end
	end,

	clone_list = function(self, list)
		list = list or {};
		local nlist = {};
		for i = 1, #list do
			local card = list[i].card;
			local count = list[i].count;
			local c = clone(card);
			local l = { card = c, count = count };
			table.insert(nlist, l);
		end
		return nlist;
	end,

	add_to_list = function(self, list)
		self.list = self:clone_list(list);
		if nil ~= self.mark_index and self.mark_index > #list then
			self.mark_index = nil;
		end
		self:init_list();
	end,

	handler = function(event, x, y)
		local self = layer_chero;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function (self, x, y)
		self.touch_x = x;
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
	end,
	
	onTouchEnded = function(self, x, y)
		if nil == self.touch_x then
			return;
		end
		local ox = self.touch_x;
		self.touch_x = nil;
		local offset = x - ox;
		local gap = wfix(30);
		if offset > gap then
			self.callback_left();
		elseif offset < -gap then
			self.callback_right();
		end
	end,

} -- layer_chero end

layer_deckpop = { -- start
	name = 'layer_deckpop',
	layer = nil, 
	info = nil,

	cleanup = function(self)
		self.layer = nil;
		self.info = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, info, table_type)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_DECKPOP, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));

		self.info = info;
		local card = clone(self.info.card);
		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT - hfix(50));
		local cwidth = FULL_WIDTH - wfix(70);
		local cheight = FULL_HEIGHT - hfix(340);
		local scale = get_card_scale(cwidth, cheight, CARD_SIZE);
		local cinfo = object_card:new(self.layer, card, nil, nil, pos, 0, scale, STYPE_VER_1);
		local sprite = cinfo:get_front();

		pos.y = HALF_HEIGHT;
		local farray = {};
		local action;
		table.insert(farray, cc.CallFunc:create(disable_touch));
		action = cc.EaseIn:create(cc.MoveTo:create(0.2, pos), 0.2);
		table.insert(farray, action);
		table.insert(farray, cc.CallFunc:create(enable_touch));

		action = cc.Sequence:create(farray);
		sprite:runAction( cc.Sequence:create(farray));

		local cb, item, name;
		if card.ctype == HERO then
			cb = self.to_hero;
			name = '切换英雄';
		elseif 'deck' == table_type then
			cb = self.to_slot;
			name = '移出牌堆';
		else --if 'slot' == table_type then
			cb = self.to_deck;
			name = '移到牌堆';
		end
		local items = {};
		pos = cc.p(HALF_WIDTH, hfix(100));
		local size = cc.size(172, 52);
		add_item_1(items, name, nil, 28, cb, ANCHOR_CENTER_DOWN, pos, size);

		util.add_menu(self.layer, items, 1);
		
		return self.layer, self.name;
	end, 

	to_hero = function()
		play_tap_1();
		local self = layer_deckpop;
		self:remove();
		layer_deck:go_change_hero();
	end,

	to_deck = function()
		play_tap_1();
		local self = layer_deckpop;
		local info = self.info;
		layer_deck:move_card('slot', 'deck', info.card, 1);
		self:remove();
	end,

	to_slot = function()
		play_tap_1();
		local self = layer_deckpop;
		local info = self.info;
		layer_deck:move_card('deck', 'slot', info.card, 1);
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_deckpop;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)
		self:remove();
	end,

} -- layer_deckpop end

layer_register = { -- start
	name = 'layer_register',
	layer = nil,
	username = '';
	password = '';
	password2 = '';

	cleanup = function(self)
		self.layer = nil;
		self.username = '';
		self.password = '';
		self.password2 = '';
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_REGISTER, self.handler, true);

		local data, pos, sprite, size;
		--sprite,data = gui_add_sprite(self.layer, 'board', GUI_LOGIN);
		sprite,data = gui_add_sprite(self.layer, 'bg', GUI_LOGIN);
		if data.width/data.rwidth > data.height/data.rheight then
			sprite:setScale(data.width/data.rwidth);
		else
			sprite:setScale(data.height/data.rheight);
		end
		--sprite, data = gui_add_sprite(self.layer,'wolf',GUI_LOGIN,ANCHOR_DOWN);
		--self:wolf_effect(data, sprite);
		sprite, data = gui_add_sprite(self.layer, 'fire', GUI_LOGIN, ANCHOR_DOWN);
		sprite, data = gui_add_sprite(self.layer, 'logo', GUI_LOGIN, ANCHOR_UP);
		sprite, data = gui_add_sprite(self.layer, 'frame', GUI_LOGIN, ANCHOR_UP);
		gui_add_stroke(self.layer,'注册',30,'title',GUI_LOGIN, ANCHOR_UP);

		str = t_lang("USERNAME");
		gui_add_stroke(self.layer,str,30,'t_uname',GUI_LOGIN, ANCHOR_UP);
		gui_add_sprite(self.layer, 'bg_uname', GUI_LOGIN, ANCHOR_UP);
		sprite, data = gui_add_sprite(self.layer,'bg2_uname',GUI_LOGIN,ANCHOR_UP);

		str = t_lang("PASSWORD");
		gui_add_stroke(self.layer,str,30,'t_pw',GUI_LOGIN, ANCHOR_UP);
		gui_add_sprite(self.layer, 'bg_pw', GUI_LOGIN, ANCHOR_UP);
		sprite, data = gui_add_sprite(self.layer, 'bg2_pw', GUI_LOGIN, ANCHOR_UP);

		str = t_lang("PASSWORD");
		gui_add_stroke(self.layer,str,20,'t_pw2',GUI_LOGIN, ANCHOR_UP);
		gui_add_sprite(self.layer, 'reg_bg_pw2', GUI_LOGIN, ANCHOR_UP);
		gui_add_sprite(self.layer, 'reg_bg2_pw2', GUI_LOGIN, ANCHOR_UP);

		local color;
		data = gui_get_data('uname', GUI_LOGIN, ANCHOR_UP);
		color = cc.c3b(data.r, data.g, data.b);
		-- editbox username
		pos = ccp(data.x, data.y);
		size = cc.size(data.width, data.height);
		self.username = util.add_editbox_blank(self.layer, size, 
			ANCHOR_LEFT_DOWN, pos, util.f_default, 22, color, 
			cc.EDITBOX_INPUT_MODE_SINGLELINE, cc.KEYBOARD_RETURNTYPE_DONE, 
			nil, self.editbox_handler, 30, t_lang("REG_TIP_REGNAME"),util.c_gray, 
			data.zorder);

		data = gui_get_data('pw', GUI_LOGIN, ANCHOR_UP);
		color = cc.c3b(data.r, data.g, data.b);
		pos = ccp(data.x, data.y);
		size = cc.size(data.width, data.height);
		self.password = util.add_editbox_blank(self.layer, size, ANCHOR_LEFT_DOWN,
			pos, util.f_default, 22,color,cc.EDITBOX_INPUT_MODE_SINGLELINE,
			cc.KEYBOARD_RETURNTYPE_DONE, cc.EDITBOX_INPUT_FLAG_PASSWORD, 
			self.editbox_handler,30,t_lang("REG_TIP_PW"),util.c_gray,data.zorder);

		data = gui_get_data('pw2', GUI_LOGIN, ANCHOR_UP);
		color = cc.c3b(data.r, data.g, data.b);
		pos = ccp(data.x, data.y);
		size = cc.size(data.width, data.height);
		self.password2 = util.add_editbox_blank(self.layer, size,ANCHOR_LEFT_DOWN,
			pos, util.f_default, 22,color,cc.EDITBOX_INPUT_MODE_SINGLELINE,
			cc.KEYBOARD_RETURNTYPE_DONE, cc.EDITBOX_INPUT_FLAG_PASSWORD, 
			self.editbox_handler,30,t_lang("REG_TIP_PW2"),util.c_gray,
			data.zorder);

		local items = {};
		local item;

		item,data = gui_add_item(items,'btn_back',GUI_LOGIN,self.close,ANCHOR_UP);
		gui_add_text_on_sprite(item, "返回", 't_back', GUI_LOGIN, ANCHOR_UP, 30);
		
		item, data = gui_add_item(items, 'btn_reg', GUI_LOGIN, self.callback_register, ANCHOR_UP);
		gui_add_text_on_sprite(item, "注册", 't_btn_reg', GUI_LOGIN, ANCHOR_UP, 30);

		util.add_menu(self.layer, items, data.zorder);

		return self.layer, self.name;

	end,

	wolf_effect = function(self, data, sprite)
		local action, array;
		array = {};
		action = CCMoveBy:create(5, ccp(0, -hfix(13)));
		table.insert(array, action);
		action = action:reverse();
		table.insert(array, action);
		action = CCSequence:create(array);
		action = CCRepeatForever:create(action);
		sprite:runAction(action);

		local fullpath = util.get_fullpath(F_PARTICLE, 'wolf_smoke.plist');
		util.add_particle(self.layer, fullpath, ccp(HALF_WIDTH, hfix(60)), data.zorder+2);
	end,

	editbox_handler = function(eventname, psender)
		local edit = tolua.cast(psender, "cc.EditBox");
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
		elseif eventname == "changed" then
		end

	end,

	close = function()
		play_tap_1();
		local self = layer_register;
		self:remove();
	end,

	callback_register = function()
		play_tap_1();
		local self = layer_register;
		--print('DEBUG callback_register');
		-- self.toggle_info:getSelectedIndex()  0 : off     1 : on
		local username = self.username:getText();
		local password = self.password:getText();
		local password2 = self.password2:getText();
		if nil == username or '' == string.gsub(username, "^%s*(.-)%s*$", "%1") then
			show_msg('ERROR 用户名格式不符');
			return;
		end
		if nil == password or '' == string.gsub(password, "^%s*(.-)%s*$", "%1") then
			show_msg('ERROR 密码格式不符');
			return;
		end
		if password ~= password2 then
			show_msg('ERROR 密码不一致');
			return;
		end
		local ret;
		ret = g_scene:connect_to_net();
		if ret <= 0 then
			return;
		end
		g_euser.username = username;
		util.save_rms('username', username, 'string');
		util.save_rms('password', password, 'string');
		net_cmd_reg(username, password);
	end,
	
	handler = function(event, x, y)
		local self = layer_register;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function (self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)

	end,

} -- layer_register end

layer_role = { -- start
	name = 'layer_role',
	layer = nil,
	list_toggle = nil,
	sex = SEX_MALE,
	list = nil,
	hindex = 0,
	alias = nil,
	validate_alias = false,
	touch_x = nil,
	list_alias = nil,
	arrow_left = nil,
	arrow_right = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list_toggle = nil;
		self.sex = SEX_MALE;
		self.list = nil;
		self.hindex = 0;
		self.alias = nil;
		self.validate_alias = false;
		self.touch_x = nil;
		self.list_alias = nil;
		self.arrow_left = nil;
		self.arrow_right = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_ROLE, self.handler, true);

		self.list_toggle = {};
		self.list_hero = {};
		self.validate_alias = false;
		local sprite, data, str;
		sprite,data = gui_add_sprite(self.layer, 'board', GUI_ROLE);
		sprite,data = gui_add_sprite(self.layer, 'bg', GUI_ROLE);
		if data.width/data.rwidth > data.height/data.rheight then
			sprite:setScale(data.width/data.rwidth);
		else
			sprite:setScale(data.height/data.rheight);
		end
		sprite,data = gui_add_sprite(self.layer, 'bg_title', GUI_ROLE, ANCHOR_UP);
		add_title_1(sprite, data, t_lang("ROL_TITLE"));

		gui_add_stroke(self.layer,'名称',30,'t_name',GUI_ROLE, ANCHOR_DOWN);
		gui_add_sprite(self.layer,'bg_info',GUI_ROLE,ANCHOR_DOWN);
		gui_add_sprite(self.layer,'bg_name',GUI_ROLE,ANCHOR_DOWN);
		gui_add_sprite(self.layer,'bg_name2',GUI_ROLE,ANCHOR_DOWN);
		str = '支持1~8个字符';
		gui_add_label(self.layer, str, 25, 'tip_name', GUI_ROLE, ANCHOR_DOWN);
		str = g_euser.alias or ( '_' .. g_euser.username );
		local first = string.sub(str, 1, 1);
		if '_' == first and 1 < string.len(str) then
			str = string.sub(str, 2);
		end
		local color;
		data = gui_get_data('name', GUI_ROLE, ANCHOR_DOWN);
		color = cc.c3b(data.r, data.g, data.b);
		pos = ccp(data.x, data.y);
		size = cc.size(data.width, data.height);
		self.alias = util.add_editbox_blank(self.layer, size, 
			ANCHOR_LEFT_DOWN, pos, util.f_default, 22, color, 
			cc.EDITBOX_INPUT_MODE_SINGLELINE, cc.KEYBOARD_RETURNTYPE_DONE, 
			nil, self.editbox_handler, 30, t_lang("LOG_TIP_UNAME"), util.c_gray, 
			data.zorder);
		if true ~= self.callback_dice() then
			self.alias:setText(str);
		end

		gui_add_stroke(self.layer,'性别',30,'t_sex',GUI_ROLE, ANCHOR_DOWN);
		gui_add_stroke(self.layer,'男',30,'t_male',GUI_ROLE, ANCHOR_DOWN);
		gui_add_stroke(self.layer,'女',30,'t_female',GUI_ROLE, ANCHOR_DOWN);

		local items = {};
		local item;

		-- self.toggle_info:getSelectedIndex()  0 : off     1 : on
		item, data = gui_add_item(items, 'toggle_male', GUI_ROLE, self.cb_toggle, ANCHOR_DOWN);
		item:setTag(SEX_MALE);
		table.insert(self.list_toggle, item);
		item:setSelectedIndex(1);
		self.sex = SEX_MALE;

		item, data = gui_add_item(items, 'toggle_female', GUI_ROLE, self.cb_toggle, ANCHOR_DOWN);
		item:setTag(SEX_FEMALE);
		table.insert(self.list_toggle, item);

		self.arrow_left = gui_add_item(items,'arrow_left',GUI_ROLE,self.callback_left,ANCHOR_DOWN);

		self.arrow_right = gui_add_item(items, 'arrow_right', GUI_ROLE, self.callback_right, ANCHOR_DOWN);

		item, data = gui_add_item(items, 'dice', GUI_ROLE, self.callback_dice, ANCHOR_DOWN);

		item,data = gui_add_item(items,'btn_next',GUI_ROLE,self.callback_next,ANCHOR_DOWN);
		gui_add_text_on_sprite(item, "确认", 't_next', GUI_ROLE, ANCHOR_DOWN, 30);

		util.add_menu(self.layer, items, data.zorder);

		return self.layer, self.name;

	end,

	init_list = function(self, list)
		list = list or {};
		if #list < 2 then
			self.arrow_left:setVisible(false);
			self.arrow_right:setVisible(false);
		end
		self.list = {};
		if 0 == #list then
			return;
		end
		local data = gui_get_data('area_center', GUI_ROLE, ANCHOR_DOWN);
		local data2 = gui_get_data('area_right', GUI_ROLE, ANCHOR_DOWN);
		local data3 = gui_get_data('area_center', GUI_ROLE, ANCHOR_UP);
		local data4 = gui_get_data('area_right', GUI_ROLE, ANCHOR_UP);
		local height_center = data3.y+data3.height-data.y;
		local height_side = data4.y+data4.height-data2.y;
		self.list.x = data.x+data.width/2;
		self.list.y = data.y+height_center/2;
		local pos = cc.p(self.list.x, self.list.y);
		self.list.gapx = data2.x+data2.width/2-pos.x;
		self.list.gapy = data2.y+height_side/2-pos.y;
		self.list.zorder_center = data.zorder;
		self.list.zorder_side = data2.zorder;
		self.hindex = 1;
		local index = 1;
		local card = nil;
		for i = 1, #list do
			local ocard = hero_list[list[i]];
			if nil ~= ocard then
				local _card = clone(ocard);
				local offset = index - self.hindex;
				local cpos = ccp(pos.x+self.list.gapx*offset, pos.y+self.list.gapy*math.abs(offset));
				local info = object_card:new(self.layer, _card, nil, nil, cpos, 0, 1);
				local sprite = info:get_front();
				local l = { card = _card, sprite = sprite };
				table.insert(self.list, l);
				if math.abs(i-self.hindex) > 1 then
					sprite:setVisible(false);
				end
				local zorder;
				if index ~= self.hindex then
					zorder = self.list.zorder_side;
					if nil == self.list.scale_side then
						local w = data2.width/sprite:getContentSize().width;
						local h = height_side/sprite:getContentSize().height;
						local s = w;
						if h < w then
							s = h;
						end
						self.list.scale_side = s;
					end
					sprite:setScale(self.list.scale_side);
				else
					zorder = self.list.zorder_center;
					if nil == self.list.scale_center then
						local w = data.width/sprite:getContentSize().width;
						local h = height_center/sprite:getContentSize().height;
						local s = w;
						if h < w then
							s = h;
						end
						self.list.scale_center = hfix(s);
					end
					sprite:setScale(self.list.scale_center);
					card = _card;
				end
				self.layer:reorderChild(sprite, zorder);
				index = index + 1;
			end
		end
	end,

	refresh_heros = function(self, index)
		local scale_center = self.list.scale_center;
		local scale_side = self.list.scale_side;
		local lzorder = self.list.zorder;
		local lpos = ccp(self.list.x, self.list.y);
		local gapx = self.list.gapx;
		local gapy = self.list.gapy;
		for i = 1, #self.list do
			local info = self.list[i];
			local sprite = info.sprite;	
			sprite:stopAllActions();
			if math.abs(i-index) > 1 then
				sprite:setVisible(false);
			else
				sprite:setVisible(true);
			end
			local offset = i - index;
			local pos = ccp(lpos.x + gapx*offset, lpos.y + gapy*math.abs(offset));
			local zorder;
			if i ~= index then
				zorder = self.list.zorder_side;
			else
				zorder = self.list.zorder_center;
			end
			self.layer:reorderChild(sprite, zorder);
			
			local action;
			local array = {};
			action = cc.MoveTo:create(0.2, pos);
			table.insert(array, action);
			if i ~= index then
				action = cc.ScaleTo:create(0.2, scale_side);
				table.insert(array, action);
				action = cc.FadeTo:create(0.2, 200);
				table.insert(array, action);
			else
				action = cc.ScaleTo:create(0.2, scale_center);
				table.insert(array, action);
				action = cc.FadeTo:create(0.2, 255);
				table.insert(array, action);
			end
			sprite:runAction(cc.Spawn:create(array));
		end
	end,

	cb_toggle = function(tag, sender)
		play_tap_3();
		local self = layer_role;
		sender = tolua.cast(sender, "cc.MenuItemToggle");
		--print('selected item:tag:%d, index:%d', tag, sender:getSelectedIndex());
		self.sex = tag;
		for i = 1, #self.list_toggle do
			local toggle = self.list_toggle[i];
			local tag = toggle:getTag();
			if tag ~= self.sex then
				toggle:setSelectedIndex(0);
			else
				toggle:setSelectedIndex(1);
			end
		end
	end,

	is_legal = function(self, str)
		-- trim white space
		if 0 == string.len(str) then
			show_msg('名称不能空');
			return false;
		end

		local sp, ep;

		sp, ep = string.find(str, ' ');
		if nil ~= sp then 
			show_msg('名称不能含有 空格 ');
			return false;
		end

		sp, ep = string.find(str, '@');
		if nil ~= sp then 
			show_msg('名称不能含有 @ ');
			return false; 
		end

		return true;
	end,

	editbox_handler = function(eventname, psender)
		local self = layer_role;
		local edit = tolua.cast(psender, "cc.EditBox");
		--local str;
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
			local str = edit:getText();
			if true ~= self:is_legal(str) then
				edit:setText('');
			end
		elseif eventname == "changed" then
			local str = edit:getText();
			local len = string.len(str);
			if len > 0 then
				local char = string.sub(str, 1, 1);	
				if '_' == char then
					edit:setText(string.sub(str, 2, len));
				end
			end
		end

	end,

	callback_left = function()
		play_tap_2();
		local self = layer_role;
		local index = self.hindex;
		if index == 1 then
			return;
		end
		self.hindex = index - 1;
		self:refresh_heros(self.hindex);
	end,
	
	callback_right = function()
		play_tap_2();
		local self = layer_role;
		local index = self.hindex;
		if index == #(self.list or {}) then
			return;
		end
		self.hindex = index + 1;
		self:refresh_heros(self.hindex);
	end,

	get_new_alias = function(self, alias)
		self.alias:setText(alias);
	end,

	callback_dice = function()
		play_tap_2();
		local self = layer_role;
		--[[
		if nil == self.list_alias then
			math.randomseed(os.time());
			local lp, lb, lg = load_alias_data();
			self.list_alias = { lp = lp, lb = lb, lg = lg };
		end
		local lp, ln;
		lp = self.list_alias.lp;
		if self.sex == SEX_MALE then
			ln = self.list_alias.lb;
		else
			ln = self.list_alias.lg;
		end
		if 0 == #(lp or {}) and 0 == #(ln or {}) then return false; end
		local index1 = math.random(1, #lp);
		local index2 = math.random(1, #ln);
		local n1 = lp[index1] or '';
		local n2 = ln[index2] or '';
		local alias = n1 .. n2;
		self.alias:setText(alias);
		]]--
		net_send(string.format("ralias %d", self.sex));
		return true;
	end,

	set_alias = function(self, alias)
		if nil == alias or '' == string.gsub(alias, "^%s*(.-)%s*$", "%1") then
			alias = alias or '';
			show_err('这个名字不太好，改个名字吧 [' .. alias .. ']');
			return false;
		end
		if util.check_has_sensitive_data(alias) then
			show_err('这个名字很敏感，改个名字吧 [' .. alias .. ']');
			return false;
		end
		if true ~= self:is_legal(alias) then
			return false;
		end
		local char = string.sub(alias, 1, 1);	
		local cmd = 'alias ' .. alias;
		net_send(cmd);
	end,

	pick_level = function(self)
		local card = self.list[self.hindex].card;
		--g_scene:add_layer(ZORDER_LAYER_GRADE, layer_grade:create(card.id));
		local hero_id = card.id or 0;
		local grade = 1;
		local cmd = 'job ' .. hero_id .. ' ' .. grade;
		net_send(cmd);
	end,
	
	callback_next = function()
		play_tap_1();
		local self = layer_role;
		local hid = self.list[self.hindex].card.id;
		local alias = self.alias:getText();
		self.sex = self.sex or SEX_MALE;
		local cmd = string.format("sprofile %s %d %s", hid, self.sex, '');  
		net_send(cmd);
		self:set_alias(alias);
	end,
	
	handler = function(event, x, y)
		local self = layer_role;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function (self, x, y)
		self.touch_x = x;
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)
		if nil == self.touch_x then
			return;
		end
		local ox = self.touch_x;
		self.touch_x = nil;
		local offset = x - ox;
		local gap = wfix(30);
		if offset > gap then
			self.callback_left();
		elseif offset < -gap then
			self.callback_right();
		end
	end,

} -- layer_role end

layer_grade = { -- start
	name = 'layer_grade',
	layer = nil,
	hero_id = nil,
	list_toggle = nil,
	list_grade = { 1, 2, 3 },
	grade = 0,

	cleanup = function(self)
		self.layer = nil;
		self.hero_id = nil;
		self.list_toggle = nil;
		self.grade = 0;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, hero_id)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_GRADE, self.handler, true);

		self.hero_id = hero_id;
		self.list_toggle = {};
		local sprite, fullpath, pos, data, scale, size;
		data = gui_get_data('g_bg', GUI_ROLE);
		pos = ccp(HALF_WIDTH, HALF_HEIGHT);
		fullpath = util.get_fullpath(F_IMAGE, data.fname1);
		sprite = util.add_sprite(self.layer, fullpath, pos, ANCHOR_CENTER_CENTER, data.zorder);
		if data.width / data.owidth > data.height / data.oheight then
			sprite:setScale(data.width / data.owidth);
		else
			sprite:setScale(data.height / data.oheight);
		end

		sprite = gui_add_sprite(self.layer, 'g_title', GUI_ROLE, ANCHOR_DOWN);
		sprite = gui_add_sprite(self.layer, 'g_bg_confirm', GUI_ROLE,ANCHOR_DOWN);

		local items = {};
		local item;

		-- self.toggle_info:getSelectedIndex()  0 : off     1 : on
		item, data = gui_add_item(items, 'g_toggle_1', GUI_ROLE, self.callback_switch_grade, ANCHOR_DOWN);
		item:setTag(self.list_grade[1]);
		table.insert(self.list_toggle, item);
		item:setSelectedIndex(1);
		self.grade = 1;

		item, data = gui_add_item(items, 'g_toggle_2', GUI_ROLE, self.callback_switch_grade, ANCHOR_DOWN);
		item:setTag(self.list_grade[2]);
		table.insert(self.list_toggle, item);

		item, data = gui_add_item(items, 'g_toggle_3', GUI_ROLE, self.callback_switch_grade, ANCHOR_DOWN);
		item:setTag(self.list_grade[3]);
		table.insert(self.list_toggle, item);

		item, data = gui_add_item(items, 'confirm', GUI_ROLE, self.callback_next, ANCHOR_DOWN);

		util.add_menu(self.layer, items, data.zorder);

		return self.layer, self.name;
	end,

	callback_switch_grade = function(tag, sender)
		play_tap_3();
		-- self.toggle_info:getSelectedIndex()  0 : off     1 : on
		--print('DEBUG callback_switch_grade tag: ', tag);
		local self = layer_grade;
		local toggle = tolua.cast(sender, "cc.MenuItemToggle");
		self.grade = tag;
		for i = 1, #self.list_toggle do
			local toggle = self.list_toggle[i];
			local tag = toggle:getTag();
			if tag ~= self.grade then
				toggle:setSelectedIndex(0);
			else
				toggle:setSelectedIndex(1);
			end
		end
	end,
	
	callback_next = function()
		play_tap_1();
		local self = layer_grade;
		local hero_id = self.hero_id or 0;
		local grade = self.grade or 1;
		local cmd = 'job ' .. hero_id .. ' ' .. grade;
		--print('DEBUG hero select cmd: ', cmd);
		net_send(cmd);
	end,
	
	handler = function(event, x, y)
		local self = layer_grade;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function (self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)

	end,

} -- layer_grade end

layer_info = {
	name = 'layer_info',
	layer = nil,
	user = nil,
	editbox = nil,
	icon_sprite = nil,
	icon_rect = nil,
	edit_rect = nil,
	gx_label = nil,
	bak_user = nil,

	cleanup = function(self, user)
		self.layer = nil;
		self.user = nil;
		self.editbox = nil;
		self.icon_sprite = nil;
		self.icon_rect = nil;
		self.edit_rect = nil;
		self.gx_label = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, user)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_INFO, self.handler, true);

		self.user = user;
		self.bak_user = self.user;
		init_bar_info_for_full_view(self.layer, self.back, GUI_PLAYERINFO);
		init_bg_for_full_view(self.layer, GUI_PLAYERINFO, '个人信息');
		local sprite, path, pos, data, str, font_path, scale;

		if self.user.sex == SEX_FEMALE then
			gui_add_sprite(self.layer, 'female', GUI_PLAYERINFO, ANCHOR_UP);
		else
			gui_add_sprite(self.layer, 'male', GUI_PLAYERINFO, ANCHOR_UP);
		end

		local items = {};
		local item;

		item, data = gui_add_item(items,'btn_replay', GUI_PLAYERINFO, self.video, ANCHOR_UP);
		gui_add_text_on_sprite_2(item, "回放", data, 30);

		--[[
		if user.eid == g_euser.eid then
			-- TODO don't use this create method
			item, data = gui_add_item(items, 'btn_playback', GUI_PLAYERINFO, self.video, nil, ANCHOR_CENTER_CENTER);
		end
		
		--item, data = gui_add_item(items, 'btn_deck', GUI_PLAYERINFO, self.check_deck); -- 牌堆

		if user.eid ~= g_euser.eid and not is_frd(user.is_frd) then
			item, data = gui_add_item(items, 'btn_add', GUI_PLAYERINFO, self.friends); -- 好友
		end
		]]--
		util.add_menu(self.layer, items, data.zorder);

		sprite, data = gui_add_sprite(self.layer, 'f_icon', GUI_PLAYERINFO, ANCHOR_UP);
		pos = ccp(data.x, data.y);
		path = get_icon_path(user.icon);
		local size = cc.size(data.width, data.height);
		sprite = util.add_sprite(self.layer, path, pos, ANCHOR_LEFT_DOWN, data.zorder-1);
		sprite:setScale(size.width/sprite:getContentSize().width);
		if user.eid == g_euser.eid then
			self.icon_rect = { x1 = pos.x, x2 = pos.x + size.width,
							   y1 = pos.y, y2 = pos.y + size.height };
			self.icon_sprite = sprite;
		end

		sprite = gui_add_sprite(self.layer, 'bg_alias', GUI_PLAYERINFO,ANCHOR_UP);
		str = user.alias or '';
		gui_add_stroke(self.layer,str,23,'alias',GUI_PLAYERINFO,ANCHOR_UP);


		local icon_vip = gui_add_sprite(self.layer, 'icon_vip', GUI_PLAYERINFO,ANCHOR_UP);
		local tips_vip = '月卡时间: ';
		if is_vip_member(user) then
			local end_time = os.date("*t", user.monthly_end_date);
			tips_time = string.format("%d年%d月%d日"
			, end_time.year, end_time.month, end_time.day);
			tips_vip = tips_vip .. tips_time;
		else
			icon_vip:setOpacity(64);
			tips_vip = tips_vip .. '未开通';
		end
		gui_add_label(self.layer,tips_vip,20,'vip',GUI_PLAYERINFO,ANCHOR_UP);


		gui_add_label(self.layer,'经验值:',20,'exp',GUI_PLAYERINFO,ANCHOR_UP);
		gui_add_sprite(self.layer, 'exp_bar_1', GUI_PLAYERINFO,ANCHOR_UP);
		data, scale = gui_get_data('exp_bar_2', GUI_PLAYERINFO, ANCHOR_UP);
		path = util.get_path(data.fname1);
		pos = cc.p(data.x, data.y);
		local bar = util.add_progress_bar(self.layer, util.create_sprite(path), pos, cc.PROGRESS_TIMER_TYPE_BAR, ccp(0, 1), ccp(1, 0), 0, data.zorder);
		bar:setAnchorPoint(ANCHOR_LEFT_DOWN);
		bar:setScale(scale);
		local percent;
		local exp_total = user.exp_next;
		local exp = user.exp;
		if exp < 0 then exp = 0; end
		if 0 == exp_total or exp >= exp_total then
			percent = 100;
		else
			percent = exp / exp_total * 100;
		end
		bar:setPercentage(percent);

		local font_path = util.get_path(FNT_1);
		str = exp .. ' / ' .. exp_total;
		data, scale = gui_get_data('exp_num', GUI_PLAYERINFO, ANCHOR_UP);
		pos = cc.p(data.x+data.width, data.y);
		sprite = util.add_labelbmf(self.layer, str, font_path, pos, ANCHOR_RIGHT_DOWN, data.zorder);
		sprite:setScale(scale);

		if nil ~= user.collection then
			gui_add_label(self.layer,'卡牌数量:',20,'card',GUI_PLAYERINFO,ANCHOR_UP);
			gui_add_sprite(self.layer, 'card_bar_1', GUI_PLAYERINFO,ANCHOR_UP);
			data, scale = gui_get_data('card_bar_2', GUI_PLAYERINFO, ANCHOR_UP);
			path = util.get_path(data.fname1);
			pos = cc.p(data.x, data.y);
			bar = util.add_progress_bar(self.layer, util.create_sprite(path), pos, cc.PROGRESS_TIMER_TYPE_BAR, ccp(0, 1), ccp(1, 0), 0, data.zorder);
			bar:setAnchorPoint(ANCHOR_LEFT_DOWN);
			bar:setScale(scale);
			percent = user.collection / 400 * 100;
			bar:setPercentage(percent);

			str = user.collection .. ' / ' .. '400';
			data, scale = gui_get_data('card_num', GUI_PLAYERINFO, ANCHOR_UP);
			pos = cc.p(data.x+data.width, data.y);
			sprite = util.add_labelbmf(self.layer, str, font_path, pos, ANCHOR_RIGHT_DOWN, data.zorder);
			sprite:setScale(scale);
		end

		local d1 = gui_get_data('bg_sign', GUI_PLAYERINFO, ANCHOR_UP);
		local d2 = gui_get_data('bg_sign', GUI_PLAYERINFO, ANCHOR_DOWN);
		local d3 = gui_get_data('bg_detail', GUI_PLAYERINFO, ANCHOR_UP);
		local d4 = gui_get_data('bg_detail', GUI_PLAYERINFO, ANCHOR_DOWN);
		local h1 = d1.y + d1.height - d3.y;
		local h2 = d1.y + d1.height - d4.y;
		local h3 = math.floor((h2 - h1)/2);

		gui_add_sprite(self.layer, 'bg_sign', GUI_PLAYERINFO,ANCHOR_UP, -h3, h3);
		gui_add_sprite(self.layer, 'bg_title_sign', GUI_PLAYERINFO,ANCHOR_UP);
		gui_add_label(self.layer,'个性签名',30,'title_sign',GUI_PLAYERINFO,ANCHOR_UP);
		data = gui_get_data('sign', GUI_PLAYERINFO, ANCHOR_UP);
		str = get_signature(user.signature);
		pos = cc.p(data.x, data.y-h3);
		size = cc.size(data.width, data.height+h3);	
		local color = cc.c4b(data.r, data.g, data.b, 255);
		self.gx_label = util.add_labelttf(self.layer, str, nil, 25, pos, color, ANCHOR_LEFT_DOWN, data.zorder, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_TOP); 
		if user.eid == g_euser.eid then
			self.edit_rect = { x1= pos.x, x2 = pos.x + size.width,
							   y1= pos.y, y2 = pos.y + size.height }; 
			pos = cc.p(data.x, data.y-h3);
			local rs = cc.size(data.width, data.height+h3);
			self.editbox = util.add_editbox_blank(self.layer, rs,
				ANCHOR_LEFT_DOWN, pos, util.f_default, 25, color, 
				cc.EDITBOX_INPUT_MODE_SINGLELINE, cc.KEYBOARD_RETURNTYPE_DONE, 
				nil, self.editbox_handler, 100, '', color, data.zorder+10); 
			self.editbox:setText(str);
			self.editbox:setVisible(false);
		end

		gui_add_sprite(self.layer, 'bg_detail',GUI_PLAYERINFO,ANCHOR_UP,-h3*2,h3);
		gui_add_sprite(self.layer, 'bg_title_detail', GUI_PLAYERINFO,ANCHOR_UP,-h3);
		gui_add_label(self.layer,'详细资料',30,'title_detail',GUI_PLAYERINFO,ANCHOR_UP,nil,-h3);

		gui_add_label(self.layer,'ID:',22,'id',GUI_PLAYERINFO,ANCHOR_UP,nil,-h3);
		gui_add_label(self.layer,'积分:',22,'rate',GUI_PLAYERINFO,ANCHOR_UP,nil,-h3);
		gui_add_label(self.layer,'胜率:',22,'winper',GUI_PLAYERINFO,ANCHOR_UP,nil,-h3);
		gui_add_label(self.layer,'公会:',22,'guild',GUI_PLAYERINFO,ANCHOR_UP,nil,-h3);
		gui_add_label(self.layer,'对战场次:',22,'match',GUI_PLAYERINFO,ANCHOR_UP,nil,-h3);
		gui_add_label(self.layer,'胜利场次:',22,'win',GUI_PLAYERINFO,ANCHOR_UP,nil,-h3);

		str = user.eid;
		gui_add_label_ali(self.layer, str, 22, 'id_num', GUI_PLAYERINFO, ANCHOR_UP, cc.TEXT_ALIGNMENT_RIGHT, nil, -h3);
		str = math.floor(user.rating);
		gui_add_label_ali(self.layer, str, 22, 'rate_num', GUI_PLAYERINFO, ANCHOR_UP, cc.TEXT_ALIGNMENT_RIGHT, nil, -h3);
		local percent_win = 0;
		if user.game_count > 0 then
			percent_win = user.win / user.game_count * 100;
		end
		percent_win = string.format("%.2f%%", percent_win);
		str = percent_win;
		gui_add_label_ali(self.layer, str, 22, 'winper_num', GUI_PLAYERINFO, ANCHOR_UP, cc.TEXT_ALIGNMENT_RIGHT, nil, -h3);
		if user.gpos > GUILD_POS_NONE and user.gpos ~= GUILD_POS_APPLY then
			str = get_guild_name(user.gname);
		else
			str = t_lang("NO_GUILD");
		end
		gui_add_label_ali(self.layer, str, 22, 'guild_name', GUI_PLAYERINFO, ANCHOR_UP, cc.TEXT_ALIGNMENT_RIGHT, nil, -h3);
		str = user.game_count;
		gui_add_label_ali(self.layer, str, 22, 'match_num', GUI_PLAYERINFO, ANCHOR_UP, cc.TEXT_ALIGNMENT_RIGHT, nil, -h3);
		str = user.win;
		gui_add_label_ali(self.layer, str, 22, 'win_num', GUI_PLAYERINFO, ANCHOR_UP, cc.TEXT_ALIGNMENT_RIGHT, nil, -h3);

		return self.layer, self.name;
	end,

	back = function()
		play_tap_1();
		if g_scene:is_stage(STAGE_MAP) and nil ~= layer_chat.layer then
			layer_chat.layer:setVisible(true);
		end
		local self = layer_info;
		self:remove();
	end,

	video = function()
		play_tap_1();
		local flag = is_wait_for_battle();
		if 1 == flag then
			show_msg("正在等待对战匹配");
			return;
		elseif 2 == flag then
			show_msg("正在等待房间对战");
			return;
		end
		local self = layer_info;
		local eid = self.user.eid or '';
		local alias = self.user.alias or '';
		layer_video.alias = alias;
		local cmd = 'lreplay ' .. eid;
		net_send(cmd);
	end,

	editbox_handler = function(eventname, psender)
		local self = layer_info;
		local edit = tolua.cast(psender, "cc.EditBox");
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
			local str = edit:getText();
			str = util.space_(str);
			edit:setText(str);
			edit:setVisible(false);
			self.gx_label:setString(str);
			self.gx_label:setVisible(true);
			if str ~= g_euser.signature then
				self:save(nil, nil, str);
			end
		elseif eventname == "changed" then
		end
	end,

	save = function(self, icon, sex, signature)
		icon = icon or g_euser.icon;
		sex = sex or g_euser.sex;
		signature = signature or g_euser.signature;
		local cmd = string.format("sprofile %s %d %s", icon, sex, signature);
		net_send(cmd);
	end,

	friends = function()
		local self = layer_info;
	end,

	check_deck = function()
		local self = layer_info;
	end,

	callback_icon = function(index)
		local self = layer_info;
		print('index: ', index);
		if nil ~= index and index ~= tonumber(g_euser.icon) then
			self:save(index);
		end
	end,

	handler = function(event, x, y)
		local self = layer_info;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			if nil ~= layer_pickicon.layer then
				layer_pickicon.close();
				return;
			end
			if nil ~= layer_video.layer then
				layer_video.back();
				return;
			end
			self.back();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		local r = self.icon_rect;
		if nil ~= r and x > r.x1 and x < r.x2 and y > r.y1 and y < r.y2 then
			play_tap_1();
			g_scene:add_layer(ZORDER_LAYER_PICKICON, layer_pickicon:create(self.callback_icon));
			return;
		end
		local t = self.edit_rect;
		if nil ~= t and x > t.x1 and x < t.x2 and y > t.y1 and y < t.y2 then
			play_tap_3();
			self.gx_label:setVisible(false);
			self.editbox:setVisible(true);
			self.editbox:sendActionsForControlEvents(CCControlEventTouchUpInside);
			return;
		end
	end,
} -- layer_info end

layer_pickicon = { -- start
	name = 'layer_pickicon',
	layer = nil,
	callback = nil,
	tag = nil,
	bg_rect = nil,

	cleanup = function(self)
		self.layer = nil;
		self.bg_rect = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, callback)
		self:remove();
		
		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_PICKICON, self.handler, true);

		self.callback = callback;
		util.add_layer_color(self.layer, cc.c4b(0, 0, 0, 158));

		local data, scale = gui_get_data('f_icon', GUI_PLAYERINFO, ANCHOR_UP);
		local len = #list_icon_num;

		local height = 110 + ((math.floor(len/4)+1) * (data.height + 10));
		local bgsize = cc.size(4*(data.width+10)+20, height);--realsize
		local bg, bg_rect = init_bg_for_popview(self.layer, '选择头像', bgsize, self.close);
		self.bg_rect = bg_rect;

		local items = {};
		local item;

		local fpath = util.get_path(data.fname1); -- frame_path
		for i = 1, #list_icon_num do
			local inum = list_icon_num[i];
			local fname = 'picon_1_' .. inum .. '.png';
			local cb = self.indexpicon;
			local index = (i-1)%4;
			local x = 15+data.width/2 + (i-1)%4*(data.width+10);
			local y = bgsize.height-110-(data.height+5)*math.floor((i-1)/4);
			local p = cc.p(x, y);
			item = util.create_item_image(fpath,fpath,p,ANCHOR_CENTER_UP,cb);
			item:setScale(data.width/item:getContentSize().width);
			local path = util.get_path(fname);
			local s = util.add_sprite(item,path,cc.p(0, 0),ANCHOR_LEFT_DOWN, -10);
			s:setScale(item:getContentSize().width/s:getContentSize().width);
			item:setTag(inum);
			table.insert(items, item);
		end

		util.add_menu(bg, items, 20);

		return self.layer, self.name;
	end,
	
	indexpicon = function(...)
		play_tap_1();
		local self = layer_pickicon;
		local args = {...};
		self.tag = args[2]:getTag();
		--print('self.tag: ', self.tag);
		self.close();
	end,

	close = function()
		play_tap_1();
		local self = layer_pickicon;
		local tag = self.tag;
		self:remove();
		if nil ~= self.callback then
			self.callback(self.tag);
		end
	end,

	handler = function(event, x, y)
		local self = layer_pickicon;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		local r = self.bg_rect;
		if nil ~= r and (x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2) then
			self.close();
		end
	end,

} -- layer_pickicon end

layer_video = {
	name = 'layer_video',
	layer = nil,
	list = nil,
	cwidth = nil,
	cheight = nil,
	tableview = nil,
	bar = nil,
	tap = nil,
	eid = nil,
	alias = nil,
	data_cell = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.tableview = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, eid, list)
		self:remove();
		
		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_VIDEO, self.handler, true);

		self.eid = eid;
		-- self.alias is set in layer_info video()
		self.list = list or {};

		init_bar_info_for_full_view(self.layer, self.back, GUI_VIDEO);
		local sprite, data;

		gui_add_sprite(self.layer, 'board', GUI_VIDEO);
		sprite,data = gui_add_sprite(self.layer, 'bg', GUI_VIDEO);
		if data.width/data.rwidth > data.height/data.rheight then
			sprite:setScale(data.width/data.rwidth);
		else
			sprite:setScale(data.height/data.rheight);
		end
		gui_add_sprite(self.layer, 'bg_2', GUI_VIDEO);
		gui_add_sprite(self.layer, 'f_left_up', GUI_VIDEO, ANCHOR_UP);
		gui_add_sprite(self.layer, 'f_right_up', GUI_VIDEO, ANCHOR_UP);
		gui_add_sprite(self.layer, 'bg_title', GUI_VIDEO, ANCHOR_UP);
		gui_add_label_ali(self.layer, t_lang("VIDEO_TITLE"), 28, 'title', GUI_VIDEO, ANCHOR_UP, cc.TEXT_ALIGNMENT_CENTER);

		gui_add_sprite(self.layer, 'alias_left', GUI_VIDEO, ANCHOR_UP);
		gui_add_sprite(self.layer, 'alias_right', GUI_VIDEO, ANCHOR_UP);
		gui_add_label_ali(self.layer, self.alias, 25, 'alias', GUI_VIDEO, ANCHOR_UP, cc.TEXT_ALIGNMENT_CENTER);

		data = gui_get_data('cell', GUI_VIDEO, ANCHOR_UP);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height+10;
		local d2 = gui_get_data('table', GUI_VIDEO, ANCHOR_UP);
		data = gui_get_data('table', GUI_VIDEO, ANCHOR_DOWN);
		size = cc.size(data.width, d2.y+d2.height-data.y);
		pos = cc.p(data.x, data.y);
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		return self.layer, self.name;
	end,

	play_video = function(...)
		play_tap_1();
		local self = layer_video;
		local args = {...};
		local tag = args[2]:getTag();
		local info = self.list[tag];
		if nil == info then
			return;
		end
		local gameid = info.gameid;
		local cmd = 'replay ' .. gameid;
		net_send(cmd);
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_video;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local data = self.data_cell;
			--gui_add_cell_bg(cell, data, width, height);
			gui_add_cell_bg(cell, data);
			local info = self.list[idx + 1];
			local einfo = info.einfo;
			local is_win = info.is_win;
			local data2, sprite, path, pos, size, str;

			sprite, data2 = gui_add_sprite_on_cell(cell, data, 'icon', GUI_VIDEO, ANCHOR_UP);
			path = get_icon_path(einfo.icon);
			sprite = util.add_sprite(sprite, path,cc.p(0,0),ANCHOR_LEFT_DOWN,-1);
			sprite:setScale(data2.width/sprite:getContentSize().width);

			gui_add_sprite_on_cell(cell, data, 'bg_alias', GUI_VIDEO, ANCHOR_UP);
			str = einfo.alias;-- .. einfo.eid;
			gui_add_label_on_cell(cell,data,str,28,'c_alias',GUI_VIDEO,ANCHOR_UP);

			gui_add_sprite_on_cell(cell, data, 'bg_lv', GUI_VIDEO, ANCHOR_UP);

			path = util.get_path('font_lv.fnt');
			str = 'LV.' .. einfo.lv;
			gui_add_labelbmf_on_cell(cell,data,str,path,'lv',GUI_VIDEO,ANCHOR_UP);

			local t = info.gameid;
			str = string.format("%s/%s %s:%s:%s", string.sub(t, 3, 4), string.sub(t, 5, 6), string.sub(t, 7, 8), string.sub(t, 9, 10), string.sub(t, 11, 12));
			path = util.get_path(FNT_1);
			gui_add_labelbmf_on_cell(cell, data, str, path, 'time', GUI_VIDEO, ANCHOR_UP);

			if true == is_win then
				gui_add_sprite_on_cell(cell, data, 'win', GUI_VIDEO, ANCHOR_UP);
			else
				gui_add_sprite_on_cell(cell, data, 'lose', GUI_VIDEO, ANCHOR_UP);
			end

			local ver = tonumber(info.version);
			local lver = tonumber(LOGIC_VERSION);
			local items = {};
			local item;

			item, data2 = gui_add_item_on_cell(items, data, 'btn_play', GUI_VIDEO, self.play_video, ANCHOR_UP);
			item:setTag(idx + 1);
			str = "播放";
			if ver ~= lver then
				str = "旧版本";
				item:setEnabled(false);
			end
			gui_add_text_on_sprite(item,str,'t_play',GUI_VIDEO,ANCHOR_UP,30);

			util.add_menu(cell, items, data2.zorder);

			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	back = function()
		play_tap_1();
		local self = layer_video;
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_video;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
} -- layer_video end

layer_tip = {
	name = 'layer_tip',
	layer = nil,
	callback = nil,
	bg = nil,
	btn_confirm = nil,

	cleanup = function(self)
		self.layer = nil;
		self.callback = nil;
		self.bg = nil;
		self.btn_confirm = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, msg, cb)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_TIP, self.handler, true);

		self.callback = cb;
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));

		local path = util.get_path('pop_up.png');
		local frect = cc.rect(0, 0, 64, 64); -- fullrect
		local irect = cc.rect(30, 30, 4, 4); -- insetrect
		local size = cc.size(wfix(505), hfix(302));--realsize
		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		local bg = util.add_scale9sprite(self.layer, path, pos, ANCHOR_CENTER_CENTER, frect, irect, size, 10); 
		self.bg = bg;

    	if nil ~= msg then
			pos = cc.p(size.width/2, size.height-50);
			local lsize = cc.size(size.width-40, size.height - 80 - 100);
			util.add_labeloutline(bg, msg, nil, 25, pos, util.c4b_white, util.c4b_black, 1, ANCHOR_CENTER_UP, 1, lsize, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_TOP);
    	end

		local items = {};
		local item, p1, p2;

		if nil ~= self.callback then
			pos = cc.p(size.width/4*3, 28);
			self.btn_confirm = add_item_1(items, '确定',nil,30,self.confirm,ANCHOR_CENTER_DOWN,pos);
		end

		if nil ~= self.callback then
			pos = cc.p(size.width/4, 28);
		else
			pos = cc.p(size.width/2, 28);
		end
		add_item_1(items, '取消', nil, 30, self.cancel, ANCHOR_CENTER_DOWN, pos);
		
		util.add_menu(bg, items, 1);

		return self.layer, self.name;
	end,

	confirm = function()
		play_tap_1();
		local self = layer_tip;
		if nil ~= self.callback then
			self.callback(1);
		end
		self:remove();
	end,

	cancel = function()
		play_tap_1();
		local self = layer_tip;
		if g_scene:is_stage(STAGE_DECK) then
			if nil ~= self.callback then
				self.callback(0);
			end
		end
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_tip;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
	end,

} -- layer_tip end

layer_quick = { -- start    wait quick match
	name = 'layer_quick',
	layer = nil,
	is_waiting = false,
	label_time = nil,
	time_1 = nil,
	time = nil,

	cleanup = function(self)
		self.layer = nil;
		self.is_waiting = false;
		self.label_time = nil;
		self.time_1 = nil;
		self.time = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_QUICK, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));
		gui_add_sprite(self.layer, 'bg', GUI_QUICK, ANCHOR_DOWN);
		gui_add_sprite(self.layer, 'bg_title', GUI_QUICK, ANCHOR_DOWN);
		gui_add_label_ali(self.layer,'对战',24,'title',GUI_QUICK, ANCHOR_DOWN, cc.TEXT_ALIGNMENT_CENTER);
		gui_add_sprite(self.layer, 'bg_2', GUI_QUICK, ANCHOR_DOWN);
		sprite,data = gui_add_sprite(self.layer, 'light', GUI_QUICK, ANCHOR_DOWN);
		pos = ccp(data.x+data.width/2, data.y+data.height/2);
		sprite:setPosition(pos);
		sprite:setAnchorPoint(ANCHOR_CENTER_CENTER);
		self:magic_anim(sprite);
		local sprite, data, pos, path, card_width;
		sprite,data = gui_add_sprite(self.layer, 'frame', GUI_QUICK, ANCHOR_DOWN);
		pos = cc.p(data.x+data.width/2, data.y+data.height/2);
		sprite:setPosition(pos);
		sprite:setAnchorPoint(ANCHOR_CENTER_CENTER);
		self:frame_rotate(sprite, data);
		card_width = data.width;

		path = util.get_path(FNT_1);
		sprite, data = gui_add_labelbmf(self.layer, '60', path, 't_time', GUI_QUICK, ANCHOR_DOWN);
		pos = cc.p(data.x+data.width/2+card_width/2, data.y+data.height/2);
		sprite:setPosition(pos);
		sprite:setAnchorPoint(ANCHOR_CENTER_CENTER);
		self.label_time = sprite;

		local fsize = 30;
		local tpos	= cc.p(pos.x - data.width/4, pos.y);
		local tcolor = cc.c4b(128, 255, 128, 255);
		local scolor = cc.c4b(113, 59, 18, 255);
		local outline_size = 1;
		util.add_labeloutline(self.layer, '预计匹配时间:', nil, fsize, tpos, tcolor, scolor, outline_size, ANCHOR_RIGHT_CENTER, data.zorder);
		tpos = cc.p(pos.x + data.width/4, pos.y);
		util.add_labeloutline(self.layer, '秒', nil, fsize, tpos, tcolor, scolor, outline_size, ANCHOR_LEFT_CENTER, data.zorder);


		local items = {};
		local item;

		item, data = gui_add_item(items, 'btn_back', GUI_QUICK, self.callback_return, ANCHOR_DOWN);

		util.add_menu(self.layer, items, data.zorder);

		--eff_layer_1(self.layer);	

		self.time_1 = os.time();
		self.time = 60; -- 60 sec
--		self.time = 600; -- 600 sec
		self.layer:scheduleUpdateWithPriorityLua(self.update_time_count, 1);

		return self.layer, self.name;

	end,

	update_time_count = function(dt)
		local self = layer_quick;
		local t = os.time() - self.time_1;
		local time = self.time - t;
		if 0 > time then
			time = 0;
		end
--		local str = string.format("%d:%d", math.floor(time/60), time%60);
		local str = string.format("%d", time);
		self.label_time:setString(str);
	end,

	frame_rotate = function(self, sprite, data)
		math.randomseed(os.time());
		local fname1 = data.fname2;
		local fname2 = data.fname1;
		local function callback_front(...)
			local args = {...};
			local s = args[1];
			s:removeAllChildrenWithCleanup(true);
			local path = util.get_path(fname1);
			local tc = cc.Director:getInstance():getTextureCache();
			local texture = tc:addImage(path);
			if nil == texture then return; end
			s:setTexture(texture);
			local index = math.random(1, #list_icon_num);
			local filename = 'picon_1_' .. list_icon_num[index] .. '.png';
			path = util.get_path(filename);
			util.add_sprite(s, path, cc.p(0, 0), ANCHOR_LEFT_DOWN, -10);
		end

		local function callback_back(...)
			local args = {...};
			local s = args[1];
			s:removeAllChildrenWithCleanup(true);
			local path = util.get_path(fname2);
			local tc = cc.Director:getInstance():getTextureCache();
			local texture = tc:addImage(path);
			if nil == texture then return; end
			s:setTexture(texture);
		end

		local t = 0.6;
		local action = nil;
		local array = {};
		action = cc.OrbitCamera:create(t, 1, 0, 0, -90, 0, 0);
		table.insert(array, action);
		action = cc.CallFunc:create(callback_front);
		table.insert(array, action);
		action = cc.OrbitCamera:create(t, 1, 0, 90, -90, 0, 0);
		table.insert(array, action);
		action = cc.OrbitCamera:create(t, 1, 0, 0, -90, 0, 0);
		table.insert(array, action);
		action = cc.CallFunc:create(callback_back);
		table.insert(array, action);
		action = cc.OrbitCamera:create(t, 1, 0, 90, -90, 0, 0);
		table.insert(array, action);
		action = cc.Sequence:create(array);
		action = cc.RepeatForever:create(action);
		sprite:runAction(action);
	end,

	magic_anim = function(self, sprite)
		local c = sprite:getColor();
		local action, array;
		array = {};
		action = cc.TintTo:create(1, 150, 0, 150);
		table.insert(array, action);
		action = cc.TintTo:create(1, c.r, c.g, c.b);
		table.insert(array, action);
		action = cc.Sequence:create(array);
		array = {};
		table.insert(array, action);
		action = cc.RotateBy:create(2, 40);
		table.insert(array, action);
		action = cc.Spawn:create(array);
		action = cc.RepeatForever:create(action);
		sprite:runAction(action);
	end,

	start_waiting = function(self)
		if nil == self.layer then
			return
		end
		self.is_waiting = true;
	end,

	stop_waiting = function(self)
		if nil == self.layer then
			return
		end
		self.is_waiting = false;
	end,

	cancel_wait = function(self)
		--local cmd = 'quick 9';
		local cmd = 'fcancel';
		net_send(cmd, true);
	end,

	check_quit = function(self)
		if true == self.is_waiting then
			self:cancel_wait();
		end
	end,

	callback_return = function()
		play_tap_1();
		local self = layer_quick;
		self.remove_after_eff();
		--eff_layer_2(self.layer, self.remove_after_eff);	
	end,

	remove_after_eff = function()
		local self = layer_quick;
		self:check_quit();
		self:remove();
		layer_service:set_show(true);
		--layer_bottombar:set_show(true);
	end,

	handler = function(event, x, y)
		local self = layer_quick;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function (self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)

	end,
} -- layer_quick end

layer_lroom = { -- start   list room info 
	name = 'layer_lroom',
	layer = nil,
	lchannel = nil,
	btn_channel = nil,
	c_channel = 0,
	list = {},
	table_view = nil,
	editbox = nil,
	cwidth = nil,
	cheight = nil,
	bar = nil,
	tap = nil,
	data_cell = nil,
	label_channel = nil,

	cleanup = function(self)
		self.layer = nil;
		self.lchannel = nil;
		self.btn_channel = nil;
		self.c_channel = 0;
		self.list = {};
		self.table_view = nil;
		self.channel = 0;
		self.editbox = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell = nil;
		self.label_channel = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_LROOM, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));
		local sprite, data;
		local offsetheight = init_bg_for_view(self.layer, GUI_ARENA, '观战', self.back);
		self.label_channel = gui_add_label(self.layer, '()', 30, 'channel', GUI_ARENA, ANCHOR_UP);

		data = gui_get_data('cell', GUI_ARENA, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height + 10;
		data = gui_get_data('table', GUI_ARENA, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.table_view = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos,cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		local items = {};
		local item;

		item, data = gui_add_item(items, 'btn_refresh', GUI_ARENA, self.callback_reload, ANCHOR_UP);

		item, data = gui_add_item(items, 'btn_channel', GUI_ARENA, self.callback_channel, ANCHOR_DOWN);
		gui_add_text_on_sprite(item,'切换频道','t_channel',GUI_ARENA,ANCHOR_DOWN,30);
		self.btn_channel = item;

		item, data = gui_add_item(items, 'btn_create', GUI_ARENA, self.callback_create, ANCHOR_DOWN);
		gui_add_text_on_sprite(item,'创建房间','t_create',GUI_ARENA,ANCHOR_DOWN,30);

		item, data = gui_add_item(items, 'btn_search', GUI_ARENA, self.callback_search, ANCHOR_DOWN);
		gui_add_text_on_sprite(item,'查找房间','t_search',GUI_ARENA,ANCHOR_DOWN,30);

		util.add_menu(self.layer, items, data.zorder);

		return self.layer, self.name;
	end,

	set_list_channel = function(self, list)
		list = list or {};
		self.lchannel = list;
		local channel = self.c_channel or 1;
		if 0 >= channel or channel > #list then
			channel = 1;
		end
		self.cb_change_channel(channel);
		--self:handle_channel_btn(channel);
	end,

	change_channel = function(self, channel)
		channel = channel or 1;
		local info = self.lchannel[channel];
		if nil == info then
			return;
		end
		channel = info.id;
		local cmd = 'lroom ' .. channel;
		net_send(cmd);
	end,

	set_channel_name = function(self, item, channel, name)
		local label = item:getChildByTag(TAG_SPRITE_LABEL);
		if nil == label then return; end
		label:setString(name);
	end,

	handle_channel_btn = function(self, channel)
		self.lchannel = self.lchannel or {};
		local info = self.lchannel[channel];
		if nil == info then
			return;
		end
		self.c_channel = channel;
		local item = self.btn_channel;
		local name = info.title;
		if nil == item then
			return;
		end
		self:set_channel_name(item, info.id, name);
		self:change_channel(self.c_channel);
	end,

	cb_change_channel = function(index)
		local self = layer_lroom;
		local list = self.lchannel;
		local info = list[index];
		if nil == info then return; end
		self.c_channel = index;
		self.label_channel:setString('(' .. info.title .. ')');
		self:change_channel(index);
	end,

	callback_channel = function()
		play_tap_1();
		local self = layer_lroom;
		self.lchannel = self.lchannel or {};
		local l = self.lchannel;
		local t = self.c_channel or 1;
		local c = self.cb_change_channel;
		g_scene:add_layer(ZORDER_LAYER_CCHANNEL, layer_cchannel:create(l, t, c));

		--[[
		-- change channel by just tap the btn
		self.lchannel = self.lchannel or {};
		local channel = self.c_channel or 1;
		channel = channel + 1;
		if channel == #self.lchannel + 1 then
			channel = 1;
		end
		self:handle_channel_btn(channel);
		]]--
	end,

	back = function()
		local self = layer_lroom;
		self:remove();
	end,

	callback_reload = function()
		play_tap_1();
		local self = layer_lroom;
		self:change_channel(self.c_channel);
	end,

	callback_sroom = function(guest_name)
		local self = layer_lroom;
		--print('DEBUG g_layer_lroom callback_sroom guest_name: ', guest_name);
		local list = self.list or {};
		local nlist = {};
		for i = 1, #list do
			local info = list[i];
			local title = info.title;
			if nil ~= string.find(title, guest_name) then
				table.insert(nlist, info);
			end
		end
		self.list = nlist;
		self.table_view:reloadData();
	end,

	callback_search = function()
		play_tap_1();
		local self = layer_lroom;
		g_scene:add_layer(ZORDER_LAYER_LOCK, layer_lock:create(3, self.callback_sroom));
	end,

	callback_room = function(lock)
		local self = layer_lroom;
		--print(string.format("lock[%s]", lock));
		-- ' 0 ' means create room
		lock = lock or '';
		--local cmd = 'room ' .. self.c_channel;
		local cmd = 'room 1';
		if 0 < string.len(lock) then
			cmd = cmd .. ' 0 ' .. lock;
		end
		net_send(cmd);
	end,

	callback_create = function()
		play_tap_1();
		local self = layer_lroom;
		g_scene:add_layer(ZORDER_LAYER_LOCK, layer_lock:create(2, self.callback_room));
	end,

	refresh_list = function(self, channel, list)
		if nil == self.layer then
			return;
		end
		local index = 1;
		for i = 1, #(self.lchannel or {}) do
			local id = self.lchannel[i].id;
			if tonumber(id) == tonumber(channel) then
				index = i;
			end
		end
		self.c_channel = index;
		self.list = list;
		self.table_view:reloadData();
	end,

	ask_lock = function(self, index, lock)
		g_scene:add_layer(ZORDER_LAYER_LOCK, layer_lock:create(1, self.callback_lock, index));
	end,

	callback_lock = function(index, input)
		local self = layer_lroom;
		local info = self.list[index];
		if nil == info then
			return;
		end
		input = input or '';
		local rid = info.id;
		local rchannel = info.channel;
		local cmd = 'room ' .. rchannel .. ' ' .. rid .. ' ' .. input;
		net_send(cmd);
	end,

	cb_enter_room = function(...)
		play_tap_1();
		local self = layer_lroom;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		local rid = info.id;
		local pwd_flag = info.pwd_flag;
		-- pwd_flag 0==no password, 1==has password
		local pwd_flag = info.pwd_flag;
		if 1 == pwd_flag then
			self:ask_lock(index, lock);
			return;
		end
		self.callback_lock(index);
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_lroom;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			--local cell = args[3];
			--local idx = cell:getIdx();
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local info = self.list[idx + 1];
			local rid = info.id;
			local num_guest = info.num_guest;
			local rtitle = info.title;
			local pwd_flag = info.pwd_flag;
			local data2, sprite, path, pos, size, str;
			local list_alias = csplit(rtitle, "~VS~");

			gui_add_sprite_on_cell(cell,data,'bg_alias',GUI_ARENA,ANCHOR_DOWN);
			local str_font_size = 24;
			str = list_alias[1] or '';
			if #list_alias == 1 and string.len(str) > 5 then
				-- cut '_room'    e.g  xx_room
				local t = string.sub(str, string.len(str)-4, string.len(str));
				if '_room' == t then
					str = string.sub(str, 1, string.len(str)-5);
				end
			end
			if string.len(str) > 25 then
				str_font_size = 18;
			elseif string.len(str) > 22 then
				str_font_size = 20;
			end
			gui_add_label_on_cell(cell,data,str,str_font_size,'c_alias',GUI_ARENA,ANCHOR_DOWN);

			if nil ~= list_alias[2] then
				str = list_alias[2] or '';
				str_font_size = 24;
				if string.len(str) > 25 then
					str_font_size = 18;
				elseif string.len(str) > 22 then
					str_font_size = 20;
				end
				sprite = gui_add_label_on_cell(cell,data,str,str_font_size,'c_alias',GUI_ARENA,ANCHOR_DOWN);
				sprite:setHorizontalAlignment(cc.TEXT_ALIGNMENT_RIGHT);

				str = '对战';
			else
				str = '等待中...';
			end
			sprite = gui_add_label_on_cell(cell,data,str,28,'c_alias',GUI_ARENA,ANCHOR_DOWN, cc.c4b(182, 28, 16, 255));
			sprite:setHorizontalAlignment(cc.TEXT_ALIGNMENT_CENTER);

			str = '房间人数: ' .. num_guest;
			gui_add_label_on_cell(cell,data,str,24,'t_num',GUI_ARENA,ANCHOR_DOWN);

			if num_guest > 1 then
				str = '状态: 游戏中';
			else
				str = '状态: 准备中';
			end
			if 1 == pwd_flag then
				str = str .. '(已设密码)';
			end
			gui_add_label_on_cell(cell,data,str,24,'t_state',GUI_ARENA,ANCHOR_DOWN);

			local items = {};
			local item;

			item, data2 = gui_add_item_on_cell(items, data, 'btn_enter', GUI_ARENA, self.cb_enter_room, ANCHOR_DOWN);
			item:setTag(idx + 1);
			gui_add_text_on_sprite(item,'进入','t_enter',GUI_ARENA,ANCHOR_DOWN,30);

			util.add_menu(cell, items, data2.zorder);

			--[[

			
			local data2 = gui_get_data('rid', GUI_ARENA, ANCHOR_DOWN);
			pos = ccp(data2.x - data.x, data2.y - data.y);
			local size = cc.size(data2.width, data2.height);
			fullpath = util.get_fullpath(F_FONT, 'font_room_num.fnt');
			pos.x = pos.x + size.width/2;
			pos.y = pos.y + size.height/2-wfix(6);
			sprite = util.add_labelbmf(cell, rid, fullpath, pos, ANCHOR_CENTER_CENTER);

			data2 = gui_get_data('key', GUI_ARENA, ANCHOR_DOWN);
			if 1 == pwd_flag then
				fullpath = util.get_fullpath(F_IMAGE, data2.fname1);
				pos = ccp(data2.x - data.x, data2.y - data.y);
				util.add_sprite(cell, fullpath, pos, ANCHOR_LEFT_DOWN);
			end

			data2 = gui_get_data('kname', GUI_ARENA, ANCHOR_DOWN);
			pos = ccp(data2.x - data.x, 0);
			size = cc.size(data2.width, data.height);
			util.add_labelttf(cell, rtitle, nil, 25, pos, util.c_white, ANCHOR_LEFT_DOWN, zorder, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);

			local str = num_guest .. ' 人';
			data2 = gui_get_data('num', GUI_ARENA, ANCHOR_DOWN);
			pos = ccp(data2.x - data.x, data2.y - data.y);
			size = cc.size(data2.width, data2.height);
			util.add_labelttf(cell, str, nil, 25, pos, util.c_white, ANCHOR_LEFT_DOWN, zorder, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);


			data2 = gui_get_data('rstate', GUI_ARENA, ANCHOR_DOWN);
			pos = ccp(data2.x - data.x, data2.y - data.y);
			if 1 < num_guest then 
				fullpath = util.get_fullpath(F_IMAGE, data2.fname2);
			else
				fullpath = util.get_fullpath(F_IMAGE, data2.fname1);
			end
			util.add_sprite(cell, fullpath, pos, ANCHOR_LEFT_DOWN);
			]]--
			return cell;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_lroom;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function (self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)

	end,
} -- layer_lroom end

layer_lock = {
	name = 'layer_lock',
	layer = nil,
	callback = nil,
	index = nil,
	toggle = nil,
	rect = nil,

	cleanup = function(self)
		self.layer = nil;
		self.toggle = nil;
		self.rect = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	-- ltype 1 输入密码框  2 创建房间 3 查找房号
	create = function(self, ltype, cb, index)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_LOCK, self.handler, true);

		self.callback = cb;
		self.index = index;
		self.toggle = nil;
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 128));
		local title = '';
		if 1 == ltype then
			title = '进入房间';
		elseif 2 == ltype then
			title = '创建房间';
		else -- 3 == ltype
			title = '查找房间';
		end
		local bgsize = cc.size(wfix(400), hfix(350));
		local bg, rect = init_bg_for_popview(self.layer,title,bgsize,self.back);
		self.rect = rect;

		if 1 == ltype then
			self:init_asklock(bg, bgsize);
		elseif 2 == ltype then
			self:init_createroom(bg, bgsize);
		else -- 3 == ltype
			self:init_searchroom(bg, bgsize);
		end

		return self.layer, self.name;
	end,

	init_asklock = function(self)
		local size = cc.size(wfix(300), hfix(71));
		local pos = cc.p((bgsize.width-size.width)/2, hfix(150));
		local tip = '请输入密码';
		self.editbox = add_editbox_1(bg, pos, size, tip, 10,self.editbox_handler);

		local items = {};

		add_item_1(items, '确定', nil, 30, self.confirm_ask, ANCHOR_CENTER_DOWN, cc.p(bgsize.width/4, hfix(30)));

		add_item_1(items, '取消', nil, 30, self.back, ANCHOR_CENTER_DOWN, cc.p(bgsize.width/4*3, hfix(30)));
		
		util.add_menu(bg, items, 50);
	end,

	init_createroom = function(self, bg, bgsize)
		local size = cc.size(wfix(250), hfix(71));
		local pos = cc.p((bgsize.width-size.width)/2+wfix(50), hfix(150));
		local tip = '请输入密码';
		self.editbox = add_editbox_1(bg, pos, size, tip, 10,self.editbox_handler);

		local items = {};

		add_item_1(items, '创建', nil, 30, self.confirm_create, ANCHOR_CENTER_DOWN, cc.p(bgsize.width/4, hfix(30)));

		add_item_1(items, '取消', nil, 30, self.back, ANCHOR_CENTER_DOWN, cc.p(bgsize.width/4*3, hfix(30)));

		local item = add_toggle_1(items, self.callback_use_lock, ANCHOR_CENTER_DOWN, cc.p(wfix(50), hfix(150)));
		self.toggle = item;
		
		util.add_menu(bg, items, 50);
	end,

	init_searchroom = function(self, bg, bgsize)
		local size = cc.size(wfix(300), hfix(71));
		local pos = cc.p((bgsize.width-size.width)/2, hfix(150));
		local tip = '请输入玩家姓名';
		self.editbox = add_editbox_1(bg, pos, size, tip, 10,self.editbox_handler);

		local items = {};

		add_item_1(items, '确定', nil, 30, self.confirm_search, ANCHOR_CENTER_DOWN, cc.p(bgsize.width/4, hfix(30)));

		add_item_1(items, '取消', nil, 30, self.back, ANCHOR_CENTER_DOWN, cc.p(bgsize.width/4*3, hfix(30)));
		
		util.add_menu(bg, items, 50);
	end,

	callback_use_lock = function(tag, sender)
		play_tap_3();
		--print('DEBUG callback_use_lock');
		-- self.toggle_info:getSelectedIndex()  0 : off     1 : on
		--print('selected item: tag: %d, index:%d', tag, tolua.cast(sender, "CCMenuItemToggle"):getSelectedIndex());
	end,

	editbox_handler = function(eventname, psender)
		local self = layer_lock;
		local edit = tolua.cast(psender, "cc.EditBox");
		if nil ~= self.toggle then
			local index = self.toggle:getSelectedIndex();
			if 0 == index then
				self.toggle:setSelectedIndex(1);
			end
		end
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
			local str = edit:getText();
			if nil == str or string.len(str) == 0 then
				if nil ~= self.toggle then
					local index = self.toggle:getSelectedIndex();
					if 1 == index then
						self.toggle:setSelectedIndex(0);
					end
				end
			end
		elseif eventname == "changed" then
		end

	end,

	confirm_ask = function()
		play_tap_1();
		local self = layer_lock;
		local input = self.editbox:getText();
		self:back();
		if nil ~= self.callback then
			self.callback(self.index, input);
		end
	end,

	confirm_create = function()
		play_tap_1();
		local self = layer_lock;
		local index = 0;
		if nil ~= self.toggle then
			index = self.toggle:getSelectedIndex();
		end
		local lock = '';
		if 0 ~= index then
			lock = self.editbox:getText();
		end
		self:back();
		if nil ~= self.callback then
			self.callback(lock);
		end
	end,

	confirm_search = function()
		play_tap_1();
		local self = layer_lock;
		local roomid = self.editbox:getText();
		self:back();
		if nil ~= self.callback then
			self.callback(roomid);
		end
	end,

	back = function()
		play_tap_1();
		local self = layer_lock;
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_lock;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		local r = self.rect;
		if nil ~= r and (x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2) then
			self.back();
		end
	end,
} -- layer_lock end

layer_code = {
	name = 'layer_code',
	layer = nil,
	rect = nil,

	cleanup = function(self)
		self.layer = nil;
		self.rect = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_CODE, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 128));
		local title = '兑换码';
		local bgsize = cc.size(wfix(400), hfix(350));
		local bg, rect = init_bg_for_popview(self.layer,title,bgsize,self.back);
		self.rect = rect;

		local size = cc.size(wfix(300), hfix(71));
		local pos = cc.p((bgsize.width-size.width)/2, hfix(150));
		local tip = '请输入';
		self.editbox = add_editbox_1(bg, pos, size, tip, 10,self.editbox_handler);

		local items = {};

		add_item_1(items, '确定', nil, 30, self.confirm, ANCHOR_CENTER_DOWN, cc.p(bgsize.width/4, hfix(30)));

		add_item_1(items, '取消', nil, 30, self.back, ANCHOR_CENTER_DOWN, cc.p(bgsize.width/4*3, hfix(30)));
		
		util.add_menu(bg, items, 50);

		return self.layer, self.name;
	end,

	editbox_handler = function(eventname, psender)
		local self = layer_code;
		local edit = tolua.cast(psender, "cc.EditBox");
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
		elseif eventname == "changed" then
		end

	end,

	confirm = function()
		play_tap_1();
		local self = layer_code;
		local str = self.editbox:getText() or '';
		str = string.gsub(str, "%s", "");
		if 0 == string.len(str) then
			show_msg("请输入兑换码");
			return;
		end
		--self:back();
		local cmd = 'gift ' .. str;
		net_send(cmd);
	end,

	clean_input = function(self)
		if nil == self.layer then return; end
		if nil == self.editbox then return; end
		self.editbox:setText("");
	end,

	back = function()
		play_tap_1();
		local self = layer_code;
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_code;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		local r = self.rect;
		if nil ~= r and (x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2) then
			self.back();
		end
	end,
} -- layer_code end

layer_room = { -- start    has a room, wait match
	name = 'layer_room',
	layer = nil,
	list = nil,
	tableview = nil,
	cwidth = nil,
	cheight = nil,
	theight = nil,
	bar = nil,
	tap = nil,
	data_cell = nil,

	teid = nil,
	ticon = nil,
	tname = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.tableview = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.theight = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell = nil;

		self.teid = nil;
		self.ticon = nil;
		self.tname = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	-- channel, room_id, room_name
	create = function(self, channel, rid, player)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_ROOM, self.handler, true);

		self.list = list or {};
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 200));
		local sprite, data;
		local offsetheight = init_bg_for_view(self.layer, GUI_ROOM, '房间', self.back);

		data = gui_get_data('cell', GUI_ROOM, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height + 10;
		data = gui_get_data('table', GUI_ROOM, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos,cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		local items = {};
		local item;

		item, data = gui_add_item(items, 'btn_start', GUI_ROOM, self.callback_start, ANCHOR_DOWN);
		gui_add_text_on_sprite(item,'开始','t_start',GUI_ROOM,ANCHOR_DOWN,30);
		self.btn_start = item;
		enable_btn(item, false);
		if player.eid ~= g_euser.eid then
			self.btn_start:setVisible(false);
		end

		util.add_menu(self.layer, items, data.zorder);

		self:insert_player(player);

		return self.layer, self.name;
	end,

	insert_player = function(self, player)
		for i = 1, #self.list do
			if player.eid == self.list[i].eid then
				return;
			end
		end
		local l = {};
		l.eid = player.eid;
		l.alias = player.alias;
		l.icon = player.icon;
		table.insert(self.list, l);
		self.tableview:reloadData();
	end,

	remove_player = function(self, eid)
		for i = 1, #self.list do
			if eid == self.list[i].eid then
				table.remove(self.list, i);
				break;
			end
		end
		self.tableview:reloadData();
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_room;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new();
			local width = self.cwidth;
			local height = self.cheight;
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local info = self.list[idx + 1];
			local icon = info.icon;
			local eid = info.eid;
			local alias = info.alias;
			local data2, sprite, path, pos, size, str;

			sprite, data2 = gui_add_sprite_on_cell(cell, data, 'icon', GUI_ROOM, ANCHOR_DOWN);
			path = get_icon_path(icon);
			sprite = util.add_sprite(sprite, path,cc.p(0,0),ANCHOR_LEFT_DOWN,-1);
			sprite:setScale(data2.width/sprite:getContentSize().width);

			gui_add_sprite_on_cell(cell,data,'bg_alias',GUI_ROOM,ANCHOR_DOWN);
			str = alias;
			gui_add_label_on_cell(cell,data,str,28,'c_alias',GUI_ROOM,ANCHOR_DOWN);

			if idx + 1 == 1 then
				str = '房主';
			elseif idx + 1 == 2 then
				str = '挑战者';
			else
				str = '观战者';
			end
			gui_add_stroke_on_cell(cell,data,str,28,'t_state',GUI_ROOM,ANCHOR_DOWN);

			if idx + 1 > 1 and self.list[1].eid == g_euser.eid then
				local items = {};
				local item;

				item, data2 = gui_add_item_on_cell(items, data, 'btn_kick', GUI_ROOM, self.kick, ANCHOR_DOWN);
				item:setTag(idx + 1);
				gui_add_text_on_sprite(item,'踢出','t_kick',GUI_ROOM,ANCHOR_DOWN,30);

				util.add_menu(cell, items, data2.zorder);
			end
			return cell;
		end
	end, -- tableview_handler end }

	kick = function(...)
		local self = layer_room;
		local args = {...};
		local index = args[2]:getTag();
		local player = self.list[index];
		local cmd = 'kick ' .. player.eid;
		net_send(cmd);
	end,

	show_start = function(self)
		if #self.list < 2 then
			return;
		end
		enable_btn(self.btn_start, true);
	end,

	hide_start = function(self, eid)
		self:remove_player(eid);
		if #self.list > 1 then
			return;
		end
		enable_btn(self.btn_start, false);
	end,

	callback_start = function()
		local self = layer_room;

		local cmd = 'game';
		net_send(cmd);
	end,

	back = function()
		local self = layer_room;
		self:remove();
		local cmd = 'leave';
		net_send(cmd, true);
	end,

	handler = function(event, x, y)
		local self = layer_room;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function (self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)

	end,
} -- layer_room end

layer_cchannel = { 
	name = 'layer_cchannel',
	layer = nil,
	info = nil,
	rect = nil,
	list = nil,
	callback = nil,

	cleanup = function(self)
		self.layer = nil;
		self.info = nil;
		self.rect = nil;
		self.list = nil;
		self.callback = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, list, t, callback)
		self:remove();

		self.info = info;
		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_CCHANNEL, self.handler, true);

		util.add_layer_color(self.layer, cc.c4b(0, 0, 0, 200));

		self.callback = callback;
		self.list = {};
		for i = 1, #list do
			local l = list[i];
			if t ~= i then
				table.insert(self.list, { id = l.id, title = l.title, index = i});
			end
		end
		local btn_height = 70;
		local item_list = {};
		for i = 1, #self.list do
			local l = self.list[i];
			table.insert(item_list, { title = l.title, index = l.index });
		end

		local height = 110 + (#item_list * (btn_height + 10));
		local bgsize = cc.size(wfix(400), height);--realsize
		local bg,rect=init_bg_for_popview(self.layer,'切换频道',bgsize,self.back);
		self.rect = rect;

		local items = {};

		local gap = btn_height + 5;
		for i = 1, #item_list do
			local l = item_list[i];
			local p = cc.p(bgsize.width/2, bgsize.height-150-gap*(i-1));
			local s = cc.size(bgsize.width - 70, btn_height);
			local item = add_item_1(items, l.title, nil, 30, self.change, ANCHOR_CENTER_CENTER,p,s);
			item:setTag(i);
		end

		pos = cc.p(bgsize.width-20, bgsize.height-20);
		add_item_close(items, pos, ANCHOR_CENTER_CENTER, self.back);

		util.add_menu(bg, items, 20);

		return self.layer, self.name;
	end,

	change = function(...)
		local self = layer_cchannel;
		local args = {...};
		local tag = args[2]:getTag();
		local info = self.list[tag];
		if nil == info then return; end
		if nil ~= self.callback then
			self.callback(info.index);
		end
		self.back();
	end,

	back = function()
		local self = layer_cchannel;
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_cchannel;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		local r = self.rect;
		if nil == r then
			return;
		end
		if x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2 then
			self.back();
		end
	end,
} -- layer_cchannel end

layer_book = { -- start    
	name = 'layer_book',
	PAGE_SIZE = 12,
	layer = nil,
	list_pick_hero = {
		{ tag = 1, title = '所有英雄' },
		--[[ -- set in layer_shop add_to_list
		{ tag = 2, title = '盖伦' },
		{ tag = 3, title = '瑞雯' },
		{ tag = 4, title = '宙斯' },
		{ tag = 5, title = '莉莱' },
		{ tag = 6, title = '娑娜' },
		{ tag = 7, title = '特朗德尔' },
		{ tag = 8, title = '安妮' },
		]]--
	},
	list_pick_type = {
		{ tag = 1, title = '所有分类' },
		{ tag = 2, title = '英雄' },
		{ tag = 3, title = '附加' },
		{ tag = 4, title = '技能' },
		{ tag = 5, title = '盟军' },
		{ tag = 6, title = '武器' },
		{ tag = 7, title = '防具' },
		{ tag = 8, title = '支援' },
	},
	in_hero_buy = nil,
	in_type_buy = nil,
	in_hero_sell = nil,
	in_type_sell = nil,
	list = nil,
	list_phero = nil,
	list_shop = nil,
	tableview = nil,
	last_id = 0,
	tap_buy = nil,
	tap_sell = nil,
	kind = nil,
	KIND_BUY = 1,
	KIND_SELL = 2,
	my_cards = nil,
	clarrow = nil,
	crarrow = nil,
	twidth = nil,
	line = nil,
	side = nil,
	offset = nil,
	offset_buy = nil,
	offset_sell = nil,
	label_hero = nil,
	label_type = nil,

	cleanup = function(self)
		self.layer = nil;
		self.in_hero_buy = nil;
		self.in_type_buy = nil;
		self.in_hero_sell = nil;
		self.in_type_sell = nil;
		self.list = nil;
		self.list_phero = nil;
		self.list_shop = nil;
		self.tableview = nil;
		self.last_id = 0;
		self.tap_buy = nil;
		self.tap_sell = nil;
		self.kind = nil;
		self.my_cards = nil;
		self.clarrow = nil;
		self.crarrow = nil;
		self.twidth = nil;
		self.line = nil;
		self.side = nil;
		self.offset = nil;
		self.offset_buy = nil;
		self.offset_sell = nil;
		self.label_hero = nil;
		self.label_type = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_BOOK, self.handler, true);

		self.my_cards = c_str_array_2(g_euser.all_str);	

		-- btn back set in g_scene.shop
		init_bg_for_full_view(self.layer, GUI_SHOP, '图鉴');
		local sprite, pos, size, data;
		local d1 = gui_get_data('bg_table', GUI_SHOP, ANCHOR_UP);
		local d2 = gui_get_data('bg_table', GUI_SHOP, ANCHOR_DOWN);
		local offsety = d1.y - d2.y;
		gui_add_sprite(self.layer, 'bg_table', GUI_SHOP, ANCHOR_UP, -offsety, offsety);
		gui_add_sprite(self.layer, 'bg_bottom', GUI_SHOP, ANCHOR_DOWN);
		gui_add_sprite(self.layer, 'bg_hero', GUI_SHOP, ANCHOR_DOWN);
		gui_add_sprite(self.layer, 'bg_kind', GUI_SHOP, ANCHOR_DOWN);
		self.label_hero = gui_add_label(self.layer, '', 23, 't_hero', GUI_SHOP, ANCHOR_DOWN);
		self.label_type = gui_add_label(self.layer, '', 23, 't_kind', GUI_SHOP, ANCHOR_DOWN);

		local items = {};
		local item;

		--item, data = gui_add_item(items, 'reload', GUI_SHOP, self.callback_reloadlist, ANCHOR_UP);

		item, data = gui_add_item(items, 'tab_buy', GUI_SHOP, self.callback_buy, ANCHOR_UP);
		gui_add_text_outline_on_sprite(item, "卡牌", 't_buy', GUI_SHOP, ANCHOR_UP, 30);
		self.tap_buy = item;

		item, data = gui_add_item(items, 'tab_sell', GUI_SHOP, self.callback_sell, ANCHOR_UP);
		gui_add_text_outline_on_sprite(item, "售卖", 't_sell', GUI_SHOP, ANCHOR_UP, 30);
		self.tap_sell = item;
		self.tap_sell:setVisible(false);

		item, data = gui_add_item(items, 'more_hero', GUI_SHOP, self.pick_hero, ANCHOR_DOWN);

		item, data = gui_add_item(items, 'more_kind', GUI_SHOP, self.pick_type, ANCHOR_DOWN);

		util.add_menu(self.layer, items, data.zorder);

		self.callback_buy(0, self.tap_buy);

		self.list = {};
		data = gui_get_data('table', GUI_SHOP, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsety);
		-----------
		self.r_table = { x = data.x, y = data.y, offsety = offsety,
						 width = data.width, height = data.height + offsety };
		-----------
		local dcard = gui_get_data('card', GUI_SHOP, ANCHOR_DOWN);
		self.cwidth = dcard.width / dcard.height * (dcard.height + offsety/2);
		self.cheight = data.height + offsety;

		self.twidth = size.width;
		self.line = pos.y + size.height/2;
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_HORIZONTAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, data.zorder);
		self.clarrow, self.crarrow = util.add_arrows(self.layer, pos, size, self.cwidth, 0, cc.p(0, 0));

		return self.layer, self.name;
	end,

	syn_hero_list = function(self, new_index)
		if self.kind == self.KIND_BUY then
			new_index = (new_index or self.in_hero_buy) or 1;
		else
			new_index = (new_index or self.in_hero_sell) or 1;
		end
		local nlist = {};
		local list = {};
		if self.kind == self.KIND_SELL then
			for i = 1, #self.list_shop do
				local info = self.list_shop[i];
				local count = self:is_has_card(info.card.id);
				if count > 0 then
					table.insert(list, info);
				end
			end
		else
			list = self.list_shop;
		end
		local info = self.list_pick_hero[new_index];
		local tag = info.tag;
		if 1 == tag then -- all kind of type
			for i = 1, #list do
				table.insert(nlist, list[i]);
			end
		elseif 2 == tag then -- hero id 1 GaiLun
			local cid = 1;
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(cid, card.id);
				if cid == card.id or true == is_fit then
					table.insert(nlist, list[i]);
				end
			end
		elseif 3 == tag then -- hero id 2 RuiWen
			local cid = 2;
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(cid, card.id);
				if cid == card.id or true == is_fit then
					table.insert(nlist, list[i]);
				end
			end
		elseif 4 == tag then -- hero id 5 ZhouSi
			local cid = 5;
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(cid, card.id);
				if cid == card.id or true == is_fit then
					table.insert(nlist, list[i]);
				end
			end
		elseif 5 == tag then -- hero id 6 LaiLi
			local cid = 6;
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(cid, card.id);
				if cid == card.id or true == is_fit then
					table.insert(nlist, list[i]);
				end
			end
		elseif 6 == tag then -- hero id 8 SuoNa
			local cid = 8;
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(cid, card.id);
				if cid == card.id or true == is_fit then
					table.insert(nlist, list[i]);
				end
			end
		elseif 7 == tag then -- hero id 11 TeLangDeEr
			local cid = 11;
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(cid, card.id);
				if cid == card.id or true == is_fit then
					table.insert(nlist, list[i]);
				end
			end
		elseif 8 == tag then -- hero id 15 AnNi
			local cid = 15;
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(cid, card.id);
				if cid == card.id or true == is_fit then
					table.insert(nlist, list[i]);
				end
			end
		end
		self.list = nlist;
		self.list_phero = self.list;
		return self.list;
	end,

	syn_type_list = function(self, new_index)
		if self.kind == self.KIND_BUY then
			new_index = (new_index or self.in_type_buy) or 1;
		else
			new_index = (new_index or self.in_type_sell) or 1;
		end
		local nlist = {};
		local list = self.list_phero or self.list;
		local info = self.list_pick_type[new_index];
		local tag = info.tag;
		if 1 == tag then -- all kind of type
			for i = 1, #list do
				table.insert(nlist, list[i]);
			end
		elseif 2 == tag then -- hero 
			for i = 1, #list do
				local card = list[i].card;
				if HERO == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 3 == tag then -- attach 
			for i = 1, #list do
				local card = list[i].card;
				if ATTACH == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 4 == tag then -- ability 
			for i = 1, #list do
				local card = list[i].card;
				if ABILITY == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 5 == tag then -- ally 
			for i = 1, #list do
				local card = list[i].card;
				if ALLY == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 6 == tag then -- weapon 
			for i = 1, #list do
				local card = list[i].card;
				if WEAPON == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 7 == tag then -- armor 
			for i = 1, #list do
				local card = list[i].card;
				if ARMOR == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 8 == tag then -- SUPPORT 
			for i = 1, #list do
				local card = list[i].card;
				if SUPPORT == card.ctype or TRAP == card.ctype or ARTIFACT == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		end
		self.list = nlist;
		return self.list;
	end,

	change_hero_type = function(self, new_index)
		new_index = new_index or 1;
		local titles = self.list_pick_hero or {};
		if 0 == titles then return; end

		local info = titles[new_index];
		if nil == info then return; end
		local name = info.title;
		self.label_hero:setString(name);

		if self.kind == self.KIND_BUY then
			if new_index ~= self.in_hero_buy then
				self.offset_buy = nil;
			end
			self.in_hero_buy = new_index;
		else
			if new_index ~= self.in_hero_sell then
				self.offset_sell = nil;
			end
			self.in_hero_sell = new_index;
		end

		local list = self.list or {};
		if 0 == #list then return; end

		self:syn_hero_list(new_index);
		self:reload();
	end,

	change_pick_type = function(self, new_index)
		new_index = new_index or 1;
		local titles = self.list_pick_type or {};
		if 0 == titles then return; end

		local info = titles[new_index];
		if nil == info then return; end
		local name = info.title;
		self.label_type:setString(name);

		if self.kind == self.KIND_BUY then
			if new_index ~= self.in_type_buy then
				self.offset_buy = nil;
			end
			self.in_type_buy = new_index;
		else
			if new_index ~= self.in_type_sell then
				self.offset_sell = nil;
			end
			self.in_type_sell = new_index;
		end

		local list = self.list or {};
		if 0 == #list then return; end

		self:syn_type_list(new_index);
		self:reload();
	end,

	callback_pick_hero = function(index)
		local self = layer_book;
		self:change_hero_type(index);
		local pindex;
		if self.kind == self.KIND_BUY then
			pindex = self.in_type_buy;
		else
			pindex = self.in_type_sell;
		end
		self:change_pick_type(pindex);
	end,

	pick_hero = function()
		local self = layer_book;
		local cb = self.callback_pick_hero;
		local list = self.list_pick_hero;
		g_scene:add_layer(ZORDER_LAYER_PICK, layer_pick:create(list, cb));
	end,

	callback_pick_type = function(index)
		local self = layer_book;
		self:change_pick_type(index);
	end,

	pick_type = function()
		local self = layer_book;
		local cb = self.callback_pick_type;
		local list = self.list_pick_type;
		g_scene:add_layer(ZORDER_LAYER_PICK, layer_pick:create(list, cb));
	end,

	reload = function(self)
		local offset;
		if true ~= SHOP_PAGE then
			if self.kind == self.KIND_BUY then
				offset = self.offset_buy;
			else -- self.KIND_SELL
				offset = self.offset_sell;
			end
		else
			offset = self.offset;
		end
		self.tableview:reloadData();
		if nil ~= offset then
			self.tableview:setContentOffset(offset, false);
		end
	end,

	callback_reloadlist = function()
		play_tap_3();
		local self = layer_book;
		g_list_shop = {};
		if true ~= SHOP_PAGE then
			self.list_shop = {};
			self.list = {};
			self.callback_buy(0, self.tap_buy);
			self.offset_buy = nil;
			self.offset_sell = nil;
			-- total 400 cards
			-- each turn get 40 , 10 times
			local p = 40;
			local t = math.ceil(CARD_ARRAY_LIST / p);
			g_list_shop.last_id = t;
			for i = 1, t do
				local cmd = 'shop ' .. (1+p*(i-1)) .. ' ' .. p;
				net_send(cmd);
			end
		else
			self.list = {};
			self.offset = nil;
			-- each page has 4 cards (show 6);
			-- first time get 4 * 3 = 12 cards;
			local cmd = 'shop 1 ' .. layer_shop.PAGE_SIZE;
			net_send(cmd);
		end
	end,

	set_buy_list = function(self)
		self.list = {};
		for i = 1, #self.list_shop do
			local info = self.list_shop[i];
			table.insert(self.list, info);
		end
		self:change_hero_type(self.in_hero_buy);
		self:change_pick_type(self.in_type_buy);
	end,

	set_sell_list = function(self)
		self.list = {};
		for i = 1, #self.list_shop do
			local info = self.list_shop[i];
			local count = self:is_has_card(info.card.id);
			if count > 0 then
				table.insert(self.list, info);
			end
		end
		self:change_hero_type(self.in_hero_sell);
		self:change_pick_type(self.in_type_sell);
	end,

	callback_buy = function(tag, sender)
		play_tap_3();
		local self = layer_book;
		--local toggle = tolua.cast(sender, "CCMenuItemToggle");
		self.kind = self.KIND_BUY;
		local index = self.tap_sell:getSelectedIndex();
		if 0 == index then
			self.tap_buy:setSelectedIndex(1);
			return;
		end
		self.tap_buy:setSelectedIndex(1);
		self.tap_sell:setSelectedIndex(0);
		if true ~= SHOP_PAGE then
			self:set_buy_list();
		else
			self:reload();
		end
	end,

	callback_sell = function(tag, sender)
		play_tap_3();
		local self = layer_book;
		if g_euser.level < 10 then
			show_msg('10级开启');
			self.tap_sell:setSelectedIndex(0);
			return;
		end
		--local toggle = tolua.cast(sender, "CCMenuItemToggle");
		self.kind = self.KIND_SELL;
		local index = self.tap_buy:getSelectedIndex();
		if 0 == index then
			self.tap_sell:setSelectedIndex(1);
			return;
		end
		self.tap_sell:setSelectedIndex(1);
		self.tap_buy:setSelectedIndex(0);
		if true ~= SHOP_PAGE then
			self:set_sell_list();
		end
		self:reload();
	end,

	add_to_list = function(self, list, last_id)
		--print('last_id: ', last_id);
		if true ~= SHOP_PAGE then
			self.list_shop = self.list_shop or {};
			if #self.list_shop > 0 then
				return;
			end
			self.list_pick_hero = { { tag = 1, title = '所有英雄' } };
			for i = 1, #list do
				local info = list[i];
				table.insert(self.list_shop, info);
				if info.card.ctype == HERO then
					local tag = info.card.id;
					local title = info.card.name;
					table.insert(self.list_pick_hero, {tag=i+1, title=title});
				end
			end
			if self.kind == self.KIND_BUY then
				self:set_buy_list();
				--self:reload();
			else
				self.callback_buy(0, self.tap_buy);
			end
			return;
		end
		self.list = self.list or {};
		self.last_id = last_id;
		if 0 == #list then
			--self.last_id = -1; -- -1 means don't need to send requst again
			if -1 == self.last_id then
				return;
			end
			local card_id = self.last_id + 1;
			local cmd = 'shop ' .. card_id .. ' ' .. self.PAGE_SIZE;
			net_send(cmd);
			return;
		end
		if 0 < #self.list then
			local m = self.list[#self.list];
			if true == m.flag_more_cell then
				table.remove(self.list, #self.list);
			end
			m = self.list[#self.list];
			if true == m.flag_more_cell then
				table.remove(self.list, #self.list);
			end
		end
		for i = 1, #list do
			table.insert(self.list, list[i]);
		end
		if self.PAGE_SIZE == #list then
			local hlen = (#self.list)%2;
			local more_cell = { flag_more_cell = true };
			table.insert(self.list, more_cell);
			if 1 == hlen then
				more_cell = { flag_more_cell = true };
				table.insert(self.list, more_cell);
			end
		end
	end,

	back = function()
		play_tap_1();
		layer_book:remove();
	end,

	is_has_card = function(self, cid)
		for i = 1, #self.my_cards do
			local info = self.my_cards[i];
			if info.cid == cid and info.count >= 0 then
				return info.count;
			end
		end
		return 0;
	end,

	update_my_cards = function(self, cid, count)
		for i = 1, #self.my_cards do
			local info = self.my_cards[i];
			local mid = info.cid;
			if mid == cid then
				info.count = info.count + count;
				if 0 >= info.count then
					table.remove(self.my_cards, i);
				end
				if self.kind == self.KIND_BUY then
					self:set_buy_list();
				else -- self.kind == self.KIND_SELL
					self:set_sell_list();
				end
				--self:reload();
				return;
			end
		end
		table.insert(self.my_cards, { cid = cid, count = count });
		if self.kind == self.KIND_BUY then
			self:set_buy_list();
		else -- self.kind == self.KIND_SELL
			self:set_sell_list();
		end
		--self:reload();
	end,

	get_more = function()
		local self = layer_book;
		local card_id = self.last_id + 1;
		local cmd = 'shop ' .. card_id .. ' ' .. self.PAGE_SIZE;
		net_send(cmd);
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_book;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return math.ceil(#(self.list or {})/2);
		elseif "scrollViewDidScroll" == event then
			local len = math.ceil(#self.list / 2);
			local offset = view:getContentOffset();
			if true ~= SHOP_PAGE then
				if self.kind == self.KIND_BUY then
					self.offset_buy = offset;
				else -- self.KIND_SELL
					self.offset_sell = offset;
				end
			else
				self.offset = offset;
			end
			util.handle_arrows(self.clarrow, self.crarrow, len, self.cwidth, self.twidth, offset);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			local index = idx*2 + 1;
			if 2 == self.side then -- down
				index = index + 1;
			elseif 1 == self.side then -- up
			else
				return;
			end
			local info = self.list[index];
			if nil == info then
				return;
			end
			if true == SHOP_PAGE then
				if true == info.flag_more_cell then
					return;
				end
			end
			info.kind = self.kind;
			--g_scene:add_layer(ZORDER_LAYER_SHOPPOP, layer_shoppop:create(info));
			g_scene:add_layer(ZORDER_LAYER_MISPOP,layer_mispop:create(info.card));
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local index = idx*2 + 1;
			if true == SHOP_PAGE and true == self.list[index].flag_more_cell then
				local items = {};

				add_item_1(items, '更多', nil, 20, self.get_more,ANCHOR_CENTER_CENTER,pos);

				util.add_menu(cell, items, 1);
				return cell;
			end
			local size;
			for i = index, index+1 do
				local info = self.list[i];
				if nil == info or true == info.flag_more_cell then
					break;
				end
				local card = clone(info.card);
				local basey = 0;
				if i % 2 == 0 then
					basey = height/2;
				end
				local s, d; -- sprite, data
				local d = gui_get_data('card', GUI_SHOP, ANCHOR_DOWN);
				r = self.r_table;
				local offsety = r.offsety;
				local offset = -r.y-basey+offsety/2;
				local scale = (d.height + offsety/2) / CARD_SIZE.height;
				local pos = cc.p(width/2, d.y+offset+CARD_SIZE.height*scale/2);
				pos.y = pos.y-hfix(30);
				local cinfo = object_card:new(cell, card, nil, nil, pos, 0, scale, STYPE_VER_1);
				local sprite = cinfo:get_front();
				self.list[i].info = cinfo;
				self.list[i].sprite = sprite;

				--[[
				local gold, crystal, path;
				if self.kind == self.KIND_BUY then
					gold = math.abs(info.c_buygold);
					crystal = math.abs(info.c_buycrystal);
				else -- self.KIND_SELL
					gold = info.c_sellgold;
					crystal = info.c_sellcrystal;
				end
				self.list[i].gold = gold;
				self.list[i].crystal = crystal;
				path = util.get_path(FNT_1);
				local gapy = 10 * sprite:getScale();
				scale = 0;
				if gold > 0 then
					s, d = gui_add_sprite(cell, 'bg_gold', GUI_SHOP, ANCHOR_DOWN);
					s:setPosition(cc.p(d.x-r.x, d.y+offset));
					local w = width/s:getContentSize().width;
					local h = d.height/s:getContentSize().height;
					if w > h then
						scale = h;
					else
						scale = w;
					end
					s:setScale(scale);
					s, d = gui_add_sprite(cell, 'icon_gold',GUI_SHOP,ANCHOR_DOWN);
					s:setPosition(cc.p(d.x-r.x, d.y+offset));
					s:setScale(scale);

					s, d = gui_add_labelbmf(cell, gold, path,'num_gold',GUI_SHOP,ANCHOR_DOWN);
					s:setPosition(cc.p(d.x-r.x, d.y+offset));
					s:setScale(scale);
				end
				if crystal > 0 then
					s, d = gui_add_sprite(cell,'bg_crystal',GUI_SHOP,ANCHOR_DOWN);
					s:setPosition(cc.p(d.x-r.x, d.y+offset));
					if 0 == scale then
						local w = width/s:getContentSize().width;
						local h = d.height/s:getContentSize().height;
						if w > h then
							scale = h;
						else
							scale = w;
						end
					end
					s:setScale(scale);
					s,d=gui_add_sprite(cell,'icon_crystal',GUI_SHOP,ANCHOR_DOWN);
					s:setPosition(cc.p(d.x-r.x, d.y+offset));
					s:setScale(scale);
				
					s, d = gui_add_labelbmf(cell, crystal, path,'num_crystal',GUI_SHOP,ANCHOR_DOWN);
					s:setPosition(cc.p(d.x-r.x, d.y+offset));
					s:setScale(scale);
				end
				]]--

				local count = self:is_has_card(cinfo.card.id);
				self.list[i].count = count;
				path = util.get_path('font_deck_num.fnt');
				pos = cc.p(width/4*3, height/4*3-basey+10);
				count = '*' .. count;
				s=util.add_labelbmf(cell,count,path,pos,ANCHOR_CENTER_CENTER,100);
				if wfix(1) > hfix(1) then
					s:setScale(hfix(1));
				else
					s:setScale(wfix(1));
				end
			end
			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_book;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.back();
		end
	end,

	onTouchBegan = function (self, x, y)
		if y > self.line then
			self.side = 1; -- up
		else
			self.side = 2; -- down
		end
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
	end,
	
	onTouchEnded = function(self, x, y)
		--[[
		if -1 == self.last_id then
			return;
		end
		local len = #(self.list or {});
		if 0 == len then
			return;
		end
		len = math.ceil(len / 2);
		local offset = self.tableview:getContentOffset();
		local line = math.floor(self.cwidth * (len-3) - self.twidth);
		if offset.x + line <= 0 then
			local card_id = self.last_id + 1;
			local cmd = 'shop ' .. card_id .. ' ' .. self.PAGE_SIZE;
			net_send(cmd);
		end
		]]--
	end,

} -- layer_book end

layer_shop = { -- start    
	name = 'layer_shop',
	PAGE_SIZE = 12,
	layer = nil,
	list_pick_hero = {
		{ tag = 1, title = '所有英雄' },
		--[[ -- set in layer_shop add_to_list
		{ tag = 2, title = '盖伦' },
		{ tag = 3, title = '瑞雯' },
		{ tag = 4, title = '宙斯' },
		{ tag = 5, title = '莉莱' },
		{ tag = 6, title = '娑娜' },
		{ tag = 7, title = '特朗德尔' },
		{ tag = 8, title = '安妮' },
		]]--
	},
	list_pick_type = {
		{ tag = 1, title = '所有分类' },
		{ tag = 2, title = '英雄' },
		{ tag = 3, title = '附加' },
		{ tag = 4, title = '技能' },
		{ tag = 5, title = '盟军' },
		{ tag = 6, title = '武器' },
		{ tag = 7, title = '防具' },
		{ tag = 8, title = '支援' },
	},
	in_hero_buy = nil,
	in_type_buy = nil,
	in_hero_sell = nil,
	in_type_sell = nil,
	list = nil,
	list_phero = nil,
	list_shop = nil,
	tableview = nil,
	last_id = 0,
	tap_buy = nil,
	tap_sell = nil,
	kind = nil,
	KIND_BUY = 1,
	KIND_SELL = 2,
	my_cards = nil,
	clarrow = nil,
	crarrow = nil,
	twidth = nil,
	line = nil,
	side = nil,
	offset = nil,
	offset_buy = nil,
	offset_sell = nil,
	label_hero = nil,
	label_type = nil,

	cleanup = function(self)
		self.layer = nil;
		self.in_hero_buy = nil;
		self.in_type_buy = nil;
		self.in_hero_sell = nil;
		self.in_type_sell = nil;
		self.list = nil;
		self.list_phero = nil;
		self.list_shop = nil;
		self.tableview = nil;
		self.last_id = 0;
		self.tap_buy = nil;
		self.tap_sell = nil;
		self.kind = nil;
		self.my_cards = nil;
		self.clarrow = nil;
		self.crarrow = nil;
		self.twidth = nil;
		self.line = nil;
		self.side = nil;
		self.offset = nil;
		self.offset_buy = nil;
		self.offset_sell = nil;
		self.label_hero = nil;
		self.label_type = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_SHOP, self.handler, true);

		self.my_cards = c_str_array_2(g_euser.all_str);	

		-- btn back set in g_scene.shop
		init_bg_for_full_view(self.layer, GUI_SHOP, '商店');
		local sprite, pos, size, data;
		local d1 = gui_get_data('bg_table', GUI_SHOP, ANCHOR_UP);
		local d2 = gui_get_data('bg_table', GUI_SHOP, ANCHOR_DOWN);
		local offsety = d1.y - d2.y;
		gui_add_sprite(self.layer, 'bg_table', GUI_SHOP, ANCHOR_UP, -offsety, offsety);
		gui_add_sprite(self.layer, 'bg_bottom', GUI_SHOP, ANCHOR_DOWN);
		gui_add_sprite(self.layer, 'bg_hero', GUI_SHOP, ANCHOR_DOWN);
		gui_add_sprite(self.layer, 'bg_kind', GUI_SHOP, ANCHOR_DOWN);
		self.label_hero = gui_add_label(self.layer, '', 23, 't_hero', GUI_SHOP, ANCHOR_DOWN);
		self.label_type = gui_add_label(self.layer, '', 23, 't_kind', GUI_SHOP, ANCHOR_DOWN);

		local items = {};
		local item;

		item, data = gui_add_item(items, 'reload', GUI_SHOP, self.callback_reloadlist, ANCHOR_UP);

		item, data = gui_add_item(items, 'tab_buy', GUI_SHOP, self.callback_buy, ANCHOR_UP);
		gui_add_text_outline_on_sprite(item, "购买", 't_buy', GUI_SHOP, ANCHOR_UP, 30);
		self.tap_buy = item;

		item, data = gui_add_item(items, 'tab_sell', GUI_SHOP, self.callback_sell, ANCHOR_UP);
		gui_add_text_outline_on_sprite(item, "售卖", 't_sell', GUI_SHOP, ANCHOR_UP, 30);
		self.tap_sell = item;

		item, data = gui_add_item(items, 'more_hero', GUI_SHOP, self.pick_hero, ANCHOR_DOWN);

		item, data = gui_add_item(items, 'more_kind', GUI_SHOP, self.pick_type, ANCHOR_DOWN);

		util.add_menu(self.layer, items, data.zorder);

		self.callback_buy(0, self.tap_buy);

		self.list = {};
		data = gui_get_data('table', GUI_SHOP, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsety);
		-----------
		self.r_table = { x = data.x, y = data.y, offsety = offsety,
						 width = data.width, height = data.height + offsety };
		-----------
		local dcard = gui_get_data('card', GUI_SHOP, ANCHOR_DOWN);
		self.cwidth = dcard.width / dcard.height * (dcard.height + offsety/2);
		self.cheight = data.height + offsety;

		self.twidth = size.width;
		self.line = pos.y + size.height/2;
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_HORIZONTAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, data.zorder);
		self.clarrow, self.crarrow = util.add_arrows(self.layer, pos, size, self.cwidth, 0, cc.p(0, 0));

		return self.layer, self.name;
	end,

	syn_hero_list = function(self, new_index)
		if self.kind == self.KIND_BUY then
			new_index = (new_index or self.in_hero_buy) or 1;
		else
			new_index = (new_index or self.in_hero_sell) or 1;
		end
		local nlist = {};
		local list = {};
		if self.kind == self.KIND_SELL then
			for i = 1, #self.list_shop do
				local info = self.list_shop[i];
				local count = self:is_has_card(info.card.id);
				if count > 0 then
					table.insert(list, info);
				end
			end
		else
			list = self.list_shop;
		end
		local info = self.list_pick_hero[new_index];
		local tag = info.tag;
		if 1 == tag then -- all kind of type
			for i = 1, #list do
				table.insert(nlist, list[i]);
			end
		elseif 2 == tag then -- hero id 1 GaiLun
			local cid = 1;
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(cid, card.id);
				if cid == card.id or true == is_fit then
					table.insert(nlist, list[i]);
				end
			end
		elseif 3 == tag then -- hero id 2 RuiWen
			local cid = 2;
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(cid, card.id);
				if cid == card.id or true == is_fit then
					table.insert(nlist, list[i]);
				end
			end
		elseif 4 == tag then -- hero id 5 ZhouSi
			local cid = 5;
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(cid, card.id);
				if cid == card.id or true == is_fit then
					table.insert(nlist, list[i]);
				end
			end
		elseif 5 == tag then -- hero id 6 LaiLi
			local cid = 6;
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(cid, card.id);
				if cid == card.id or true == is_fit then
					table.insert(nlist, list[i]);
				end
			end
		elseif 6 == tag then -- hero id 8 SuoNa
			local cid = 8;
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(cid, card.id);
				if cid == card.id or true == is_fit then
					table.insert(nlist, list[i]);
				end
			end
		elseif 7 == tag then -- hero id 11 TeLangDeEr
			local cid = 11;
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(cid, card.id);
				if cid == card.id or true == is_fit then
					table.insert(nlist, list[i]);
				end
			end
		elseif 8 == tag then -- hero id 15 AnNi
			local cid = 15;
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(cid, card.id);
				if cid == card.id or true == is_fit then
					table.insert(nlist, list[i]);
				end
			end
		end
		self.list = nlist;
		self.list_phero = self.list;
		return self.list;
	end,

	syn_type_list = function(self, new_index)
		if self.kind == self.KIND_BUY then
			new_index = (new_index or self.in_type_buy) or 1;
		else
			new_index = (new_index or self.in_type_sell) or 1;
		end
		local nlist = {};
		local list = self.list_phero or self.list;
		local info = self.list_pick_type[new_index];
		local tag = info.tag;
		if 1 == tag then -- all kind of type
			for i = 1, #list do
				table.insert(nlist, list[i]);
			end
		elseif 2 == tag then -- hero 
			for i = 1, #list do
				local card = list[i].card;
				if HERO == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 3 == tag then -- attach 
			for i = 1, #list do
				local card = list[i].card;
				if ATTACH == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 4 == tag then -- ability 
			for i = 1, #list do
				local card = list[i].card;
				if ABILITY == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 5 == tag then -- ally 
			for i = 1, #list do
				local card = list[i].card;
				if ALLY == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 6 == tag then -- weapon 
			for i = 1, #list do
				local card = list[i].card;
				if WEAPON == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 7 == tag then -- armor 
			for i = 1, #list do
				local card = list[i].card;
				if ARMOR == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 8 == tag then -- SUPPORT 
			for i = 1, #list do
				local card = list[i].card;
				if SUPPORT == card.ctype or TRAP == card.ctype or ARTIFACT == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		end
		self.list = nlist;
		return self.list;
	end,

	change_hero_type = function(self, new_index)
		new_index = new_index or 1;
		local titles = self.list_pick_hero or {};
		if 0 == titles then return; end

		local info = titles[new_index];
		if nil == info then return; end
		local name = info.title;
		self.label_hero:setString(name);

		if self.kind == self.KIND_BUY then
			if new_index ~= self.in_hero_buy then
				self.offset_buy = nil;
			end
			self.in_hero_buy = new_index;
		else
			if new_index ~= self.in_hero_sell then
				self.offset_sell = nil;
			end
			self.in_hero_sell = new_index;
		end

		local list = self.list or {};
		if 0 == #list then return; end

		self:syn_hero_list(new_index);
		self:reload();
	end,

	change_pick_type = function(self, new_index)
		new_index = new_index or 1;
		local titles = self.list_pick_type or {};
		if 0 == titles then return; end

		local info = titles[new_index];
		if nil == info then return; end
		local name = info.title;
		self.label_type:setString(name);

		if self.kind == self.KIND_BUY then
			if new_index ~= self.in_type_buy then
				self.offset_buy = nil;
			end
			self.in_type_buy = new_index;
		else
			if new_index ~= self.in_type_sell then
				self.offset_sell = nil;
			end
			self.in_type_sell = new_index;
		end

		local list = self.list or {};
		if 0 == #list then return; end

		self:syn_type_list(new_index);
		self:reload();
	end,

	callback_pick_hero = function(index)
		local self = layer_shop;
		self:change_hero_type(index);
		local pindex;
		if self.kind == self.KIND_BUY then
			pindex = self.in_type_buy;
		else
			pindex = self.in_type_sell;
		end
		self:change_pick_type(pindex);
	end,

	pick_hero = function()
		local self = layer_shop;
		local cb = self.callback_pick_hero;
		local list = self.list_pick_hero;
		g_scene:add_layer(ZORDER_LAYER_PICK, layer_pick:create(list, cb));
	end,

	callback_pick_type = function(index)
		local self = layer_shop;
		self:change_pick_type(index);
	end,

	pick_type = function()
		local self = layer_shop;
		local cb = self.callback_pick_type;
		local list = self.list_pick_type;
		g_scene:add_layer(ZORDER_LAYER_PICK, layer_pick:create(list, cb));
	end,

	reload = function(self)
		local offset;
		if true ~= SHOP_PAGE then
			if self.kind == self.KIND_BUY then
				offset = self.offset_buy;
			else -- self.KIND_SELL
				offset = self.offset_sell;
			end
		else
			offset = self.offset;
		end
		self.tableview:reloadData();
		if nil ~= offset then
			self.tableview:setContentOffset(offset, false);
		end
	end,

	callback_reloadlist = function()
		play_tap_3();
		local self = layer_shop;
		g_list_shop = {};
		if true ~= SHOP_PAGE then
			self.list_shop = {};
			self.list = {};
			self.callback_buy(0, self.tap_buy);
			self.offset_buy = nil;
			self.offset_sell = nil;
			-- total 400 cards
			-- each turn get 40 , 10 times
			local p = 40;
			local t = math.ceil(CARD_ARRAY_LIST / p);
			g_list_shop.last_id = t;
			for i = 1, t do
				local cmd = 'shop ' .. (1+p*(i-1)) .. ' ' .. p;
				net_send(cmd);
			end
		else
			self.list = {};
			self.offset = nil;
			-- each page has 4 cards (show 6);
			-- first time get 4 * 3 = 12 cards;
			local cmd = 'shop 1 ' .. layer_shop.PAGE_SIZE;
			net_send(cmd);
		end
	end,

	set_buy_list = function(self)
		self.list = {};
		for i = 1, #self.list_shop do
			local info = self.list_shop[i];
			table.insert(self.list, info);
		end
		self:change_hero_type(self.in_hero_buy);
		self:change_pick_type(self.in_type_buy);
	end,

	set_sell_list = function(self)
		self.list = {};
		for i = 1, #self.list_shop do
			local info = self.list_shop[i];
			local count = self:is_has_card(info.card.id);
			if count > 0 then
				table.insert(self.list, info);
			end
		end
		self:change_hero_type(self.in_hero_sell);
		self:change_pick_type(self.in_type_sell);
	end,

	callback_buy = function(tag, sender)
		play_tap_3();
		local self = layer_shop;
		--local toggle = tolua.cast(sender, "CCMenuItemToggle");
		self.kind = self.KIND_BUY;
		local index = self.tap_sell:getSelectedIndex();
		if 0 == index then
			self.tap_buy:setSelectedIndex(1);
			return;
		end
		self.tap_buy:setSelectedIndex(1);
		self.tap_sell:setSelectedIndex(0);
		if true ~= SHOP_PAGE then
			self:set_buy_list();
		else
			self:reload();
		end
	end,

	callback_sell = function(tag, sender)
		play_tap_3();
		local self = layer_shop;
		if g_euser.level < 10 then
			show_msg('10级开启');
			self.tap_sell:setSelectedIndex(0);
			return;
		end
		--local toggle = tolua.cast(sender, "CCMenuItemToggle");
		self.kind = self.KIND_SELL;
		local index = self.tap_buy:getSelectedIndex();
		if 0 == index then
			self.tap_sell:setSelectedIndex(1);
			return;
		end
		self.tap_sell:setSelectedIndex(1);
		self.tap_buy:setSelectedIndex(0);
		if true ~= SHOP_PAGE then
			self:set_sell_list();
		end
		self:reload();
	end,

	add_to_list = function(self, list, last_id)
		--print('last_id: ', last_id);
		if true ~= SHOP_PAGE then
			self.list_shop = self.list_shop or {};
			if #self.list_shop > 0 then
				return;
			end
			self.list_pick_hero = { { tag = 1, title = '所有英雄' } };
			for i = 1, #list do
				local info = list[i];
				table.insert(self.list_shop, info);
				if info.card.ctype == HERO then
					local tag = info.card.id;
					local title = info.card.name;
					table.insert(self.list_pick_hero, {tag=i+1, title=title});
				end
			end
			if self.kind == self.KIND_BUY then
				self:set_buy_list();
				--self:reload();
			else
				self.callback_buy(0, self.tap_buy);
			end
			return;
		end
		self.list = self.list or {};
		self.last_id = last_id;
		if 0 == #list then
			--self.last_id = -1; -- -1 means don't need to send requst again
			if -1 == self.last_id then
				return;
			end
			local card_id = self.last_id + 1;
			local cmd = 'shop ' .. card_id .. ' ' .. self.PAGE_SIZE;
			net_send(cmd);
			return;
		end
		if 0 < #self.list then
			local m = self.list[#self.list];
			if true == m.flag_more_cell then
				table.remove(self.list, #self.list);
			end
			m = self.list[#self.list];
			if true == m.flag_more_cell then
				table.remove(self.list, #self.list);
			end
		end
		for i = 1, #list do
			table.insert(self.list, list[i]);
		end
		if self.PAGE_SIZE == #list then
			local hlen = (#self.list)%2;
			local more_cell = { flag_more_cell = true };
			table.insert(self.list, more_cell);
			if 1 == hlen then
				more_cell = { flag_more_cell = true };
				table.insert(self.list, more_cell);
			end
		end
	end,

	back = function()
		play_tap_1();
		g_scene:map();
	end,

	is_has_card = function(self, cid)
		for i = 1, #self.my_cards do
			local info = self.my_cards[i];
			if info.cid == cid and info.count >= 0 then
				return info.count;
			end
		end
		return 0;
	end,

	update_my_cards = function(self, cid, count)
		for i = 1, #self.my_cards do
			local info = self.my_cards[i];
			local mid = info.cid;
			if mid == cid then
				info.count = info.count + count;
				if 0 >= info.count then
					table.remove(self.my_cards, i);
				end
				if self.kind == self.KIND_BUY then
					self:set_buy_list();
				else -- self.kind == self.KIND_SELL
					self:set_sell_list();
				end
				--self:reload();
				return;
			end
		end
		table.insert(self.my_cards, { cid = cid, count = count });
		if self.kind == self.KIND_BUY then
			self:set_buy_list();
		else -- self.kind == self.KIND_SELL
			self:set_sell_list();
		end
		--self:reload();
	end,

	get_more = function()
		local self = layer_shop;
		local card_id = self.last_id + 1;
		local cmd = 'shop ' .. card_id .. ' ' .. self.PAGE_SIZE;
		net_send(cmd);
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_shop;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return math.ceil(#(self.list or {})/2);
		elseif "scrollViewDidScroll" == event then
			local len = math.ceil(#self.list / 2);
			local offset = view:getContentOffset();
			if true ~= SHOP_PAGE then
				if self.kind == self.KIND_BUY then
					self.offset_buy = offset;
				else -- self.KIND_SELL
					self.offset_sell = offset;
				end
			else
				self.offset = offset;
			end
			util.handle_arrows(self.clarrow, self.crarrow, len, self.cwidth, self.twidth, offset);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			local index = idx*2 + 1;
			if 2 == self.side then -- down
				index = index + 1;
			elseif 1 == self.side then -- up
			else
				return;
			end
			local info = self.list[index];
			if nil == info then
				return;
			end
			if true == SHOP_PAGE then
				if true == info.flag_more_cell then
					return;
				end
			end
			info.kind = self.kind;
			g_scene:add_layer(ZORDER_LAYER_SHOPPOP, layer_shoppop:create(info));
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local index = idx*2 + 1;
			if true == SHOP_PAGE and true == self.list[index].flag_more_cell then
				local items = {};

				add_item_1(items, '更多', nil, 20, self.get_more,ANCHOR_CENTER_CENTER,pos);

				util.add_menu(cell, items, 1);
				return cell;
			end
			local size;
			for i = index, index+1 do
				local info = self.list[i];
				if nil == info or true == info.flag_more_cell then
					break;
				end
				local card = clone(info.card);
				local basey = 0;
				if i % 2 == 0 then
					basey = height/2;
				end
				local s, d; -- sprite, data
				local d = gui_get_data('card', GUI_SHOP, ANCHOR_DOWN);
				r = self.r_table;
				local offsety = r.offsety;
				local offset = -r.y-basey+offsety/2;
				local scale = (d.height + offsety/2) / CARD_SIZE.height;
				local pos = cc.p(width/2, d.y+offset+CARD_SIZE.height*scale/2);
				local cinfo = object_card:new(cell, card, nil, nil, pos, 0, scale, STYPE_VER_1);
				local sprite = cinfo:get_front();
				self.list[i].info = cinfo;
				self.list[i].sprite = sprite;

				local gold, crystal, path;
				if self.kind == self.KIND_BUY then
					gold = math.abs(info.c_buygold);
					crystal = math.abs(info.c_buycrystal);
				else -- self.KIND_SELL
					gold = info.c_sellgold;
					crystal = info.c_sellcrystal;
				end
				self.list[i].gold = gold;
				self.list[i].crystal = crystal;
				path = util.get_path(FNT_1);
				local gapy = 10 * sprite:getScale();
				scale = 0;
				if gold > 0 then
					s, d = gui_add_sprite(cell, 'bg_gold', GUI_SHOP, ANCHOR_DOWN);
					s:setPosition(cc.p(d.x-r.x, d.y+offset));
					local w = width/s:getContentSize().width;
					local h = d.height/s:getContentSize().height;
					if w > h then
						scale = h;
					else
						scale = w;
					end
					s:setScale(scale);
					s, d = gui_add_sprite(cell, 'icon_gold',GUI_SHOP,ANCHOR_DOWN);
					s:setPosition(cc.p(d.x-r.x, d.y+offset));
					s:setScale(scale);

					s, d = gui_add_labelbmf(cell, gold, path,'num_gold',GUI_SHOP,ANCHOR_DOWN);
					s:setPosition(cc.p(d.x-r.x, d.y+offset));
					s:setScale(scale);
				end
				if crystal > 0 then
					s, d = gui_add_sprite(cell,'bg_crystal',GUI_SHOP,ANCHOR_DOWN);
					s:setPosition(cc.p(d.x-r.x, d.y+offset));
					if 0 == scale then
						local w = width/s:getContentSize().width;
						local h = d.height/s:getContentSize().height;
						if w > h then
							scale = h;
						else
							scale = w;
						end
					end
					s:setScale(scale);
					s,d=gui_add_sprite(cell,'icon_crystal',GUI_SHOP,ANCHOR_DOWN);
					s:setPosition(cc.p(d.x-r.x, d.y+offset));
					s:setScale(scale);
				
					s, d = gui_add_labelbmf(cell, crystal, path,'num_crystal',GUI_SHOP,ANCHOR_DOWN);
					s:setPosition(cc.p(d.x-r.x, d.y+offset));
					s:setScale(scale);
				end

				local count = self:is_has_card(cinfo.card.id);
				self.list[i].count = count;
				path = util.get_path('font_deck_num.fnt');
				pos = cc.p(width/4*3, height/4*3-basey+10);
				count = '*' .. count;
				s=util.add_labelbmf(cell,count,path,pos,ANCHOR_CENTER_CENTER,100);
				s:setScale(scale);
			end
			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_shop;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.back();
		end
	end,

	onTouchBegan = function (self, x, y)
		if y > self.line then
			self.side = 1; -- up
		else
			self.side = 2; -- down
		end
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
	end,
	
	onTouchEnded = function(self, x, y)
		--[[
		if -1 == self.last_id then
			return;
		end
		local len = #(self.list or {});
		if 0 == len then
			return;
		end
		len = math.ceil(len / 2);
		local offset = self.tableview:getContentOffset();
		local line = math.floor(self.cwidth * (len-3) - self.twidth);
		if offset.x + line <= 0 then
			local card_id = self.last_id + 1;
			local cmd = 'shop ' .. card_id .. ' ' .. self.PAGE_SIZE;
			net_send(cmd);
		end
		]]--
	end,

} -- layer_shop end

layer_shoppop = {
	name = 'layer_shoppop',
	layer = nil,
	list_hero = nil,
	data = nil,
	info = nil,	
	oinfo = nil,
	t_gold = nil,
	t_crystal = nil,
	rect = nil,
	label_count = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list_hero = nil;
		self.data = nil;
		self.info = nil;
		self.oinfo = nil;
		self.t_gold = nil;
		self.t_crystal = nil;
		self.rect = nil;
		self.label_count = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, data)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_SHOPPOP, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 120));
		local list_card = c_str_array_2(g_euser.all_str);	
		self.list_hero = {};
		for i = 1, #list_card do
			local cid = list_card[i].cid;
			if cid > 20 then
				break;
			end
			table.insert(self.list_hero, cid);
		end
		self.data = data;
		local info = data.info;
		self.oinfo = info;
		local f = info.frame;
		local scale = get_card_scale(f.width, f.height, CARD_SIZE);
		self.info = info:copy(self.layer, STYPE_VER_1, nil, scale, nil);

		local items = {};
		local item;

		if nil ~= layer_shop.layer then
			local sprite = self.info:get_sprite();
			local path = util.get_path('font_deck_num.fnt');
			local pos = cc.p(CARD_SIZE.width/2 + 100, CARD_SIZE.height/2 + 20);
			local label = util.add_labelbmf(sprite, '', path, pos, ANCHOR_CENTER_CENTER, 100);
			label:setScale(2);
			self.label_count = label;
			self:update_count();
		end

		util.add_menu(self.layer, items, data.zorder);

		self:show(data.count);
		
		return self.layer, self.name;
	end, 

	back = function()
		play_tap_1();
		local self = layer_shoppop;
		self:remove();
	end,

	update_count = function(self)
		if nil == self.layer then return; end
		if nil == self.label_count then return; end
		local count = layer_shop:is_has_card(self.info.card.id);
		count = '*' .. count;
		self.label_count:setString(count);
	end,

	show = function(self, count)
		local layer = self.layer;
		local info = self.data;
		local kind = info.kind;

		local d1 = gui_get_data('p_bg', GUI_SHOP, ANCHOR_DOWN);
		local d2 = gui_get_data('p_bg', GUI_SHOP, ANCHOR_UP);
		local offsetheight = d2.y-d1.y;
		local sprite, data;
		sprite, data = gui_add_sprite(self.layer,'p_bg',GUI_SHOP,ANCHOR_DOWN,nil, offsetheight);
		self.rect = {
			x1 = data.x, x2 = data.x + data.width,
			y1 = data.y, y2 = data.y + data.height,
		};
		gui_add_sprite(self.layer, 'p_bg_title', GUI_SHOP, ANCHOR_UP);
		local can_action = true;
		local str, crystal, gold;
		if kind == layer_shop.KIND_BUY then
			gold = math.abs(info.c_buygold); 
			crystal = math.abs(info.c_buycrystal); 
			str = '购买卡牌';
		else
			gold = math.abs(info.c_sellgold); 
			crystal = math.abs(info.c_sellcrystal); 
			if nil == count or 1 > count then
				can_action = false;
			end
			str = '售卖卡牌';
		end
		gui_add_label(self.layer, str, 30, 'p_t_title', GUI_SHOP, ANCHOR_UP);
		gui_add_sprite(self.layer,'p_bg_card',GUI_SHOP,ANCHOR_DOWN,nil,offsetheight);
		local scale;
		data, scale = gui_get_data('p_card', GUI_SHOP, ANCHOR_DOWN);
		data.height = data.height + offsetheight;
		local sprite = self.info.sprite;
		pos = cc.p(data.x+data.width/2, data.y+data.height/2);
		sprite:setPosition(pos);
		sprite:setScale((data.height-10*scale)/sprite:getContentSize().height);
		self.layer:reorderChild(sprite, data.zorder);

		local path = util.get_path(FNT_1);
		if gold > 0 then
			gui_add_sprite(self.layer, 'p_icon_gold', GUI_SHOP, ANCHOR_DOWN);
			gui_add_labelbmf(self.layer, gold, path, 'p_num_gold',GUI_SHOP,ANCHOR_DOWN);
		end
		if crystal > 0 then
			gui_add_sprite(self.layer, 'p_icon_crystal', GUI_SHOP, ANCHOR_DOWN);
			gui_add_labelbmf(self.layer, crystal, path,'p_num_crystal',GUI_SHOP,ANCHOR_DOWN);
		end

		local items = {};
		local item;

		if true == can_action then
			item, data = gui_add_item(items, 'p_btn_action', GUI_SHOP, self.action, ANCHOR_DOWN);
			if kind == layer_shop.KIND_BUY then
				str = '购买';
				item:setTag(2);
			else
				str = '售卖';
				item:setTag(1);
			end
			gui_add_text_on_sprite(item,str,'p_t_action',GUI_SHOP,ANCHOR_DOWN,30);

			if gold > 0 then
				item, data = gui_add_item(items, 'p_toggle_gold', GUI_SHOP, self.choose_gold, ANCHOR_DOWN);
				self.t_gold = item;
			end

			if crystal > 0 then
				item, data = gui_add_item(items, 'p_toggle_crystal', GUI_SHOP, self.choose_crystal, ANCHOR_DOWN);
				self.t_crystal = item;
			end
		end

		item,data = gui_add_item(items,'p_btn_back',GUI_SHOP,self.back,ANCHOR_UP);

		util.add_menu(self.layer, items, data.zorder);

		if true == can_action then
			if gold > 0 then
				self.choose_gold(0, self.t_gold);
			elseif crystal > 0 then
				self.choose_crystal(0, self.t_crystal);
			end
		end
	end,

	check_has_hero_fit = function(self, cid)
		if cid <= 20 then
			return true;
		end
		for i = 1, #self.list_hero do
			local hid = self.list_hero[i];
			local is_fit = fit_hero_id(hid, cid);
			if true == is_fit then
				return true;
			end
		end
		return false;
	end,

	choose_gold = function(tag, sender)
		play_tap_3();
		local self = layer_shoppop;
		--local toggle = tolua.cast(sender, "CCMenuItemToggle");
		if nil == self.t_crystal then
			self.t_gold:setSelectedIndex(1);
			return;
		end
		local index = self.t_crystal:getSelectedIndex();
		if 0 == index then
			self.t_gold:setSelectedIndex(1);
			return;
		end
		self.t_gold:setSelectedIndex(1);
		self.t_crystal:setSelectedIndex(0);
	end,

	choose_crystal = function(tag, sender)
		play_tap_3();
		local self = layer_shoppop;
		--local toggle = tolua.cast(sender, "CCMenuItemToggle");
		if nil == self.t_gold then
			self.t_crystal:setSelectedIndex(1);
			return;
		end
		local index = self.t_gold:getSelectedIndex();
		if 0 == index then
			self.t_crystal:setSelectedIndex(1);
			return;
		end
		self.t_crystal:setSelectedIndex(1);
		self.t_gold:setSelectedIndex(0);
	end,

	confirm_buy = function()
		local self = layer_shoppop;
		local card_id = self.info.card.id;
		local action = 'buy';
		local card_type = 0; -- 0--card, 1--piece
		local money_type = nil; -- 0--gold, 1--crystal
		if nil ~= self.t_gold then
			local tt = self.t_gold:getSelectedIndex();
			if 1 == tt then
				money_type = 0;
				if 'buy' == action and self.data.gold > g_euser.gold then
					show_err(t_lang("TIP_NOT_ENOUGH_GOLD"));
					return;
				end
			end
		end
		if nil ~= self.t_crystal then
			local tt = self.t_crystal:getSelectedIndex();
			if 1 == tt then
				money_type = 1;
				if 'buy' == action and self.data.crystal > g_euser.crystal then
					show_err(t_lang("TIP_NOT_ENOUGH_CRYSTAL"));
					return;
				end
			end
		end
		if nil == money_type then
			return;
		end
		local count = 1;
		local cmd = string.format("%s %d %d %d %d", action, card_id, card_type, money_type, count);
		net_send(cmd);
		--self.back();
	end,

	action = function(...)
		play_tap_1();
		local self = layer_shoppop;
		local args = {...};
		local tag = args[2]:getTag();
		local card_id = self.info.card.id;
		local card_type = 0; -- 0--card, 1--piece
		local action = nil;
		if 1 == tag then
			action = 'sell';
		elseif 2 == tag then
			if false == self:check_has_hero_fit(card_id) then
				local t = '你没有可使用该卡牌的英雄，确定购买？';
				local cb = self.confirm_buy;
				g_scene:add_layer(ZORDER_LAYER_TIP,layer_tip:create(t,cb));
				return;
			end
			if nil ~= layer_shop.layer then
				local count = layer_shop:is_has_card(card_id);
				if count >= 4 then
					local t = '最多只能放4张相同的牌到牌堆，确定购买？';
					local cb = self.confirm_buy;
					g_scene:add_layer(ZORDER_LAYER_TIP,layer_tip:create(t,cb));
					return;
				end
				if card_id <= 20 and count >= 1 then
					local t = '同款英雄牌有一张便足够了，确定购买？';
					local cb = self.confirm_buy;
					g_scene:add_layer(ZORDER_LAYER_TIP,layer_tip:create(t,cb));
					return;
				end
			end
			action = 'buy';
		else
			--print('xxxx');
			return;
		end
		local money_type = nil; -- 0--gold, 1--crystal
		if nil ~= self.t_gold then
			local tt = self.t_gold:getSelectedIndex();
			if 1 == tt then
				money_type = 0;
				if 'buy' == action and self.data.gold > g_euser.gold then
					show_err(t_lang("TIP_NOT_ENOUGH_GOLD"));
					return;
				end
			end
		end
		if nil ~= self.t_crystal then
			local tt = self.t_crystal:getSelectedIndex();
			if 1 == tt then
				money_type = 1;
				if 'buy' == action and self.data.crystal > g_euser.crystal then
					show_err(t_lang("TIP_NOT_ENOUGH_CRYSTAL"));
					return;
				end
			end
		end
		if nil == money_type then
			return;
		end
		local count = 1;
		local cmd = string.format("%s %d %d %d %d", action, card_id, card_type, money_type, count);
		net_send(cmd);
		--self.back();
	end,

	handler = function(event, x, y)
		local self = layer_shoppop;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function (self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)
		local r = self.rect;
		if nil == r then
			return;
		end
		if x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2 then
			self.back();
		end
	end,
} -- layer_shoppop end

layer_rank = {
	name = 'layer_rank',
	layer = nil,
	list_tab = { -- tab_id, unselected data index, selected data index
		{ LADDER_RATING, 'rate', '积分' }, { LADDER_LEVEL, 'level', '等级' }, 
		{ LADDER_GUILD, 'guild', '公会' }, { LADDER_COLLECT, 'collect', '搜集' }, 
		--{ LADDER_GOLD, 'gold' },
	},
	list = nil,
	list_toggle = nil,
	tableview = nil,
	label_2 = nil,
	label_3 = nil,
	my_rank = nil,
	cwidth = nil,
	cheight = nil,
	bar = nil,
	tap = nil,
	data_cell = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.list_toggle = nil;
		self.tableview = nil;
		self.label_2 = nil;
		self.label_3 = nil;
		self.my_rank = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_RANK, self.handler, true);

		self.list_toggle = {};
		self.list = {};

		-- btn back set in g_scene.deck
		init_bg_for_full_view(self.layer, GUI_RANK, '排行榜');

		local sprite, data, pos, size;
		local d1 = gui_get_data('bg_table', GUI_RANK, ANCHOR_UP);
		local d2 = gui_get_data('bg_table', GUI_RANK, ANCHOR_DOWN);
		local offsety = d1.y - d2.y;
		gui_add_sprite(self.layer, 'bg_table', GUI_RANK, ANCHOR_DOWN,nil,offsety);
		gui_add_sprite(self.layer, 'f_title', GUI_RANK, ANCHOR_UP);
		gui_add_sprite(self.layer, 'line_1', GUI_RANK, ANCHOR_UP);
		gui_add_sprite(self.layer, 'line_2', GUI_RANK, ANCHOR_UP);
		gui_add_label(self.layer, '排名', 23, 'tt1', GUI_RANK, ANCHOR_UP);
		self.label_2 = gui_add_label(self.layer,'',23,'tt2',GUI_RANK,ANCHOR_UP);
		self.label_3 = gui_add_label(self.layer,'',23,'tt3',GUI_RANK,ANCHOR_UP);
		gui_add_sprite(self.layer, 'bg_my_rank', GUI_RANK, ANCHOR_DOWN);
		gui_add_sprite(self.layer, 'bg_num_my_rank', GUI_RANK, ANCHOR_DOWN);
		gui_add_label(self.layer,'我的排名',23,'t_my_rank',GUI_RANK,ANCHOR_DOWN);
		self.my_rank = gui_add_label_ali(self.layer,'',23,'num_my_rank',GUI_RANK,ANCHOR_DOWN, cc.TEXT_ALIGNMENT_CENTER);

		local items = {};
		local item;

		for i = 1, #self.list_tab do
			local info = self.list_tab[i];
			local key = 'tag' .. i;
			item, data = gui_add_item(items, key, GUI_RANK, self.cb_toggle, ANCHOR_UP);
			key = 'tag_text' .. i;
			gui_add_text_outline_on_sprite(item, info[3], key, GUI_RANK, ANCHOR_UP, 30);
			item:setTag(info[1]);
			table.insert(self.list_toggle, item);
		end

		util.add_menu(self.layer, items, data.zorder);

		data = gui_get_data('cell', GUI_RANK, ANCHOR_DOWN);
		self.cwidth = data.width;
		self.cheight = data.height;
		self.data_cell = data;

		data = gui_get_data('table', GUI_RANK, ANCHOR_DOWN);
		size = cc.size(data.width, data.height + offsety);
		pos = cc.p(data.x, data.y);
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, ccp(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+10);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		self:change_tab(LADDER_RATING);
			
		return self.layer, self.name;
	end,

	reload = function(self)
		self.tableview:reloadData();
	end,

	change_tab = function(self, tab)
		for i = 1, #self.list_toggle do
			local toggle = self.list_toggle[i];
			local tag = toggle:getTag();
			if tag ~= tab then
				toggle:setSelectedIndex(0);
			else
				toggle:setSelectedIndex(1);
			end
		end
		local t2, t3;
		if tab == LADDER_RATING then
			t2 = '角色名';
			t3 = '积分';
		elseif tab == LADDER_LEVEL then
			t2 = '角色名';
			t3 = '等级';
		elseif tab == LADDER_GUILD then
			t2 = '公会名';
			t3 = '等级';
		elseif tab == LADDER_COLLECT then
			t2 = '角色名';
			t3 = '收集';
		--[[
		elseif tab == LADDER_GOLD then
			t2 = '';
			t3 = '';
		]]--
		else
			return;
		end
		if nil ~= self.label_2 then
			self.label_2:setString(t2);
		end
		if nil ~= self.label_3 then
			self.label_3:setString(t3);
		end
		local cmd = 'ladder ' .. tab;
		net_send(cmd);
	end,

	cb_toggle = function(tag, sender)
		play_tap_3();
		local self = layer_rank;
		-- self.toggle_info:getSelectedIndex()  0 : off     1 : on
		--sender = tolua.cast(sender, "cc.MenuItemToggle");
		--print('selected item:tag:%d, index:%d', tag, sender:getSelectedIndex());
		self:change_tab(tag);
	end,

	set_list = function(self, list)
		local my_info = list[#list];
		if nil ~= my_info then
			local l = my_info.rank;
			self.my_rank:setString(l);
			table.remove(list, #list);
		end
		self.list = list or {};
		self:reload();
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_rank;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			local info = self.list[idx + 1];
			if tonumber(info.ladder_type) == LADDER_GUILD then
				local gid = info.info_id;
			else
				local d = { eid = info.info_id, icon = info.icon,
							alias = info.name };
				g_scene:add_layer(ZORDER_LAYER_CHATPOP, layer_chatpop:create(d));
			end
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local data = self.data_cell;
			local info = self.list[idx + 1];
			local sprite, data2, str;
			
			gui_add_sprite_on_cell(cell, data, 'line_cell', GUI_RANK,ANCHOR_DOWN);
			gui_add_sprite_on_cell(cell, data, 'bg_rank', GUI_RANK, ANCHOR_DOWN);
			str = info.rank; -- rank
			gui_add_label_on_cell(cell,data,str,25,'num_rank',GUI_RANK,ANCHOR_DOWN);
			str = info.name;
			gui_add_label_on_cell(cell,data,str,20,'name',GUI_RANK,ANCHOR_DOWN);
			local path = util.get_path(FNT_1);
			str = math.floor(info.point);
			gui_add_labelbmf_on_cell(cell,data,str,path,'point',GUI_RANK,ANCHOR_DOWN);

			if tonumber(info.ladder_type) ~= LADDER_GUILD then
				sprite, data2 = gui_add_sprite_on_cell(cell, data, 'icon', GUI_RANK, ANCHOR_DOWN);
				path = get_icon_path(info.icon or 0);
				pos = cc.p(0, 0);
				sprite=util.add_sprite(sprite,path,pos,ANCHOR_LEFT_DOWN,-1);
				sprite:setScaleX(data2.width/sprite:getContentSize().width);
				sprite:setScaleY(data2.height/sprite:getContentSize().height);
			end

			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	back = function()
		play_tap_1();
		g_scene:map();
	end,

	handler = function(event, x, y)
		local self = layer_rank;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.back();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
} -- layer_rank end

layer_forum = { -- start
	name = 'layer_forum',
	layer = nil, 

	cleanup = function(self)
		self.layer = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_FORUM, self.handler, true);
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 200));
		
		return self.layer, self.name;
	end, 

	callback = function(event)
		kdebug("event[%s]", event);
		local self = layer_forum;
		if nil == self.layer then
			return;
		end
		if "back" == event then
			self:remove();
		end
	end,

	handler = function(event, x, y)
		local self = layer_forum;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			play_tap_1();
			self:remove();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)
	end,
} -- layer_forum end

layer_appstorepay = { -- start
	name = 'layer_appstorepay',
	layer = nil, 

	cleanup = function(self)
		self.layer = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_APPSTOREPAY,self.handler,true);
		
		return self.layer, self.name;
	end, 

	callback = function(...)
		local args = {...};
		local event = args[1];
		kdebug("event[%s]", event);
		local self = layer_appstorepay;
		if nil == self.layer then
			return;
		end
		if "back" == event then
			self:remove();
		elseif "receipt" == event then
			print('app store receipt:');	
			local r = args[2];
			print(r);	
			--[[
			show_netloading();
			local xhr = cc.XMLHttpRequest:new();
			xhr.responseType = cc.XMLHTTPREQUEST_RESPONSE_STRING;
			local r = string.format("http://%s:8899/pay_server/order?playerId=%d&serverId=%s&payCode=%s", IP_ADDR, tonumber(g_euser.eid), serverId, payCode);
			xhr:open("GET", r);
			local function callback_xhr()
				hide_netloading();
				local status = "Http Status Code:" .. xhr.statusText;
			end
			hide_netloading();
			xhr:registerScriptHandler(callback_xhr);
			xhr:send();
			]]--
		end
	end,

	handler = function(event, x, y)
		local self = layer_appstorepay;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)
	end,
} -- layer_appstorepay end

layer_gm = { -- start
	name = 'layer_gm',
	layer = nil, 
	list = nil,
	cwidth = nil,
	cheight = nil,
	tableview = nil,
	bar = nil,
	tap = nil,
	eid = nil,
	alias = nil,
	data_cell = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.tableview = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_ANIM, self.handler, false);

		self.list = {
			-- tag, title, number
			{ tag = 1, t = "客服微信", n = "1918230995", },
			{ tag = 2, t = "客服QQ", n = "1918230995", },
			{ tag = 3, t = "QQ交流群1", n = "90196112", },
		};
		-- btn back set in g_scene.deck
		init_bg_for_full_view(self.layer, GUI_GM, '联系客服');
		local d1 = gui_get_data('table', GUI_GM, ANCHOR_UP);
		local d2 = gui_get_data('table', GUI_GM, ANCHOR_DOWN);
		local offsety = d1.y - d2.y;
		local sprite, data;
		data = gui_get_data('cell', GUI_GM, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height+10;
		data = gui_get_data('table', GUI_GM, ANCHOR_DOWN);
		size = cc.size(data.width, data.height+offsety);
		pos = cc.p(data.x, data.y);
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		gui_add_sprite(self.layer, 'bg_intro', GUI_GM,ANCHOR_DOWN);
		local str = '客服工作时间\n周一至周五 10:00 ~ 18:00\n\n请亲们加客服微信1918230995，以便及时了解更新更快的游戏通知';
		gui_add_label(self.layer, str, 22, 'intro', GUI_GM, ANCHOR_DOWN);

		return self.layer, self.name;
	end, 

	back = function()
		play_tap_1();
		g_scene:map();
	end,

	action = function(...)
		play_tap_1();
		local self = layer_gm;
		local args = {...};
		local tag = args[2]:getTag();
		local info = self.list[tag];
		local text = info.n;
		util.text_to_pasteboard(text);
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_gm;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local info = self.list[idx + 1];
			local tag = info.tag;
			local tip = info.t;
			local number = info.n;
			local data2, sprite, path, pos, size, str;

			str = tip;
			gui_add_label_on_cell(cell,data,str,28,'tip',GUI_GM,ANCHOR_DOWN);
			str = number;
			gui_add_label_on_cell(cell,data,str,28,'number',GUI_GM,ANCHOR_DOWN);

			local items = {};
			local item;

			item, data2 = gui_add_item_on_cell(items, data, 'btn_action', GUI_GM, self.action, ANCHOR_DOWN);
			item:setTag(tag);
			gui_add_text_on_sprite(item,'复制','t_action',GUI_GM,ANCHOR_UP,30);

			util.add_menu(cell, items, data2.zorder);

			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_gm;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.back();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)
	end,

} -- layer_gm end

layer_service = {
	name = 'layer_service',
	layer = nil,
	list = nil,
	tableview = nil,
	rect = nil,
	cwidth = nil,
	cheight = nil,
	bar = nil,
	tap = nil,
	data_cell = nil,
	icon_up = nil,
	icon_down = nil,
	theight = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.tableview = nil;
		self.rect = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell = nil;
		self.icon_up = nil;
		self.icon_down = nil;
		self.theight = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_SERVICE, self.handler, true);

		self.list = {};
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));

		local data;
		local offsetheight, sprite, rect = init_bg_for_view(self.layer, GUI_SERVICE, '对战次数每日0点刷新', self.back);
		self.rect = rect;

		local tip = "1.金币场与钻石场生命5点以上投降视为强退\n2.强退方受1次机会额外惩罚\n3.被强退方退回入场费与次数";
		gui_add_label(self.layer, tip, 22, 'tip', GUI_SERVICE, ANCHOR_DOWN);

		data = gui_get_data('cell', GUI_SERVICE, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height + 10;
		data = gui_get_data('table', GUI_SERVICE, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		self.theight = size.height;
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos,cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		pos = cc.p(data.x+data.width, data.y+size.height);
		self.icon_up = add_scroll_icons(self.layer, pos, true);
		self.icon_up:setVisible(false);
		pos = cc.p(data.x+data.width, data.y);
		self.icon_down = add_scroll_icons(self.layer, pos, false);
		self.icon_down:setVisible(false);

		return self.layer, self.name;
	end,

	back = function()
		play_tap_1();
		local self = layer_service;
		self:remove();
	end,

	set_show = function(self, is_show)
		if nil == layer_service.layer then return; end
		layer_service.layer:setVisible(is_show);
	end,

	reload = function(self)
		self.tableview:reloadData();
	end,

	add_info = function(self, data)
		self.list = {};
--		local open_flag = 1;
--		if open_flag == data.pve_status then
			table.insert(self.list, { bg = "bg_68.png", tag = GAME_SOLO_GOLD, 
						data = { 
							time_left = data.pve_time, 
							reward = data.pve_gold_reward, 
							reward_type = 'gold', 
							fee = data.pve_gold_cost, 
							fee_type = 'gold', 
						}, 
						flag = data.pve_status
			});
--		end
--		if open_flag == data.pvp_gold_status then
			table.insert(self.list, { bg = "bg_69.png", tag = GAME_VS_GOLD, 
						data = { 
							time_left = data.pvp_gold_time, 
							reward = data.pvp_gold_reward, 
							reward_type = 'gold', 
							fee = data.pvp_gold_cost, 
							fee_type = 'gold', 
							start_time = data.pvp_gold_start_time,
							end_time = data.pvp_gold_end_time,
						}, 
						flag = data.pvp_gold_status
			});
--		end
--		if open_flag == data.pvp_crystal_status then
			table.insert(self.list, { bg = "bg_70.png", tag = GAME_VS_CRYSTAL, 
						data = { 
							time_left = data.pvp_crystal_time, 
							reward = data.pvp_crystal_reward, 
							reward_type = 'crystal', 
							fee = data.pvp_crystal_cost, 
							fee_type = 'crystal', 
							start_time = data.pvp_crystal_start_time,
							end_time = data.pvp_crystal_end_time,
						}, 
						flag = data.pvp_crystal_status
			});
--		end
--		if open_flag == data.pvp_free_status then
			table.insert(self.list, {
						bg = "bg_71.png", tag = GAME_VS_FREE, data = {
							reward = data.pvp_free_reward, 
							reward_type = 'gold', 
							lose = data.pvp_free_lose, 
							lose_type = 'gold', 
						},
						flag = data.pvp_free_status
			});
--		end
--		if open_flag == data.pve_free_status then
			table.insert(self.list, {
						bg = "bg_72.png", tag = GAME_SOLO_FREE, data = {
							reward = data.pve_free_reward, 
							reward_type = 'gold', 
							lose = data.pve_free_lose, 
							lose_type = 'gold', 
						},
						flag = data.pve_free_status
			});
--		end
		self:reload();
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_service;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			update_scroll_icon(self.icon_up, self.icon_down, view, self.theight);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			play_tap_3();
			local cell = args[3];
			local idx = cell:getIdx();
			local info = self.list[idx + 1];
--			print('xxx: ', info.data.time_left, info.tag);
			local open_flag = 1;
			if open_flag ~= info.flag then
				show_msg("未开放");
				return;
			end
			if nil ~= info.data.time_left and info.data.time_left <= 0 then
				show_msg("今日挑战次数已经用完");
				return;
			end
			local fee_type = info.data.fee_type;
			local fee = info.data.fee or 0;
			if fee_type == 'gold' then
				if fee > g_euser.gold then
					show_msg(t_lang("TIP_NOT_ENOUGH_GOLD"));
					return;
				end
			elseif fee_type == 'crystal' then
				if fee > g_euser.crystal then
					show_money_tip(t_lang("TIP_NOT_ENOUGH_CRYSTAL"));
					return;
				end
			end
			local tag = info.tag;
			if tag==GAME_VS_GOLD or tag==GAME_VS_CRYSTAL or tag==GAME_VS_FREE then
				self:set_show(false);
				local layer, name = layer_quick:create();
				g_scene:add_layer(ZORDER_LAYER_QUICK, layer, name, true);
				layer_quick:start_waiting();
			end
			local cmd = string.format("fight %d", tag);
			net_send(cmd);
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local data = self.data_cell;
			local info = self.list[idx + 1];
			data.fname1 = info.bg;
			gui_add_cell_bg(cell, data);
			local ttt = info.data;
			local time_left = ttt.time_left;
			local str;
			local sprite, data2;
			if nil ~= time_left then
				str = time_left;
				--path = util.get_path(FNT_1);
				local path = util.get_path('font_deck_num.fnt');
				gui_add_labelbmf_on_cell(cell,data,str,path,'num_left',GUI_SERVICE,ANCHOR_DOWN);
			end

			if nil ~= ttt.reward then
				str = '胜利奖励';
				local tip1,tips1_data = gui_add_label_on_cell(cell,data,str,25,'t_reward',GUI_SERVICE,ANCHOR_DOWN);
				path = util.get_path(FNT_1);
				str = ttt.reward or 0;
				local tip2, tips2_data = gui_add_labelbmf_on_cell(cell,data,str,path,'n_reward',GUI_SERVICE,ANCHOR_DOWN);
				sprite, data2 = gui_add_sprite_on_cell(cell, data, 'icon_reward', GUI_SERVICE, ANCHOR_DOWN);
				if 'crystal' == ttt.reward_type then
					local path = util.get_path(data2.fname2);
					local tc = cc.Director:getInstance():getTextureCache();
					local texture = tc:addImage(path);
					if nil ~= texture then 
						sprite:setTexture(texture);
					end
				end

				if info.tag == GAME_VS_FREE or info.tag == GAME_SOLO_FREE then
					tip1:setPositionY(tips1_data.y - tips1_data.height);
					tip2:setPositionY(tips2_data.y - tips2_data.height);
					sprite:setPositionY(data2.y - tips1_data.height);
				end
			end

			if nil ~= ttt.fee then
				str = '入场费';
				gui_add_label_on_cell(cell,data,str,25,'t_fee',GUI_SERVICE,ANCHOR_DOWN);
				str = ttt.fee or 0;
				gui_add_labelbmf_on_cell(cell,data,str,path,'n_fee',GUI_SERVICE,ANCHOR_DOWN);
				sprite, data2 = gui_add_sprite_on_cell(cell, data, 'icon_fee', GUI_SERVICE, ANCHOR_DOWN);
				if 'crystal' == ttt.fee_type then
					local path = util.get_path(data2.fname2);
					local tc = cc.Director:getInstance():getTextureCache();
					local texture = tc:addImage(path);
					if nil ~= texture then 
						sprite:setTexture(texture);
					end
				end
			end

			local s_time = ttt.start_time;
			local e_time = ttt.end_time;
			if nil ~= s_time and nil ~= e_time and s_time ~= e_time then
				local ts = os.date("*t", s_time);
				local te = os.date("*t", e_time);
				str = string.format("开放时间:\n%02d:%02d:%02d ~ %02d:%02d:%02d", ts.hour, ts.min, ts.sec, te.hour, te.min, te.sec);
				util.add_labeloutline(cell, str, nil, 19, cc.p(10, 10), util.c4b_black, util.c4b_white, 2, ANCHOR_LEFT_DOWN, 60);
			end
			
			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_service;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.back();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		local r = self.rect;
		if nil == r then
			return;
		end
		if x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2 then
			self.back();
		end
	end,
} -- layer_service end

layer_lottery = {
	name = 'layer_lottery',
	LTYPE_ONE_GOLD = 1,
	LTYPE_TEN_GOLD = 2,
	LTYPE_ONE_CRYSTAL = 3,
	LTYPE_TEN_CRYSTAL = 4,
	layer = nil,
	rect = nil,
	list = nil,
	tableview = nil,
	cwidth = nil,
	cheight = nil,
	theight = nil,
	bar = nil,
	tap = nil,
	data_cell = nil,
	last_ltype = nil,
	last_times = nil,
	last_fee = nil,

	cleanup = function(self)
		self.layer = nil;
		self.rect = nil;
		self.list = nil;
		self.tableview = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.theight = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell = nil;
		self.last_ltype = nil;
		self.last_times = nil;
		self.last_fee = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, one_gold, ten_gold, one_crystal, ten_crystal)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_LOTTERY, self.handler, true);

		self.list = {};
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));

		local data;
		local offsetheight, sprite, rect = init_bg_for_view(self.layer, GUI_LOTTERY, '抽卡', self.back);
		self.rect = rect;

		data = gui_get_data('cell', GUI_LOTTERY, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height + 10;
		data = gui_get_data('table', GUI_LOTTERY, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		self.theight = size.height;
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos,cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		return self.layer, self.name;
	end,

	back = function()
		play_tap_1();
		local self = layer_lottery;
		self:remove();
	end,

	reload = function(self)
		self.tableview:reloadData();
	end,

	add_price = function(self, one_gold, ten_gold, one_crystal, ten_crystal)
		self.list = {};
		table.insert(self.list, { bg = "bg_choujiang1.png", tag = self.LTYPE_ONE_GOLD, tip = "产出3星或者以下卡牌,少几率出现4星卡牌", fee = one_gold, is_gold = true });
		table.insert(self.list, { bg = "bg_choujiang2.png", tag = self.LTYPE_ONE_CRYSTAL, tip = "产出2星或者以上卡牌,少几率出现5星卡牌", fee = one_crystal, is_gold = false });
		table.insert(self.list, { bg = "bg_choujiang3.png", tag = self.LTYPE_TEN_CRYSTAL, tip = "产出2星或者以上卡牌,至少出现1张5星卡牌", fee = ten_crystal, is_gold = false });
		self:reload();
	end,

	do_again = function(self)
		local ltype = self.last_ltype;
		local times = self.last_times;
		local fee = self.last_fee;
		if nil == ltype or nil == times or nil == fee then return; end
		if ltype == 1 and fee > g_euser.gold then
			show_msg(t_lang("TIP_NOT_ENOUGH_GOLD"));
			return;
		elseif ltype == 2 and fee > g_euser.crystal then
			show_crystal_tip();
			return;
		end
		local cmd = string.format("lottery %d %d", ltype, times);
		net_send(cmd);
	end,

	do_it = function(self, index)
		local info = self.list[index];
		if nil == info then return; end
		local tag = info.tag;
		local ltype = 0;
		local times = 0;
		local fee = 0;
		if tag == self.LTYPE_ONE_GOLD or tag == self.LTYPE_TEN_GOLD then
			ltype = 1;
			times = 1;
			fee = info.fee or 0;
			if fee > g_euser.gold then
				show_msg(t_lang("TIP_NOT_ENOUGH_GOLD"));
				return;
			end
			if tag == self.LTYPE_TEN_GOLD then
				times = 10;
			end
		elseif tag==self.LTYPE_ONE_CRYSTAL or tag==self.LTYPE_TEN_CRYSTAL then
			ltype = 2;
			times = 1;
			fee = info.fee or 0;
			if fee > g_euser.crystal then
				show_crystal_tip();
				return;
			end
			if tag == self.LTYPE_TEN_CRYSTAL then
				times = 10;
			end
		else
			return;
		end
		self.last_ltype = ltype;
		self.last_times = times;
		self.last_fee = fee;
		self:do_again();
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_lottery;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			play_tap_3();
			local cell = args[3];
			local idx = cell:getIdx();
			self:do_it(idx+1);
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local data = self.data_cell;
			local info = self.list[idx + 1];
			data.fname1 = info.bg;
			gui_add_cell_bg(cell, data);

			local path, str, sprite, data2;
			str = info.tip or '';
			gui_add_label_on_cell(cell,data,str,25,'t_fee',GUI_LOTTERY,ANCHOR_DOWN);

			path = util.get_path(FNT_1);
			str = info.fee or 0;
			sprite, data2 = gui_add_labelbmf_on_cell(cell,data,str,path,'n_fee',GUI_LOTTERY,ANCHOR_DOWN);
			sprite:setAnchorPoint(ANCHOR_RIGHT_DOWN);
			sprite:setPositionX(data2.x+data2.width);
			sprite, data2 = gui_add_sprite_on_cell(cell, data, 'icon_fee', GUI_LOTTERY, ANCHOR_DOWN);
			if true ~= info.is_gold then
				local path = util.get_path(data2.fname2);
				local tc = cc.Director:getInstance():getTextureCache();
				local texture = tc:addImage(path);
				if nil ~= texture then 
					sprite:setTexture(texture);
				end
			end
			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_lottery;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.back();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		local r = self.rect;
		if nil == r then
			return;
		end
		if x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2 then
			self.back();
		end
	end,
} -- layer_lottery end

layer_tower = {
	name = 'layer_tower',
	layer = nil,
	rect = nil,
	kind = nil,
	KIND_TOWER = 1,
	KIND_RANK = 2,
	KIND_SHOP = 3,
	tap_tower = nil,
	tap_rank = nil,
	tap_shop = nil,

	cleanup = function(self)
		self.layer = nil;
		self.rect = nil;
		self.tap_tower = nil;
		self.tap_rank = nil;
		self.tap_shop = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_TOWER, self.handler, true);



		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));
		local sprite, data;
		local offsetheight, bg, rect = init_bg_for_view(self.layer, GUI_TOWER, '无限塔', self.back);
		self.rect = rect;

		-- add tabs
		local items = {};
		local item;

		item, data = gui_add_item(items, 'tab_tower', GUI_TOWER, self.callback_tower, ANCHOR_UP);
		gui_add_text_outline_on_sprite(item, "爬塔", 'lb_tab_tower', GUI_TOWER, ANCHOR_UP, 30);
		self.tap_tower = item;

		item, data = gui_add_item(items, 'tab_rank', GUI_TOWER, self.callback_rank, ANCHOR_UP);
		gui_add_text_outline_on_sprite(item, "排行榜", 'lb_tab_rank', GUI_TOWER, ANCHOR_UP, 30);
		self.tap_rank = item;

		item, data = gui_add_item(items, 'tab_shop', GUI_TOWER, self.callback_shop, ANCHOR_UP);
		gui_add_text_outline_on_sprite(item, "战功商店", 'lb_tab_shop', GUI_TOWER, ANCHOR_UP, 30);
		self.tap_shop = item;

		util.add_menu(self.layer, items, data.zorder);


		local d1 = gui_get_data('p_bg_card', GUI_TOWER, ANCHOR_UP);
		local d2 = gui_get_data('p_bg_card', GUI_TOWER, ANCHOR_DOWN);
		local offsety = d1.y - d2.y;
		gui_add_sprite(self.layer, 'p_bg_card', GUI_TOWER,ANCHOR_DOWN,nil,offsety);

--		self.callback_tower(0, self.tap_tower);


		return self.layer, self.name;
	end,

	back = function()
		play_tap_1();
		local self = layer_tower;
		self:remove();
	end,

	show_tower_info = function()
		
	end,

	show_rank_info = function()
		
	end,

	show_shop_info = function()
		
	end,

	callback_tower = function()
		play_tap_3();
		local self = layer_tower;
		--local toggle = tolua.cast(sender, "CCMenuItemToggle");
		self.kind = self.KIND_TOWER;
		local index = self.tap_tower:getSelectedIndex();
		if 0 == index then
			self.tap_tower:setSelectedIndex(1);
			return;
		end
		self.tap_tower:setSelectedIndex(1);
		self.tap_rank:setSelectedIndex(0);
		self.tap_shop:setSelectedIndex(0);

		self:show_tower_info();
	end,

	callback_rank = function()
		play_tap_3();
		local self = layer_tower;
		--local toggle = tolua.cast(sender, "CCMenuItemToggle");
		self.kind = self.KIND_RANK;
		local index = self.tap_rank:getSelectedIndex();
		if 0 == index then
			self.tap_rank:setSelectedIndex(1);
			return;
		end
		self.tap_tower:setSelectedIndex(0);
		self.tap_rank:setSelectedIndex(1);
		self.tap_shop:setSelectedIndex(0);

		self:show_rank_info();
	end,

	callback_shop = function()
		play_tap_3();
		local self = layer_tower;
		--local toggle = tolua.cast(sender, "CCMenuItemToggle");
		self.kind = self.KIND_SHOP;
		local index = self.tap_shop:getSelectedIndex();
		if 0 == index then
			self.tap_shop:setSelectedIndex(1);
			return;
		end
		self.tap_tower:setSelectedIndex(0);
		self.tap_rank:setSelectedIndex(0);
		self.tap_shop:setSelectedIndex(1);

		self:show_shop_info();
	end,

	handler = function(event, x, y)
		local self = layer_tower;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.back();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		local r = self.rect;
		if nil == r then
			return;
		end
		if x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2 then
			self.back();
		end
	end,
} -- layer_tower end

layer_notice = {
	name = 'layer_notice',
	layer = nil,
	list = nil,
	tableview = nil,
	btn_top = nil,
	rect = nil,
	cwidth = nil,
	cheight = nil,
	bar = nil,
	tap = nil,
	data_cell = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.tableview = nil;
		self.btn_top = nil;
		self.rect = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_NOTICE, self.handler, true);

		self.list = {};
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));

		local data;
		local offsetheight, sprite, rect = init_bg_for_view(self.layer, GUI_NOTICE, '今日公告', self.back);
		self.rect = rect;

		data = gui_get_data('cell', GUI_NOTICE, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height + 10;
		data = gui_get_data('table', GUI_NOTICE, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos,cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		return self.layer, self.name;
	end,

	back = function()
		play_tap_1();
		local self = layer_notice;
		self:remove();
	end,

	reload = function(self)
		self.tableview:reloadData();
	end,

	add_list = function(self, list)
		self.list = list or {};
		self:reload();
	end,

	set_detail = function(self, t, detail)
		if nil == self or nil == self.list then
			return;
		end
		local title = '';
		for i = 1, #self.list do
			local list = self.list[i];
			if list.t == t then
				list.height = nil;
				list.detail = detail;
				list.is_on = true;
				list.cheight = nil;
				title = list.title or '';
			end
		end
		g_scene:add_layer(ZORDER_LAYER_TEXT, layer_text:create(title, detail));
	end,

	return_top = function()
		local self = layer_notice;
		if nil == self.tableview then
			return;
		end
		local size = self.tableview:getContentSize();
		--self.tableview:setContentOffset(ccp(0, 0), false);
		self.tableview:setContentOffset(ccp(0, -#self.list*hfix(80)), false);
		self.btn_top:setVisible(false);
	end,

	change_notice = function()
		local self = layer_notice;
	end,

	cb_didbtn = function()
		local self = layer_notice;
		if nil == self.tableview then
			return;
		end
		local t, l = self.tableview:getContentOffset();
		size = self.tableview:getContentSize();
		--if - #self.list * hfix(80) < l then
		if - #self.list * hfix(80) + size.height/2 < l then
			self.btn_top:setVisible(true);
		end
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_notice;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			play_tap_3();
			local cell = args[3];
			local idx = cell:getIdx();
			local info = self.list[idx + 1];
			if nil == info.detail then
				local cmd = 'notice ' .. info.t;
				net_send(cmd);
				return;
			end
			local t = info.title or '';
			local d = info.detail or '';
			g_scene:add_layer(ZORDER_LAYER_TEXT, layer_text:create(t, d));
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local info = self.list[idx + 1];
			local str = info.title;
			gui_add_label_on_cell(cell,data,str,28,'t_title',GUI_NOTICE,ANCHOR_DOWN);
			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_notice;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.back();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		local r = self.rect;
		if nil == r then
			return;
		end
		if x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2 then
			self.back();
		end
	end,
} -- layer_notice end

layer_option = { -- start
	name = 'layer_option',
	layer = nil,
	slider_music = nil,
	slider_effect = nil,

	cleanup = function(self)
		self.layer = nil;
		self.slider_music = nil;
		self.slider_effect = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_OPTION, self.handler, true);

		-- btn back set in g_scene.option
		init_bg_for_full_view(self.layer, GUI_OPTION, '选项');
		gui_add_sprite(self.layer, 'p_music_left', GUI_OPTION, ANCHOR_UP);
		gui_add_sprite(self.layer, 'p_music_right', GUI_OPTION, ANCHOR_UP);
		gui_add_sprite(self.layer, 'p_eff_left', GUI_OPTION, ANCHOR_UP);
		gui_add_sprite(self.layer, 'p_eff_right', GUI_OPTION, ANCHOR_UP);
		gui_add_label_ali(self.layer, '音乐', 22, 't_music', GUI_OPTION, ANCHOR_UP, cc.TEXT_ALIGNMENT_CENTER);
		gui_add_label_ali(self.layer, '音效', 22, 't_eff', GUI_OPTION, ANCHOR_UP, cc.TEXT_ALIGNMENT_CENTER);
		local sprite, data, str;

		str = get_client_version();
		gui_add_label_ali(self.layer, str, 25, 't_game_ver', GUI_OPTION, ANCHOR_DOWN, cc.TEXT_ALIGNMENT_CENTER);

		local items = {};
		local item;

		item, data = gui_add_item(items, 'btn_code', GUI_OPTION, self.enter_code, ANCHOR_DOWN);
		gui_add_text_on_sprite(item, "兑换",'t_code',GUI_OPTION, ANCHOR_DOWN, 30);

		item, data = gui_add_item(items, 'btn_logout', GUI_OPTION, self.logout, ANCHOR_DOWN);
		gui_add_text_on_sprite(item, "登出", 't_logout', GUI_OPTION, ANCHOR_DOWN, 30);

		item, data = gui_add_item(items, 'btn_music_dec', GUI_OPTION, self.change_value, ANCHOR_UP);
		item:setTag(1);

		item, data = gui_add_item(items, 'btn_music_inc', GUI_OPTION, self.change_value, ANCHOR_UP);
		item:setTag(2);

		item, data = gui_add_item(items, 'btn_eff_dec', GUI_OPTION, self.change_value, ANCHOR_UP);
		item:setTag(3);

		item, data = gui_add_item(items, 'btn_eff_inc', GUI_OPTION, self.change_value, ANCHOR_UP);
		item:setTag(4);

		util.add_menu(self.layer, items, data.zorder);

		local slider, value, pos;
		local d1, d2, dtap, p1, p2, ptap;
		d1 = gui_get_data("bg_music", GUI_OPTION, ANCHOR_UP);
		p1 = util.get_path(d1.fname1);
		d2 = gui_get_data("bar_music", GUI_OPTION, ANCHOR_UP);
		p2 = util.get_path(d2.fname1);
		dtap = gui_get_data("tap_music", GUI_OPTION, ANCHOR_UP);
		ptap = util.get_path(dtap.fname1);
		pos = cc.p(d1.x, d1.y);
		slider = util.add_slider_image(self.layer, p1, p2, ptap, 1, 0, pos, ANCHOR_LEFT_DOWN, self.music_change, data.zorder);
		slider:setScale(d1.width / slider:getContentSize().width);
		value = cc.SimpleAudioEngine:getInstance():getMusicVolume();
		slider:setValue(value);
		self.slider_music = slider;

		d1 = gui_get_data("bg_eff", GUI_OPTION, ANCHOR_UP);
		p1 = util.get_path(d1.fname1);
		d2 = gui_get_data("bar_eff", GUI_OPTION, ANCHOR_UP);
		p2 = util.get_path(d2.fname1);
		dtap = gui_get_data("tap_eff", GUI_OPTION, ANCHOR_UP);
		ptap = util.get_path(dtap.fname1);
		pos = cc.p(d1.x, d1.y);
		slider = util.add_slider_image(self.layer, p1, p2, ptap, 1, 0, pos, ANCHOR_LEFT_DOWN, self.effect_change, data.zorder);
		slider:setScale(d1.width / slider:getContentSize().width);
		value = cc.SimpleAudioEngine:getInstance():getEffectsVolume();
		slider:setValue(value);
		self.slider_effect = slider;

		return self.layer, self.name;
	end,

	enter_code = function()
		play_tap_1();
		g_scene:add_layer(ZORDER_LAYER_CODE, layer_code:create());
	end,

	logout = function()
		play_tap_1();
		logout();
	end,

	music_change = function(sender)
		local self = layer_option;
		local value = sender:getValue();
		util.set_music_volume(value);
	end,

	effect_change = function(sender)
		local self = layer_option;
		local value = sender:getValue();
		util.set_effect_volume(value);
	end,

	change_value = function(...)
		play_tap_3();
		local self = layer_option;
		local args = {...};
		local tag = args[2]:getTag();
		if 1 == tag then
			local value = self.slider_music:getValue();
			self.slider_music:setValue(value - 0.1);
		elseif 2 == tag then
			local value = self.slider_music:getValue();
			self.slider_music:setValue(value + 0.1);
		elseif 3 == tag then
			local value = self.slider_effect:getValue();
			self.slider_effect:setValue(value - 0.1);
		elseif 4 == tag then
			local value = self.slider_effect:getValue();
			self.slider_effect:setValue(value + 0.1);
		end
	end,

	back = function()
		play_tap_1();
		local self = layer_option;
		local value;
		value = self.slider_music:getValue();
		util.save_rms('music_volume', value, 'string');
		value = self.slider_effect:getValue();
		util.save_rms('effect_volume', value, 'string');
		g_scene:map();
	end,

	handler = function(event, x, y)
		local self = layer_option;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.back();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
} -- layer_option end

layer_lmatch = {
	name = 'layer_lmatch',
	layer = nil,
	list = nil,
	tableview = nil,
	cwidth = nil,
	cheight = nil,
	bar = nil,
	tap = nil,
	data_cell = nil,
	my_match_id = nil,
	s_match_id = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.tableview = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell = nil;
		self.my_match_id = nil;
		self.s_match_id = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_LMATCH, self.handler, true);

		self.list = {};
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));
		local sprite, data;
		local offsetheight = init_bg_for_view(self.layer, GUI_LMATCH, '比赛', self.back);

		data = gui_get_data('cell', GUI_LMATCH, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height + 10;
		data = gui_get_data('table', GUI_LMATCH, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos,cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		return self.layer, self.name;
	end,

	refresh_my_status = function(self, my_match_id, max_player, current_player, is_add)
		if true == is_add then
			self.my_match_id = my_match_id or '0';
		else
			self.my_match_id = '0';
		end
		for i = 1, #self.list do
			local info = self.list[i];
			if info.match_id == my_match_id then
				info.max_player = max_player;
				info.current_player = current_player;
				break;
			end
		end
		local offset = self.tableview:getContentOffset();
		self:reload();
		self.tableview:setContentOffset(offset);
	end,

	reload = function(self)
		self.tableview:reloadData();
	end,

	add_list = function(self, list, my_match_id)
		self.my_match_id = my_match_id or '0';
		self.list = list or {};
		self:reload();
	end,

	create_match = function()
		play_tap_1();
		g_scene:add_layer(ZORDER_LAYER_CMATCH, layer_cmatch:create());
	end,

	cb_cancel = function()
		local self = layer_lmatch;
		if nil == self.s_match_id then return; end
		local cmd = 'match_cancel ' .. self.s_match_id;
		--local cmd = '@match_init ' .. self.s_match_id;
		net_send(cmd);
	end,

	m_cancel = function(...)
		play_tap_2();
		local self = layer_lmatch;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		self.s_match_id = info.match_id;
		local str = string.format("确定退出比赛(%s)吗?", info.title);
		g_scene:add_layer(ZORDER_LAYER_TIP, layer_tip:create(str,self.cb_cancel));
	end,

	cb_apply = function()
		local self = layer_lmatch;
		if nil == self.s_match_id then return; end
		local cmd = 'match_apply ' .. self.s_match_id;
		net_send(cmd);
	end,

	m_apply = function(...)
		play_tap_2();
		local self = layer_lmatch;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		self.s_match_id = info.match_id;
		local str = string.format("确定参加比赛(%s)吗?", info.title);
		g_scene:add_layer(ZORDER_LAYER_TIP, layer_tip:create(str, self.cb_apply));
	end,

	m_check = function(...)
		play_tap_2();
		local self = layer_lmatch;
		local cmd = 'player_data ' .. g_euser.eid;
		net_send(cmd);
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_lmatch;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			--local cell = args[3];
			--local idx = cell:getIdx();
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new();
			local width = self.cwidth;
			local height = self.cheight;
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local info = self.list[idx + 1];
			local match_id = info.match_id;
			local title = info.title;
			local round = info.round;
			local status = info.match_status;
			local max = info.max_player;
			local current = info.current_player;
			local start_time = info.start_time;
			local round_time = info.match_round_time;
			local daily_info = info.daily_info;
			local data2, sprite, path, pos, size, str;

			gui_add_sprite_on_cell(cell,data,'bg_alias',GUI_LMATCH,ANCHOR_DOWN);
			str = title;
			gui_add_label_on_cell(cell,data,str,28,'c_alias',GUI_LMATCH,ANCHOR_DOWN);

			if round > 0 then
				str = string.format("正进行第%d轮(总)", round);
				sprite = gui_add_stroke_on_cell(cell,data,str,28,'c_alias',GUI_LMATCH,ANCHOR_DOWN, cc.c4b(0, 200, 0, 255), cc.c4b(0, 0, 0, 255));
				sprite:setHorizontalAlignment(cc.TEXT_ALIGNMENT_RIGHT);
			end

			str = '开始时间:';
			gui_add_label_on_cell(cell,data,str,24,'t_start',GUI_LMATCH,ANCHOR_DOWN);
			local t = os.date("*t", start_time);
			str = string.format("%d年%02d月%02d日", t.year, t.month, t.day);
			gui_add_label_on_cell(cell,data,str,24,'start',GUI_LMATCH,ANCHOR_DOWN);

			str = '回合时间:';
			gui_add_label_on_cell(cell,data,str,24,'t_round',GUI_LMATCH,ANCHOR_DOWN);
			t = os.date("*t", round_time);
			str = string.format("%02d分%02d秒", t.min, t.sec);
			gui_add_label_on_cell(cell,data,str,24,'round',GUI_LMATCH,ANCHOR_DOWN);

			str = '状态:';
			gui_add_label_on_cell(cell,data,str,24,'t_status',GUI_LMATCH,ANCHOR_DOWN);
			str = get_match_status(status);
			gui_add_label_on_cell(cell,data,str,24,'status',GUI_LMATCH,ANCHOR_DOWN);

			str = '人数:';
			gui_add_label_on_cell(cell,data,str,24,'t_player',GUI_LMATCH,ANCHOR_DOWN);
			str = current .. ' / ' .. max;
			gui_add_label_on_cell(cell,data,str,24,'player',GUI_LMATCH,ANCHOR_DOWN);

			local len = #daily_info;
			if len > 4 then len = 4; end
			for i = 1, len do
				local d = daily_info[i];
				local k = 't_r' .. i;
				str = '第' .. i .. '轮:';
				gui_add_label_on_cell(cell,data,str,24,k,GUI_LMATCH,ANCHOR_DOWN);
				local hour = math.floor(d/60/60);
				local min = math.floor((d-hour*60*60)/60);
				str = string.format("%02d时%02d分", hour, min);
				k = 'r' .. i;
				gui_add_label_on_cell(cell,data,str,24,k,GUI_LMATCH,ANCHOR_DOWN);
			end

			if self.my_match_id == match_id then
				str = '已参赛';
				gui_add_label_on_cell(cell,data,str,24,'has_in',GUI_LMATCH,ANCHOR_DOWN);
			end

			local cb = nil;
			local t = nil;
			if self.my_match_id == match_id then
				if status > MATCH_STATUS_READY then
					cb = self.m_check;
					t = '查看';
				elseif status == MATCH_STATUS_READY then
					cb = self.m_cancel;
					t = '退出';
				end
			elseif MATCH_STATUS_READY == status and '0' == self.my_match_id then
				cb = self.m_apply;
				t = '申请';
			end

			if nil ~= cb then
				local items = {};
				local item;

				item, data2 = gui_add_item_on_cell(items, data, 'btn_act', GUI_LMATCH, cb, ANCHOR_DOWN);
				item:setTag(idx + 1);
				gui_add_text_on_sprite(item,t,'t_act',GUI_LMATCH,ANCHOR_DOWN,25);

				util.add_menu(cell, items, data2.zorder);
			end

			return cell;
		end
	end, -- tableview_handler end }

	back = function()
		local self = layer_lmatch;
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_lmatch;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
			util.free_ram();
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
} -- layer_lmatch end

layer_matchdata = {
	name = 'layer_matchdata',
	layer = nil,

	cleanup = function(self)
		self.layer = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, match_data, player_info, oppo_info, round_date)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_MATCHDATA, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 100));
		local bgsize = cc.size(FULL_WIDTH-wfix(80), FULL_HEIGHT-hfix(100));
		local title = string.format("%s 的比赛信息", player_info.alias);
		local bg, rect = init_bg_for_popview(self.layer,title,bgsize,self.back);

		local x = 25;
		local y = bgsize.height - 130;
		local height = 40;
		local fsize = 28;
		local bcolor = cc.c4b(0, 0, 0, 255);
		local color = cc.c4b(255, 255, 255, 255);
		local color2 = cc.c4b(0, 255, 0, 255);
		local label, pos, size, str;
		pos = cc.p(x, y);
		size = cc.size(bgsize.width-pos.x*2, height);
		str = '参与比赛:';
		label = util.add_labeloutline(bg, str, nil, fsize, pos, color, bcolor, 2, ANCHOR_LEFT_DOWN, 10, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		str = match_data.title or '';
		label = util.add_labeloutline(bg, str, nil, fsize, pos, color2, bcolor, 2, ANCHOR_LEFT_DOWN, 10, size, cc.TEXT_ALIGNMENT_RIGHT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		pos.y = pos.y - height;
		str = '比赛状态:';
		label = util.add_labeloutline(bg, str, nil, fsize, pos, color, bcolor, 2, ANCHOR_LEFT_DOWN, 10, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		str = get_match_status(match_data.match_status);
		label = util.add_labeloutline(bg, str, nil, fsize, pos, color2, bcolor, 2, ANCHOR_LEFT_DOWN, 10, size, cc.TEXT_ALIGNMENT_RIGHT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		pos.y = pos.y - height;
		str = '回合进度:';
		label = util.add_labeloutline(bg, str, nil, fsize, pos, color, bcolor, 2, ANCHOR_LEFT_DOWN, 10, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		str = string.format("第%d回合", (match_data.round or 0));
		label = util.add_labeloutline(bg, str, nil, fsize, pos, color2, bcolor, 2, ANCHOR_LEFT_DOWN, 10, size, cc.TEXT_ALIGNMENT_RIGHT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		pos.y = pos.y - height;
		str = '战况';
		label = util.add_labeloutline(bg, str, nil, fsize, pos, color, bcolor, 2, ANCHOR_LEFT_DOWN, 10, size, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		self:init_player_view(player_info, bg, pos.x+size.width/4, pos.y);
		if nil ~= oppo_info then
			self:init_player_view(oppo_info, bg, pos.x+size.width/4*3, pos.y);
		end

		pos.y = pos.y - 120;
		str = 'VS';
		label = util.add_labeloutline(bg, str, nil, fsize, pos, color, bcolor, 2, ANCHOR_LEFT_DOWN, 10, size, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		pos.y = pos.y - 180;
		str = '胜利';
		label = util.add_labeloutline(bg, str, nil, fsize, pos, color, bcolor, 2, ANCHOR_LEFT_DOWN, 10, size, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		height = 50;

		pos.y = pos.y - height;
		str = '失败';
		label = util.add_labeloutline(bg, str, nil, fsize, pos, color, bcolor, 2, ANCHOR_LEFT_DOWN, 10, size, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		pos.y = pos.y - height;
		str = '平局';
		label = util.add_labeloutline(bg, str, nil, fsize, pos, color, bcolor, 2, ANCHOR_LEFT_DOWN, 10, size, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		pos.y = pos.y - height;
		str = '得分';
		label = util.add_labeloutline(bg, str, nil, fsize, pos, color, bcolor, 2, ANCHOR_LEFT_DOWN, 10, size, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		pos.y = pos.y - height;
		if 0 == round_date then
			str = '回合战斗结果:';
			label = util.add_labeloutline(bg, str, nil, fsize, pos, color, bcolor, 2, ANCHOR_LEFT_DOWN, 10, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

			str = '出局';
			label = util.add_labeloutline(bg, str, nil, fsize, pos, color2, bcolor, 2, ANCHOR_LEFT_DOWN, 10, size, cc.TEXT_ALIGNMENT_RIGHT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);
		elseif nil ~= round_date then
			str = '下回合开始时间:';
			label = util.add_labeloutline(bg, str, nil, fsize, pos, color, bcolor, 2, ANCHOR_LEFT_DOWN, 10, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

			local t = os.date("*t", rond_date);
			str = string.format("%d年%02d月%02d日", t.year, t.month, t.day);
			label = util.add_labeloutline(bg, str, nil, fsize, pos, color2, bcolor, 2, ANCHOR_LEFT_DOWN, 10, size, cc.TEXT_ALIGNMENT_RIGHT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);
		end

		return self.layer, self.name;
	end,

	init_player_view = function(self, player, bg, x, y)
		local path, sprite, pos, size, str;
		pos = cc.p(x, y-200);
		path = util.get_path('bg_53.png');
		sprite = util.add_sprite(bg, path, pos, ANCHOR_CENTER_DOWN, 10);
		local w = sprite:getContentSize().width;
		path = get_icon_path(player.icon);
		sprite = util.add_sprite(sprite, path, cc.p(0,0), ANCHOR_LEFT_DOWN, -1);
		sprite:setScale(w/sprite:getContentSize().width);

		local height = 50;
		local fsize = 28;
		local bcolor = cc.c4b(0, 0, 0, 255);
		local color = cc.c4b(255, 255, 255, 255);
		local color2 = cc.c4b(255, 0, 0, 255);
		local color3 = cc.c4b(255, 255, 0, 255);
		
		pos.y = pos.y-height;
		str = player.alias or '';
		util.add_labeloutline(bg, str, nil, fsize, pos, color, bcolor, 2, ANCHOR_CENTER_DOWN, 10, size, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		pos.y = pos.y-height;
		str = player.win or 0;
		util.add_labeloutline(bg, str, nil, fsize, pos, color2, bcolor, 2, ANCHOR_CENTER_DOWN, 10, size, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		pos.y = pos.y-height;
		str = player.lose or 0;
		util.add_labeloutline(bg, str, nil, fsize, pos, color2, bcolor, 2, ANCHOR_CENTER_DOWN, 10, size, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		pos.y = pos.y-height;
		str = player.draw or 0;
		util.add_labeloutline(bg, str, nil, fsize, pos, color2, bcolor, 2, ANCHOR_CENTER_DOWN, 10, size, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		pos.y = pos.y-height;
		str = player.point or 0;
		util.add_labeloutline(bg, str, nil, fsize, pos, color3, bcolor, 2, ANCHOR_CENTER_DOWN, 10, size, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);
	end,

	back = function()
		local self = layer_matchdata;
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_matchdata;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function (self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)

	end,
} -- layer_matchdata end

layer_cmatch = {
	name = 'layer_cmatch',
	layer = nil,
	title = nil,
	year = nil,
	month = nil,
	day = nil,
	max = nil,
	r1h = nil,
	r2h = nil,
	r3h = nil,
	r4h = nil,
	r1m = nil,
	r2m = nil,
	r3m = nil,
	r4m = nil,

	cleanup = function(self)
		self.layer = nil;
		self.title = nil;
		self.year = nil;
		self.month = nil;
		self.day = nil;
		self.max = nil;
		self.r1h = nil;
		self.r2h = nil;
		self.r3h = nil;
		self.r4h = nil;
		self.r1m = nil;
		self.r2m = nil;
		self.r3m = nil;
		self.r4m = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_CMATCH, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 128));

		self.match_id = nil;
		local bgsize = cc.size(wfix(500), hfix(650));
		local bg,rect=init_bg_for_popview(self.layer,'创建比赛',bgsize,self.back);

		local size = cc.size(wfix(300), hfix(71));
		local pos = cc.p((bgsize.width-size.width)/2, hfix(450));
		local tip = '请输入比赛标题';
		self.title = add_editbox_1(bg, pos, size, tip, 10,self.editbox_handler);

		size = cc.size(wfix(150), hfix(71));
		pos = cc.p(bgsize.width/2-size.width-wfix(80), hfix(375));
		tip = '年';
		self.year = add_editbox_1(bg, pos, size, tip, 10,self.editbox_handler);

		pos = cc.p(bgsize.width/2-size.width-wfix(80), hfix(300));
		tip = '月';
		self.month = add_editbox_1(bg, pos, size, tip, 10,self.editbox_handler);

		pos = cc.p(bgsize.width/2-size.width-wfix(80), hfix(225));
		tip = '日';
		self.day = add_editbox_1(bg, pos, size, tip, 10,self.editbox_handler);

		pos = cc.p(bgsize.width/2-size.width-wfix(80), hfix(150));
		tip = '最大人数';
		self.max = add_editbox_1(bg, pos, size, tip, 10,self.editbox_handler);

		pos = cc.p((bgsize.width-size.width)/2, hfix(375));
		tip = 'r1时';
		self.r1h = add_editbox_1(bg, pos, size, tip, 10,self.editbox_handler);

		pos = cc.p((bgsize.width-size.width)/2, hfix(300));
		tip = 'r2时';
		self.r2h = add_editbox_1(bg, pos, size, tip, 10,self.editbox_handler);

		pos = cc.p((bgsize.width-size.width)/2, hfix(225));
		tip = 'r3时';
		self.r3h = add_editbox_1(bg, pos, size, tip, 10,self.editbox_handler);

		pos = cc.p((bgsize.width-size.width)/2, hfix(150));
		tip = 'r4时';
		self.r4h = add_editbox_1(bg, pos, size, tip, 10,self.editbox_handler);

		pos = cc.p(bgsize.width/2+wfix(80), hfix(375));
		tip = 'r1分';
		self.r1m = add_editbox_1(bg, pos, size, tip, 10,self.editbox_handler);

		pos = cc.p(bgsize.width/2+wfix(80), hfix(300));
		tip = 'r2分';
		self.r2m = add_editbox_1(bg, pos, size, tip, 10,self.editbox_handler);

		pos = cc.p(bgsize.width/2+wfix(80), hfix(225));
		tip = 'r3分';
		self.r3m = add_editbox_1(bg, pos, size, tip, 10,self.editbox_handler);

		pos = cc.p(bgsize.width/2+wfix(80), hfix(150));
		tip = 'r4分';
		self.r4m = add_editbox_1(bg, pos, size, tip, 10,self.editbox_handler);

		local items = {};
		local item;

		add_item_1(items, '创建', nil, 30, self.action, ANCHOR_CENTER_DOWN, cc.p(bgsize.width/2, hfix(30)));
		
		util.add_menu(bg, items, 50);

		return self.layer, self.name;
	end,

	action = function()
		play_tap_1();
		local self = layer_cmatch;
		local title = self.title:getText() or '';
		if 0 == string.len(title) then
			show_msg('标题不能为空');
			return;
		end
		local year = tonumber(self.year:getText() or '');
		if nil == year then
			show_msg('年 要为数字');
			return;
		end
		local month = tonumber(self.month:getText() or '');
		if nil == month then
			show_msg('月 要为数字');
			return;
		end
		local day = tonumber(self.day:getText() or '');
		if nil == day then
			show_msg('日 要为数字');
			return;
		end
		local max = tonumber(self.max:getText() or '');
		if nil == year then
			show_msg('最大人数 要为数字');
			return;
		end
		local max = tonumber(self.max:getText() or '');
		if nil == year then
			show_msg('最大人数 要为数字');
			return;
		end
		local r1h = tonumber(self.r1h:getText() or '');
		if nil == r1h then
			show_msg('r1时 要为数字');
			return;
		end
		local r2h = tonumber(self.r2h:getText() or '');
		if nil == r2h then
			show_msg('r2时 要为数字');
			return;
		end
		local r3h = tonumber(self.r3h:getText() or '');
		if nil == r3h then
			show_msg('r3时 要为数字');
			return;
		end
		local r4h = tonumber(self.r4h:getText() or '');
		if nil == r4h then
			show_msg('r4时 要为数字');
			return;
		end
		local r1m = tonumber(self.r1m:getText() or '');
		if nil == r1m then
			show_msg('r1分 要为数字');
			return;
		end
		local r2m = tonumber(self.r2m:getText() or '');
		if nil == r2m then
			show_msg('r2分 要为数字');
			return;
		end
		local r3m = tonumber(self.r3m:getText() or '');
		if nil == r3m then
			show_msg('r3分 要为数字');
			return;
		end
		local r4m = tonumber(self.r4m:getText() or '');
		if nil == r4m then
			show_msg('r4分 要为数字');
			return;
		end
		local cmd = string.format("@match_add %d %04d%02d%02d", max, year, month, day);
		cmd = string.format("%s %02d%02d %02d%02d %02d%02d %02d%02d %s", cmd, r1h, r1m, r2h, r2m, r3h, r3m, r4h, r4m, title);
		net_send(cmd);
		--[[
		--print('DEBUG search friend: ', alias);
		local cmd = string.format("fsearch %s", alias);
		net_send(cmd);
		]]--
	end,

	back = function()
		local self = layer_cmatch;
		self:remove();
	end,

	editbox_handler = function(eventname, psender)
		local self = layer_cmatch;
		local edit = tolua.cast(psender, "cc.EditBox");
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
		elseif eventname == "changed" then
		end

	end,

	handler = function(event, x, y)
		local self = layer_cmatch;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
	end,

} -- layer_cmatch end

layer_friend = {
	name = 'layer_friend',
	PAGE_SIZE = 15,
	layer = nil,
	list = nil,
	tableview = nil,
	cwidth = nil,
	cheight = nil,
	bar = nil,
	tap = nil,
	state = nil, -- 1 is list frd, 2 is list of find friend
	data_cell = nil,
	eid_to_delete = nil,
	label_total = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.tableview = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.bar = nil;
		self.tap = nil;
		self.state = nil;
		self.data_cell = nil;
		self.eid_to_delete = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_FRIEND, self.handler, true);

		self.list = {};
		self.state = 1;
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));
		local sprite, data;
		local offsetheight = init_bg_for_view(self.layer, GUI_FRIEND, '好友', self.back);
		data = gui_get_data('bg_title', GUI_FRIEND, ANCHOR_UP);
		self.label_total = util.add_labelttf(self.layer, '', nil, 30, cc.p(data.x + data.width/4*3, data.y + data.height/2), cc.c4b(182, 28, 16, 255), ANCHOR_CENTER_CENTER, data.zorder+10);

		data = gui_get_data('cell', GUI_FRIEND, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height + 10;
		data = gui_get_data('table', GUI_FRIEND, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos,cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		local items = {};
		local item;

		item, data = gui_add_item(items, 'btn_search', GUI_FRIEND, self.find_friend, ANCHOR_DOWN);
		gui_add_text_on_sprite(item,'查找','t_search',GUI_FRIEND,ANCHOR_DOWN,30);

		util.add_menu(self.layer, items, data.zorder);

		return self.layer, self.name;
	end,

	reload = function(self)
		self.tableview:reloadData();
	end,

	add_list = function(self, list, state, total, start_pos)
		if nil == total or nil == start_pos then
			self.label_total:setString("");
			self.state = state or 1;
			self.list = list or {};
			self:reload();
			return;
		end
		local offset = nil;
		if start_pos > 0 then
			offset = self.tableview:getContentOffset();
		end
		local tstr = string.format("(%d)", total);
		self.label_total:setString(tstr);
		self.state = state or 1;
		list = list or {};
		local more_cell = { flag_more_cell = true };
		self.list = self.list or {};
		if 0 == start_pos then
			self.list = {};
		end
		if 0 < #self.list then
			local m = self.list[#self.list];
			if true == m.flag_more_cell then
				table.remove(self.list, #self.list);
			end
		end
		for i = 1, #list do
			table.insert(self.list, list[i]);
		end
		if self.PAGE_SIZE == #list then
			table.insert(self.list, more_cell);
		end
		self:reload();
		if nil ~= offset then
			offset.y = offset.y - #list * self.cheight;
			self.tableview:setContentOffset(offset);
		end
	end,

	get_more = function()
		play_tap_1();
		local self = layer_friend;
		local len = #(self.list or {});
		if self.list[len].flag_more_cell == true then
			len = len - 1;
		end
		if len < 0 then len = 0; end
		local cmd = string.format("flist %d %d", len, self.PAGE_SIZE);
		net_send(cmd);
	end,

	find_friend = function()
		play_tap_1();
		g_scene:add_layer(ZORDER_LAYER_FINDFRD, layer_findfrd:create());
	end,

	detail = function(...)
		play_tap_2();
		local self = layer_friend;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		local eid = info.eid;
		local cmd = 'fsta ' .. eid;
		net_send(cmd);
	end,

	delete = function(...)
		play_tap_2();
		local self = layer_friend;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		local eid = info.eid;
		self.eid_to_delete = eid;
		local tip = '确定删除 ' .. info.alias .. ' ?';
		g_scene:add_layer(ZORDER_LAYER_TIP,layer_tip:create(tip, self.cb_delete));
	end,

	cb_delete = function(tag)
		local self = layer_friend;
		tag = tag or 0;
		if 0 == tag then 
			self.eid_to_delete = nil;
			return;
		end
		if nil == self.eid_to_delete then return; end
		local cmd = 'fdel ' .. self.eid_to_delete;
		net_send(cmd);
	end,

	whisper = function(...)
		play_tap_2();
		local self = layer_friend;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		local eid = info.eid;
		local alias = info.alias;
		if nil == layer_chat.layer then
			return;
		end
		self.back();
		layer_chat.chat_target = { eid = eid, alias = alias };
		layer_chat:handle_channel_btn(C_PRIVATE);
	end,

	fight = function(...)
		play_tap_2();
		local self = layer_friend;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		local eid = info.eid;
		pop_invite_fight(eid);
	end,

	add_frd = function(...)
		play_tap_2();
		local self = layer_friend;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		local eid = info.eid;
		local cmd = string.format("fadd %d", eid);
		net_send(cmd);
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_friend;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			--local cell = args[3];
			--local idx = cell:getIdx();
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new();
			local width = self.cwidth;
			local height = self.cheight;
			local info = self.list[idx + 1];
			if true == info.flag_more_cell then
				local items = {};
				local pos = cc.p(width/2, height/2);
				local size = cc.size(172, 52);
				local item = add_item_1(items, '更多', nil, 20, self.get_more, ANCHOR_CENTER_CENTER, pos, size);
				item:setTag(idx + 1);

				util.add_menu(cell, items, 1);
				return cell;
			end
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local icon = info.icon;
			local eid = info.eid;
			local alias = info.alias;
			local is_online = info.is_online;
			local data2, sprite, path, pos, size, str;

			sprite, data2 = gui_add_sprite_on_cell(cell, data, 'icon', GUI_FRIEND, ANCHOR_DOWN);
			path = get_icon_path(icon);
			sprite = util.add_sprite(sprite, path,cc.p(0,0),ANCHOR_LEFT_DOWN,-1);
			sprite:setScale(data2.width/sprite:getContentSize().width);

			gui_add_sprite_on_cell(cell,data,'bg_alias',GUI_FRIEND,ANCHOR_DOWN);
			str = alias;
			gui_add_label_on_cell(cell,data,str,28,'c_alias',GUI_FRIEND,ANCHOR_DOWN);

			if 1 ~= is_online then
				str = '(离线)';
				gui_add_stroke_on_cell(cell,data,str,24,'t_online',GUI_FRIEND,ANCHOR_DOWN);
			end

			local items = {};
			local item;

			if self.state == 1 then
				item, data2 = gui_add_item_on_cell(items, data, 'btn_info', GUI_FRIEND, self.detail, ANCHOR_DOWN);
				item:setTag(idx + 1);
				gui_add_text_on_sprite(item,'资料','t_info',GUI_FRIEND,ANCHOR_DOWN,30);

				item, data2 = gui_add_item_on_cell(items, data, 'btn_remove', GUI_FRIEND, self.delete, ANCHOR_DOWN);
				item:setTag(idx + 1);
				gui_add_text_on_sprite(item,'删除','t_remove',GUI_FRIEND,ANCHOR_DOWN,30);

				item, data2 = gui_add_item_on_cell(items, data, 'btn_chat', GUI_FRIEND, self.whisper, ANCHOR_DOWN);
				item:setTag(idx + 1);
				gui_add_text_on_sprite(item,'私聊','t_chat',GUI_FRIEND,ANCHOR_DOWN,30);
				if 1 ~= is_online then
					enable_btn(item, false);
				end

				item, data2 = gui_add_item_on_cell(items, data, 'btn_fight', GUI_FRIEND, self.fight, ANCHOR_DOWN);
				item:setTag(idx + 1);
				gui_add_text_on_sprite(item,'挑战','t_fight',GUI_FRIEND,ANCHOR_DOWN,30);
				if 1 ~= is_online then
					enable_btn(item, false);
				end
			else
				item, data2 = gui_add_item_on_cell(items, data, 'btn_add', GUI_FRIEND, self.add_frd, ANCHOR_DOWN);
				item:setTag(idx + 1);
				gui_add_text_on_sprite(item,'加好友','t_add',GUI_FRIEND,ANCHOR_DOWN,30);
			end

			util.add_menu(cell, items, data2.zorder);
			return cell;
		end
	end, -- tableview_handler end }

	back = function()
		local self = layer_friend;
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_friend;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
			util.free_ram();
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
} -- layer_friend end

layer_findfrd = {
	name = 'layer_findfrd',
	layer = nil,
	editbox = nil,
	rect = nil,

	cleanup = function(self)
		self.layer = nil;
		self.editbox = nil;
		self.rect = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_FINDFRD, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 128));

		local bgsize = cc.size(wfix(400), hfix(350));
		local bg, rect = init_bg_for_popview(self.layer,'查找',bgsize,self.back);
		self.rect = rect;

		local size = cc.size(wfix(300), hfix(71));
		local pos = cc.p((bgsize.width-size.width)/2, hfix(150));
		local tip = '输入对方名称或ID';
		self.editbox = add_editbox_1(bg, pos, size, tip, 10,self.editbox_handler);

		local items = {};
		local item;

		add_item_1(items, '查找', nil, 30, self.action, ANCHOR_CENTER_DOWN, cc.p(bgsize.width/2, hfix(30)));
		
		util.add_menu(bg, items, 50);

		return self.layer, self.name;
	end,

	action = function()
		play_tap_1();
		local self = layer_findfrd;
		local alias = self.editbox:getText() or '';
		if 0 == string.len(alias) then
			return;
		end
		--print('DEBUG search friend: ', alias);
		local cmd = string.format("fsearch %s", alias);
		net_send(cmd);
	end,

	back = function()
		local self = layer_findfrd;
		self:remove();
	end,

	editbox_handler = function(eventname, psender)
		local self = layer_findfrd;
		local edit = tolua.cast(psender, "cc.EditBox");
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
		elseif eventname == "changed" then
		end

	end,

	handler = function(event, x, y)
		local self = layer_findfrd;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		local r = self.rect;
		if nil ~= r and (x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2) then
			self.back();
		end
	end,

} -- layer_findfrd end

layer_story = {
	name = 'layer_story',
	list = nil, -- drama
	label = nil,
	callback = nil,
	drama_view = nil, -- story chat view

	cleanup = function(self)
		self.layer = nil;
		self.label = nil;
		self.list = nil;
		self.drama_view = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, actor, list, callback)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_STORY, self.handler, true);

		self.list = list;
		self.callback = callback;
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));
		self:init_drama_view(actor);
		--self.layer:scheduleUpdateWithPriorityLua(self.update_drama, 1);

		return self.layer, self.name;
	end,

	show_finger_tip = function(self)
	end,

	init_drama_view = function(self, actor)
		local pos = cc.p(0, 0);
		local fullrect = cc.rect(0, 0, 64, 64);
		local insetrect = cc.rect(30, 30, 4, 4);
		local bgsize = cc.size(FULL_WIDTH, 200);
		local path = util.get_path('pop_up.png');
		local bg = util.add_scale9sprite(self.layer, path, pos, ANCHOR_LEFT_DOWN, fullrect, insetrect, bgsize); 
		pos = cc.p(20, bgsize.height/2);
		path = util.get_path('bg_45.png');
		local icon = util.add_sprite(bg, path, pos, ANCHOR_LEFT_DOWN, 10);
		icon:setPosition(cc.p(pos.x+icon:getContentSize().width/2, pos.y+icon:getContentSize().height/2));
		icon:setAnchorPoint(ANCHOR_CENTER_CENTER);
		path = get_icon_path(actor.icon or 0);
		local s = util.add_sprite(icon, path, cc.p(0, 0),ANCHOR_LEFT_DOWN,-1);
		s:setScale(icon:getContentSize().width/s:getContentSize().width);
		pos = cc.p(20+62, bgsize.height/2-5);
		local str = actor.name or '';
		local name = util.add_labeloutline(bg, str, nil, 25, pos, util.c4b_gold, util.c4b_black, 2, ANCHOR_CENTER_UP, 20);

		pos = cc.p(20+124+10, bgsize.height/2);
		local size = cc.size(bgsize.width-20-pos.x, bgsize.height-40);
		str = self.list[1] or '';
		table.remove(self.list, 1);
		self.label = util.add_labelttf(bg, str, nil, 30, pos, util.c4b_white, ANCHOR_LEFT_CENTER, 30, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_TOP);

		icon:setScale(1.3);
		icon:setPositionY(icon:getPositionY()+30);
		icon:setVisible(false);
		name:setVisible(false);
		self.label:setVisible(false);
		self.label:setPositionY(self.label:getPositionY()-30);
		bg:setPositionX(FULL_WIDTH);
		local array = {};
		table.insert(array, cc.EaseBackOut:create(cc.MoveTo:create(0.5, cc.p(0, 0))));
		bg:runAction(cc.Sequence:create(array));

		local function cb_show(...)
			local args = { ... };
			local sprite = args[1];
			sprite:setVisible(true);
		end
		array = {};
		local sarray = {};
		table.insert(array, cc.DelayTime:create(0.5));
		table.insert(array, cc.CallFunc:create(cb_show));
		table.insert(sarray, cc.ScaleTo:create(0.2, 1));
		table.insert(sarray, cc.MoveBy:create(0.2, cc.p(0, -30)));
		table.insert(array, cc.Spawn:create(sarray));
		icon:runAction(cc.Sequence:create(array));

		array = {};
		table.insert(array, cc.DelayTime:create(0.6));
		table.insert(array, cc.CallFunc:create(cb_show));
		name:runAction(cc.Sequence:create(array));

		array = {};
		sarray = {};
		table.insert(array, cc.DelayTime:create(0.6));
		table.insert(array, cc.CallFunc:create(cb_show));
		--table.insert(sarray, cc.FadeIn:create(0.2));
		table.insert(sarray, cc.MoveBy:create(0.2, cc.p(0, 30)));
		table.insert(array, cc.Spawn:create(sarray));
		self.label:runAction(cc.Sequence:create(array));
	end,

	update_drama = function(delta)
		self.layer:unscheduleUpdate();
	end,

	next_drama = function(self)
		local str = self.list[1];
		table.remove(self.list, 1);
		if nil == str then
			return false;
		end
		local function cb_change()
			self.label:setString(str);
		end
		array = {};
		sarray = {};
		table.insert(sarray, cc.FadeOut:create(0.1));
		table.insert(sarray, cc.MoveBy:create(0.1, cc.p(0, -30)));
		table.insert(array, cc.Spawn:create(sarray));
		table.insert(array, cc.CallFunc:create(cb_change));
		sarray = {};
		table.insert(sarray, cc.FadeIn:create(0.1));
		table.insert(sarray, cc.MoveBy:create(0.1, cc.p(0, 30)));
		table.insert(array, cc.Spawn:create(sarray));
		self.label:runAction(cc.Sequence:create(array));
		return true;
	end,

	handler = function(event, x, y)
		local self = layer_story;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
			util.free_ram();
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
	end,

	onTouchEnded = function(self, x, y)
		if true == self:next_drama() then
			return;
		end
		local cb = self.callback;
		self:remove();
		if nil ~= cb then
			cb();
		end
	end,

} -- layer_story end

layer_gatepop = {
	name = 'layer_gatepop',
	list = nil, -- drama
	label = nil,
	callback = nil,
	drama_view = nil, -- story chat view

	cleanup = function(self)
		self.layer = nil;
		self.label = nil;
		self.list = nil;
		self.drama_view = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, card, msg, callback)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_GATEPOP, self.handler, true);

		self.callback = callback;
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));
		self:init_drama_view(card, msg);

		return self.layer, self.name;
	end,

	back = function()
		play_tap_1();
		local self = layer_gatepop;
		local cb = self.callback;
		self:remove();
		if nil == cb then return; end
		cb();
	end,

	init_drama_view = function(self, card, msg)
		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		local fullrect = cc.rect(0, 0, 64, 64);
		local insetrect = cc.rect(30, 30, 4, 4);
		local bgsize = cc.size(FULL_WIDTH-wfix(100), FULL_HEIGHT-hfix(200));
		local path = util.get_path('pop_up.png');
		local bg = util.add_scale9sprite(self.layer, path, pos, ANCHOR_CENTER_CENTER, fullrect, insetrect, bgsize); 

		local scale = get_card_scale(bgsize.width-80, bgsize.height/4*3-100, CARD_SIZE);
		pos = cc.p(bgsize.width/2, bgsize.height-30-CARD_SIZE.height*scale/2);
		local cinfo = object_card:new(bg, card, nil, nil, pos, 0, scale);
		local csprite = cinfo:get_show_sprite(bg, pos, 0, scale);

		pos = cc.p(bgsize.width/2, hfix(100));
		local size = cc.size(bgsize.width-40, 100);
		msg = msg or '';
		self.label = util.add_labelttf(bg, msg, nil, 30, pos, util.c4b_white, ANCHOR_CENTER_DOWN, 30, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_TOP);

		local items = {};
		local item;

		pos = ccp(bgsize.width/2, hfix(28));
		add_item_1(items, '关闭',nil,30,self.back,ANCHOR_CENTER_DOWN,pos);

		util.add_menu(bg, items, 35);

		csprite:setScale(1.3);
		csprite:setPositionY(csprite:getPositionY()+30);
		csprite:setVisible(false);
		self.label:setVisible(false);
		self.label:setPositionY(self.label:getPositionY()-30);
		bg:setPositionX(FULL_WIDTH);
		local array = {};
		table.insert(array, cc.EaseBackOut:create(cc.MoveTo:create(0.5, cc.p(HALF_WIDTH, HALF_HEIGHT))));
		bg:runAction(cc.Sequence:create(array));

		local function cb_show(...)
			local args = { ... };
			local sprite = args[1];
			sprite:setVisible(true);
		end
		array = {};
		local sarray = {};
		table.insert(array, cc.DelayTime:create(0.5));
		table.insert(array, cc.CallFunc:create(cb_show));
		table.insert(sarray, cc.ScaleTo:create(0.2, 1));
		table.insert(sarray, cc.MoveBy:create(0.2, cc.p(0, -30)));
		table.insert(array, cc.Spawn:create(sarray));
		csprite:runAction(cc.Sequence:create(array));

		array = {};
		sarray = {};
		table.insert(array, cc.DelayTime:create(0.6));
		table.insert(array, cc.CallFunc:create(cb_show));
		table.insert(sarray, cc.MoveBy:create(0.2, cc.p(0, 30)));
		table.insert(array, cc.Spawn:create(sarray));
		self.label:runAction(cc.Sequence:create(array));
	end,

	handler = function(event, x, y)
		local self = layer_gatepop;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
			util.free_ram();
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
	end,

	onTouchEnded = function(self, x, y)
	end,

} -- layer_gatepop end

layer_dragstory = {
	name = 'layer_dragstory',
	layer = nil,
	callback = nil,
	fdata = nil,
	tdata = nil,
	tp = nil, -- touch point
	line = nil,
	finger = nil,

	cleanup = function(self)
		self.layer = nil;
		self.fdata = nil;
		self.tdata = nil;
		self.tp = nil;
		self.line = nil;
		self.finger = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, fdata, tdata, callback)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_DRAGSTORY, self.handler, true);

		self:init_clip_view(fdata, tdata);
		self:init_finger(fdata, tdata);
		self.callback = callback;
		self.fdata = fdata;
		self.tdata = tdata;

		return self.layer, self.name;
	end,

	get_sprite_data = function(sprite, use_circle)
		local x, y = sprite:getPosition();
		local size = sprite:getContentSize();
		local width = size.width;
		local height = size.height;
		local scale = sprite:getScale();
		local data = { x=x, y=y, width=width*scale, height=height*scale, use_circle=use_circle };
		return data;
	end,

	init_clip_view = function(self, fdata, tdata)
		local list = {};
		if nil ~= fdata then table.insert(list, fdata); end
		if nil ~= tdata then table.insert(list, tdata); end
		local layer_color = cc.LayerColor:create(ccc4(0, 0, 0, 180));
		local pclip = cc.ClippingNode:create();
		pclip:setInverted(true);
		pclip:addChild(layer_color);

		local pstencil = cc.DrawNode:create();
		local fill_color = cc.c4f(1, 0, 0, 1);
		local border_color = cc.c4f(1, 0, 0, 1);
		for i = 1, #list do
			local verts = {};
			local data = list[i];
			local x = data.x;
			local y = data.y;
			local width = data.width;
			local height = data.height;
			local use_circle = data.use_circle;
			if true == use_circle then
				local radius;
				if width > height then
					radius = width/2;
				else
					radius = height/2;
				end
				local count = 200;
				local m_pi = 3.1415926;
				local angel = 2.0 * m_pi / count;
				for i = 0, count - 1 do
					local radian = i * angel;
					local cx = radius * math.cos(radian);
					local cy = radius * math.sin(radian);
					table.insert(verts, cc.p(x+cx, y+cy));
				end
			else
				local hw = width/2;
				local hh = height/2;
				verts = {
					cc.p(x-hw, y-hh);
					cc.p(x+hw, y-hh);
					cc.p(x+hw, y+hh);
					cc.p(x-hw, y+hh);
				};
			end
			pstencil:drawPolygon(verts, #verts, fill_color, 0, border_color);
		end

		pstencil:setPosition(cc.p(0, 0));
		pclip:setStencil(pstencil);
		self.layer:addChild(pclip, 50);
	end,

	init_finger = function(self, fdata, tdata)
		local fpos = cc.p(fdata.x, fdata.y);
		if nil == tdata then
			self.finger = util.play_frame(self.layer, 'tutor_finger', fpos, ANCHOR_LEFT_CENTER, 0.1, 70, true);
			return;
		end
		local tpos = cc.p(tdata.x, tdata.y);
		local finger = util.play_frame(self.layer, 'tutor_finger', fpos, ANCHOR_LEFT_CENTER, 0.1, 70, false);
		self.finger = finger;
		local dis = math.sqrt(math.pow((tpos.x-fpos.x), 2) + math.pow((tpos.y-fpos.y), 2));
		local speed = 200;
		local t = dis/speed;
		local array = {};
		table.insert(array, cc.MoveTo:create(t, tpos));
		table.insert(array, cc.MoveTo:create(0.1, fpos));
		finger:runAction(cc.RepeatForever:create(cc.Sequence:create(array)));
	end,

	handler = function(event, x, y)
		local self = layer_dragstory;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
			util.free_ram();
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		self.tp = nil;
		if nil ~= self.line then
			self.line.batch:removeFromParentAndCleanup(true);
			self.line = nil;
		end
		if nil ~= self.fdata then
			local hw = self.fdata.width/2;
			local hh = self.fdata.height/2;
			if true == self.fdata.use_circle then
				local t = hw;
				if hh > hw then
					t = hh;
				end
				hw = t;
				hh = t;
			end
			local x1 = self.fdata.x - hw;
			local y1 = self.fdata.y - hh;
			local x2 = self.fdata.x + hw;
			local y2 = self.fdata.y + hh;
			if x > x1 and x < x2 and y > y1 and y < y2 then
				self.tp = cc.p(x, y);
			end
		end
		return true;
	end,

	onTouchMoved = function(self, x, y)
		if nil == self.tp then return; end
		if nil == self.tdata then return; end
		local ttt = self.tp;
		if nil == self.line then
			local path = util.get_path('dragline.plist');	
			self.line = util.add_particle(self.layer, path, ttt, 60);
		end
		local pp = cc.p(x-ttt.x, y-ttt.y);
		local r = math.atan2(pp.y, pp.x);
		local r1 = r * 360 / ( 2 * 3.14 );
		local r2 = 90 - r1;
		local offset = math.sqrt(math.pow(pp.x, 2) + math.pow(pp.y, 2));
		local spos = self.line.emitter:getPosVar();
		spos.y = offset*0.5;
		self.line.emitter:setPosVar(spos);
		local pos = cc.p(pp.x/2+ttt.x, pp.y/2+ttt.y);
		self.line.batch:setPosition(pos);
		self.line.batch:setRotation(r2);
	end,

	onTouchEnded = function(self, x, y)
		if nil == self.tp then return; end
		self.tp = nil;
		if nil == self.tdata then
			self:remove();
			self.callback();
			return;
		end
		if nil ~= self.line then
			self.line.batch:removeFromParentAndCleanup(true);
			self.line = nil;
		end
		if nil ~= self.tdata then
			local hw = self.tdata.width/2;
			local hh = self.tdata.height/2;
			if true == self.fdata.use_circle then
				local t = hw;
				if hh > hw then
					t = hh;
				end
				hw = t;
				hh = t;
			end
			local x1 = self.tdata.x - hw;
			local y1 = self.tdata.y - hh;
			local x2 = self.tdata.x + hw;
			local y2 = self.tdata.y + hh;
			if x > x1 and x < x2 and y > y1 and y < y2 then
				self:remove();
				self.callback();
				return;
			end
		end
	end,

} -- layer_dragstory end

layer_tutorial = {
	name = 'layer_tutorial',
	layer = nil,
	pclip = nil,
	rect = nil,
	finger = nil,
	tip = nil,
	board = nil,
	star = nil,
	tail = nil,
	callback = nil,

	cleanup = function(self)
		self.layer = nil;
		self.pclip = nil;
		self.rect = nil;
		self.finger = nil;
		self.tip = nil;
		self.board = nil;
		self.star = nil;
		self.tail = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, pos, size, tip, callback)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_TUTORIAL, self.handler, true);

		self:set_view(pos, size, tip, callback);

		return self.layer, self.name;
	end,

	set_view = function(self, pos, size, tip, callback)
		self.callback = callback;
		local r = nil;
		if nil ~= pos and nil ~= size then
			r = { 
				x1 = math.floor(pos.x), x2 = math.floor(pos.x + size.width),
				y1 = math.floor(pos.y), y2 = math.floor(pos.y + size.height) 
			};
			self:init_view(pos, size);
		end
		self.rect = r;

		local pos = cc.p(pos.x + size.width/2, pos.y + size.height/2+30);
		if nil ~= self.finger then
			self.finger:setPosition(pos);
			self.finger:setFlipX(false);
		else
			local finger = util.play_frame(self.layer, 'tutor_finger', pos, ANCHOR_LEFT_UP, 0.2, 70, true);
			self.finger = finger;
		end
		if pos.x > FULL_WIDTH/4*3 then
			self.finger:setFlipX(true);
			self.finger:setAnchorPoint(ANCHOR_RIGHT_UP);
		end

		if nil ~= self.tip then
			self.tip:removeFromParentAndCleanup(true);
		end
		if nil ~= tip and nil ~= r then
			local line = math.floor(FULL_HEIGHT/4*3);
			local gap = hfix(100);
			if pos.y > line then
				pos = cc.p(HALF_WIDTH, r.y1 - gap);
			else
				pos = cc.p(HALF_WIDTH, r.y2 + gap);
			end
			local size = cc.size(FULL_WIDTH/4*3, HALF_HEIGHT/4);
			self.tip = util.add_labelsys(self.layer, tip, nil, 25, pos, util.c_white, ANCHOR_CENTER_CENTER, 60, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
			local s = self.tip:getContentSize();
			size = cc.size(s.width + wfix(80), s.height + hfix(40));
			if nil ~= self.board then
				self.board:setPosition(pos);
				self.board:setContentSize(size);
			else
				local path = util.get_path('pop_up.png');
				local frect = cc.rect(0, 0, 64, 64); -- fullrect
				local irect = cc.rect(30, 30, 4, 4); -- insetrect
				self.board = util.add_scale9sprite(self.layer, path, pos, ANCHOR_CENTER_CENTER, frect, irect, size, 55); 
			end
		elseif nil ~= self.board then
			self.board:removeFromParentAndCleanup(true);
		end

		self:show_eff();
	end,

	show_eff = function(self)
		local r = self.rect;
		if nil == r or (r.x1 == r.x2 and r.y1 == r.y2) then
			if nil ~= self.star then
				self.star:removeFromParentAndCleanup(true);
				self.star = nil;
			end
			if nil ~= self.tail then
				self.tail.batch:removeFromParentAndCleanup(true);
				self.tail = nil;
			end
			return;
		end
		local speed = 250;
		local tx = (r.x2 - r.x1) / speed;
		local ty = (r.y2 - r.y1) / speed;
		local sprite, path, info, pos, size, action;
		pos = cc.p(r.x1, r.y2);
		if nil ~= self.star then
			self.star:setPosition(pos);
			self.star:stopAllActions();
		else
			path = util.get_path('tutor_star.png');
			self.star = util.add_sprite(self.layer,path,pos,ANCHOR_CENTER_CENTER,65);
		end
		size = self.star:getContentSize();
		local array = {};
		table.insert(array, cc.MoveTo:create(ty, cc.p(r.x1, r.y2)));
		table.insert(array, cc.MoveTo:create(tx, cc.p(r.x2, r.y2)));
		table.insert(array, cc.MoveTo:create(ty, cc.p(r.x2, r.y1)));
		table.insert(array, cc.MoveTo:create(tx, cc.p(r.x1, r.y1)));
		self.star:runAction(cc.RepeatForever:create(cc.Sequence:create(array)));
		self.star:runAction(cc.RepeatForever:create(cc.RotateBy:create(1, 360)));

		if nil ~= self.tail then
			self.tail.batch:setPosition(pos);
			self.tail.batch:stopAllActions();
		else
			path = util.get_path('tutor_tail.plist');
			self.tail = util.add_particle(self.layer, path, pos, 64);
		end
		array = {};
		table.insert(array, cc.MoveTo:create(ty, cc.p(r.x1, r.y2)));
		table.insert(array, cc.MoveTo:create(tx, cc.p(r.x2, r.y2)));
		table.insert(array, cc.MoveTo:create(ty, cc.p(r.x2, r.y1)));
		table.insert(array, cc.MoveTo:create(tx, cc.p(r.x1, r.y1)));
		self.tail.batch:runAction(cc.RepeatForever:create(cc.Sequence:create(array)));
	end,

	init_view = function(self, pos, size)
		if nil ~= self.pclip then
			self.pclip:removeFromParentAndCleanup(true);
			self.pclip = nil;
		end
		local layer_color = cc.LayerColor:create(ccc4(0, 0, 0, 180));
		local pclip = cc.ClippingNode:create();
		pclip:setInverted(true);
		pclip:addChild(layer_color);

		local fill_color = cc.c4f(1, 0, 0, 1);
		local border_color = cc.c4f(1, 0, 0, 1);
		local verts = {
			cc.p(0, 0);
			cc.p(size.width, 0);
			cc.p(size.width, size.height);
			cc.p(0, size.height);
		};
		--[[ 
		--circle
		--local radius = 55.0;
		local radius;
		if size.width > size.height then
			radius = size.width/2;
		else
			radius = size.height/2;
		end
		local count = 200;
		local m_pi = 3.1415926;
		local angel = 2.0 * m_pi / count;
		local verts = {};
		for i = 0, count - 1 do
			local radian = i * angel;
			local x = radius * math.cos(radian);
			local y = radius * math.sin(radian);
			table.insert(verts, cc.p(x, y));
		end
		]]--
		local pstencil = cc.DrawNode:create();
		pstencil:drawPolygon(verts, #verts, fill_color, 0, border_color);
		pstencil:setPosition(pos);
		pclip:setStencil(pstencil);
		self.layer:addChild(pclip, 50);
		self.pclip = pclip;
	end,

	get_finger = function(self)
		if nil == self.layer then
			return nil;
		end
		return self.finger;
	end,

	check_touch = function(self, x, y)
		local r = self.rect;
		if nil == r then
			kerror("layer_tutorial rect is nil");
			return false;
		end
		if x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2 then
			return true;
		end
		return false;
	end,

	handler = function(event, x, y)
		local self = layer_tutorial;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
			util.free_ram();
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	to_close = function(delta)
		local self = layer_tutorial;
		local cb = self.callback;
		if nil == cb then
			self:remove();
			return;
		end
		-- see in util.add_tutorial
		local flag, not_remove = cb();
		if true ~= flag or true ~= not_remove then
			self:remove();
			return;
		end
	end,

	onTouchBegan = function(self, x, y)
		-- flag==false means touching bright area, true==other area
		local flag = self:check_touch(x, y);
		-- if this is last touch of tutor(cb==nil)
		-- AND touching the bright area(flag==false)
		-- then close layer immediately to let the underlying layer
		-- get the touch signal
		if false == flag and nil == self.callback then -- tap the area
			self.to_close();
		end
		return true;
	end,

	onTouchMoved = function(self, x, y)
		return false;
	end,

	onTouchEnded = function(self, x, y)
		if true == g_is_in_tutor then
			local flag = self:check_touch(x, y);
			if false == flag and nil ~= self.callback then -- tap the area
				self.to_close();
			end
		else
			self.to_close();
		end
		return false;
	end,

} -- layer_tutorial end


layer_dragtutorial = {
	name = 'layer_dragtutorial',
	layer = nil,
	callback = nil,

	cliplist = nil,
	fdata = nil,
	tdata = nil,
	tp = nil, -- touch point
	line = nil,
	tip = nil,
	board = nil,

	cleanup = function(self)
		self.layer = nil;
		cliplist = nil;
		self.fdata = nil;
		self.tdata = nil;
		self.tp = nil;
		self.line = nil;
		self.tip = nil;
		self.board = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, cliplist, fdata, tdata, pos, tip, callback)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_DRAGTUTOR, self.handler, true);

		self:init_clip_view(cliplist);
		self:init_finger(fdata, tdata);
		self:init_tip_view(cliplist, pos, tip)
		self.callback = callback;
		self.fdata = fdata;
		self.tdata = tdata;

		return self.layer, self.name;
	end,

	get_sprite_data = function(sprite, use_circle)
		local x, y = sprite:getPosition();
		local size = sprite:getContentSize();
		local width = size.width;
		local height = size.height;
		local scale = sprite:getScale();
		local data = { x=x, y=y, width=width*scale, height=height*scale, use_circle=use_circle };
		return data;
	end,

	init_clip_view = function(self, cliplist)
		cliplist = cliplist or {}
		local layer_color = cc.LayerColor:create(ccc4(0, 0, 0, 180));
		local pclip = cc.ClippingNode:create();
		pclip:setInverted(true);
		pclip:addChild(layer_color);

		local pstencil = cc.DrawNode:create();
		local fill_color = cc.c4f(1, 0, 0, 1);
		local border_color = cc.c4f(1, 0, 0, 1);
		for i = 1, #cliplist do
			local verts = {};
			local data = cliplist[i];
			local x = data.x;
			local y = data.y;
			local width = data.width;
			local height = data.height;
			local use_circle = data.use_circle;
			if true == use_circle then
				local radius;
				if width > height then
					radius = width/2;
				else
					radius = height/2;
				end
				local count = 200;
				local m_pi = 3.1415926;
				local angel = 2.0 * m_pi / count;
				for i = 0, count - 1 do
					local radian = i * angel;
					local cx = radius * math.cos(radian);
					local cy = radius * math.sin(radian);
					table.insert(verts, cc.p(x+cx, y+cy));
				end
			else
				local hw = width/2;
				local hh = height/2;
				verts = {
					cc.p(x-hw, y-hh);
					cc.p(x+hw, y-hh);
					cc.p(x+hw, y+hh);
					cc.p(x-hw, y+hh);
				};
			end
			pstencil:drawPolygon(verts, #verts, fill_color, 0, border_color);
		end

		pstencil:setPosition(cc.p(0, 0));
		pclip:setStencil(pstencil);
		self.layer:addChild(pclip, 50);
	end,

	init_finger = function(self, fdata, tdata)
		if nil == fdata then
			return;
		end

		local fpos = cc.p(fdata.x, fdata.y);
		if nil == tdata then
			util.play_frame(self.layer, 'tutor_finger', fpos, ANCHOR_LEFT_CENTER, 0.2, 70, true);
			return;
		end
		local tpos = cc.p(tdata.x, tdata.y);
		local finger = util.play_frame(self.layer, 'tutor_finger', fpos, ANCHOR_LEFT_CENTER, 0.1, 70, false);
		local dis = math.sqrt(math.pow((tpos.x-fpos.x), 2) + math.pow((tpos.y-fpos.y), 2));
		local speed = 200;
		local t = dis/speed;
		local array = {};
		table.insert(array, cc.MoveTo:create(t, tpos));
		table.insert(array, cc.MoveTo:create(0.1, fpos));
		finger:runAction(cc.RepeatForever:create(cc.Sequence:create(array)));
	end,

	init_tip_view = function(self, cliplist, pos, tip)

		if nil ~= self.tip then
			self.tip:removeFromParentAndCleanup(true);
		end
		if nil ~= tip then
			local size = cc.size(FULL_WIDTH/4*3, HALF_HEIGHT/4);
			if nil == pos then
				pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
				size = cc.size(FULL_WIDTH/2, HALF_HEIGHT/4);
				--[[
				for i=1, #(cliplist or {}) do
					local area = cliplist[i];
					if ((pos.x >= area.x and pos.x < area.x + area.width)
					or (area.x >= pos.x and area.x < pos.x + size.width))
					and ((pos.y >= area.y and pos.y < area.y + area.height)
					or (area.y >= pos.y and area.y < pos.y + size.height))
					then
						
						size = cc.size(FULL_WIDTH/8*5, HALF_HEIGHT/4*3);
						break
					end
				end
				]]--
			end


			self.tip = util.add_labelsys(self.layer, tip, nil, 25, pos, util.c_white, ANCHOR_CENTER_CENTER, 60, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
			local s = self.tip:getContentSize();
			size = cc.size(s.width + wfix(80), s.height + hfix(40));
			if nil ~= self.board then
				self.board:removeFromParentAndCleanup(true);
			end

			local path = util.get_path('pop_up.png');
			local frect = cc.rect(0, 0, 64, 64); -- fullrect
			local irect = cc.rect(30, 30, 4, 4); -- insetrect
			self.board = util.add_scale9sprite(self.layer, path, pos, ANCHOR_CENTER_CENTER, frect, irect, size, 55); 
		elseif nil ~= self.board then
			self.board:removeFromParentAndCleanup(true);
		end

	end,

	handler = function(event, x, y)
		local self = layer_dragtutorial;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
			util.free_ram();
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		self.tp = nil;
		if nil ~= self.line then
			self.line.batch:removeFromParentAndCleanup(true);
			self.line = nil;
		end
		if nil ~= self.fdata then
			local hw = self.fdata.width/2;
			local hh = self.fdata.height/2;
			if true == self.fdata.use_circle then
				local t = hw;
				if hh > hw then
					t = hh;
				end
				hw = t;
				hh = t;
			end
			local x1 = self.fdata.x - hw;
			local y1 = self.fdata.y - hh;
			local x2 = self.fdata.x + hw;
			local y2 = self.fdata.y + hh;
			if x > x1 and x < x2 and y > y1 and y < y2 then
				self.tp = cc.p(x, y);
			end
		end
		return true;
	end,

	onTouchMoved = function(self, x, y)
		if nil == self.tp then return; end
		if nil == self.tdata then return; end
		local ttt = self.tp;
		if nil == self.line then
			local path = util.get_path('dragline.plist');	
			self.line = util.add_particle(self.layer, path, ttt, 60);
		end
		local pp = cc.p(x-ttt.x, y-ttt.y);
		local r = math.atan2(pp.y, pp.x);
		local r1 = r * 360 / ( 2 * 3.14 );
		local r2 = 90 - r1;
		local offset = math.sqrt(math.pow(pp.x, 2) + math.pow(pp.y, 2));
		local spos = self.line.emitter:getPosVar();
		spos.y = offset*0.5;
		self.line.emitter:setPosVar(spos);
		local pos = cc.p(pp.x/2+ttt.x, pp.y/2+ttt.y);
		self.line.batch:setPosition(pos);
		self.line.batch:setRotation(r2);
	end,

	onTouchEnded = function(self, x, y)
		if nil == self.fdata and nil == self.tdata then
			self:remove();
			if nil ~= self.callback then self.callback(); end
			return;
		end
		if nil == self.tp then return; end
		self.tp = nil;
		if nil == self.tdata then
			self:remove();
			if nil ~= self.callback then self.callback(); end
			return;
		end
		if nil ~= self.line then
			self.line.batch:removeFromParentAndCleanup(true);
			self.line = nil;
		end
		if nil ~= self.tdata then
			local hw = self.tdata.width/2;
			local hh = self.tdata.height/2;
			if true == self.fdata.use_circle then
				local t = hw;
				if hh > hw then
					t = hh;
				end
				hw = t;
				hh = t;
			end
			local x1 = self.tdata.x - hw;
			local y1 = self.tdata.y - hh;
			local x2 = self.tdata.x + hw;
			local y2 = self.tdata.y + hh;
			if x > x1 and x < x2 and y > y1 and y < y2 then
				self:remove();
				self.callback();
				return;
			end
		end
	end,

} -- layer_dragtutorial end

layer_horselamp = {
	name = 'layer_horselamp',
	list = {},
	layer = nil,
	count = nil,
	label = nil,
	bg_width = nil,
	label_width = nil,

	cleanup = function(self)
		self.layer = nil;
		self.count = nil;
		self.label = nil;
		self.bg_width = nil;
		self.label_width = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_HORSELAMP, self.handler,false);

		local info = self.list[1];
		local msg, count;
		if nil == info then
			msg = '???';
			count = 1;
		else
			msg = info.msg;
			count = info.count;
		end
		self.count = count;
		local bgpos = cc.p(HALF_WIDTH, FULL_HEIGHT-hfix(160));
		local pclip = cc.ClippingNode:create();
		self.layer:addChild(pclip);
		local path = util.get_fullpath(F_IMAGE, 'bg_horselamp.png');
		local bg = util.add_sprite(pclip, path, bgpos, ANCHOR_CENTER_DOWN);
		local size = bg:getContentSize();
		self.bg_width = size.width;
		self.offsetx = size.width;
		pos = cc.p(size.width, 0);
		self.label = util.add_labelttf(bg, msg, nil, 40, pos, util.c4b_white, ANCHOR_LEFT_DOWN, 10);
		self.label_width = self.label:getContentSize().width;
		local fill_color = cc.c4f(1, 0, 0, 1);
		local border_color = cc.c4f(1, 0, 0, 1);
		local hwidth = size.width/2;
		local verts = {
			cc.p(-hwidth, 0);
			cc.p(hwidth, 0);
			cc.p(hwidth, size.height);
			cc.p(-hwidth, size.height);
		};
		local pstencil = cc.DrawNode:create();
		pstencil:drawPolygon(verts, #verts, fill_color, 0, border_color);
		pstencil:setPosition(bgpos);
		pclip:setStencil(pstencil);
		self.layer:scheduleUpdateWithPriorityLua(self.update, 1);

		return self.layer, self.name;
	end,

	update = function(delta)
		local self = layer_horselamp;

		self.offsetx = self.offsetx - wfix(3);
		self.label:setPosition(cc.p(self.offsetx, 0));
		if self.offsetx < -self.label_width then
			self.offsetx = self.bg_width;
			self.count = self.count - 1;
			if 1 > self.count then
				table.remove(self.list, 1);
				self:check_next();
			end
		end
	end,

	check_next = function(self)
		if 0 == #self.list then
			self:remove()
			return;
		end
		local info = self.list[1];
		local msg, count;
		if nil == info then
			msg = '???';
			count = 1;
		else
			msg = info.msg;
			count = info.count;
		end
		self.label:setString(msg);
		self.count = count;
	end,

	handler = function(event, x, y)
		local self = layer_horselamp;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
	end,
} -- layer_horselamp end

layer_grave = { -- layer_grave start
	name = 'layer_grave',
	layer = nil,
	table_view = nil,
	list = nil,
	slist = nil,
	tlist = nil,
	target_list = nil,
	cwidth = nil, -- cell width
	cheight = nil, -- cell height
	scale = nil, -- card scale

	cleanup = function(self)
		self.layer = nil;
		self.table_view = nil;
		self.list = {};
		self.slist = {};
		self.tlist = {};
		self.target_list = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.scale = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, list)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_GRAVE, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 128));
		self.target_list = {};
		self.list = {};
		for i = #list, 1, -1 do
			--table.insert(self.list, list[i]);
			local info = list[i];
			local cid = info.card.id;
			local index = cindex(info.card);
			table.insert(self.list, { cid = cid, index = index });
		end
		self:set_selectable_list();

		-- table view: FULL_WIDTH, hfix(700)
		-- cell: hfix(400), hfix(700)  -- both use hfix to keep scale same
		local size, pos;
		size = cc.size(FULL_WIDTH, hfix(700));
		--self.cwidth = size.width/1.5;
		self.cwidth = hfix(400);
		self.cheight = size.height;
		pos = cc.p(wfix(0), hfix(160));
		-- card scale
		self.scale = (self.cwidth - hfix(70)) / CARD_SIZE.width;
		---
		self.table_view = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_HORIZONTAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, 1);

		local items = {};
		local item;
		local size = cc.size(172, 52);

		pos = ccp(HALF_WIDTH, hfix(40));
		item = add_item_1(items, '关闭', nil, 20, self.callback_close, ANCHOR_CENTER_DOWN, pos, size);

		util.add_menu(self.layer, items);

		return self.layer, self.name;
	end, 

	set_selectable_list = function(self)
		self.slist = {};
		if nil == g_src_index then
			return self.slist;
		end
		self.target_list = {};
		local num;
		local err;
		num, err = total_target(g_src_index, g_logic_table, g_current_side)
		local ability_target_indexs = list_ability_target(g_src_index, g_logic_table, g_current_side, self.target_list, #self.target_list + 1);
		self.slist = ability_target_indexs;
		return self.slist;
	end,

	handler = function(event, x, y)
		self = layer_grave;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,

	callback_close = function()
		play_tap_1();
		local self = layer_grave;
		local need_clean = false;
		if 0 < #(self.target_list or {}) then
			need_clean = true;
		end
		self:remove();
		if true == need_clean then
			g_src_index = 0;
			g_action_type = TYPE_NONE;
			refresh_layer_card();
		end
	end,

	callback_target = function(...)
		play_tap_1();
		local self = layer_grave;
		local args = {...};
		local index = args[2]:getTag();
		print('DEBUG g_layer_grave callback_target: ', tag);

		table.insert(self.target_list, index);
		local ability_target_indexs = list_ability_target(g_src_index, g_logic_table, g_current_side, self.target_list, #self.target_list + 1);
		if 0 == #(ability_target_indexs or {}) then
			layer_card:clean_menu();

			local cmd = 'b ' .. g_src_index ;
			for i=1, #self.target_list do
				cmd = cmd .. ' ' .. self.target_list[i];
			end
			self.callback_close();
			play_game_cmd(cmd);

			return;
		end
		self:set_selectable_list();
		self.table_view:reloadData();
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_grave;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			--local cell = args[3];
			--local idx = cell:getIdx();
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight ,self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local info = self.list[idx + 1];
			local cid = info.cid;
			local index = info.index;
			--print('------- cid, index: ', cid, index);
			local card = clone(g_card_list[cid]);
			local size = cc.size(self.cwidth, self.cheight);
			local pos = ccp(size.width/2, size.height/2 + hfix(60));
			--local sprite = info:get_grave_sprite(cell, pos, 0, self.scale);
			--local new_info = info:copy(cell, STYPE_VER_1, nil, self.scale, nil);
			local cobj = object_card:new(cell, card, nil, nil, pos, 0, 1, STYPE_VER_1);
			local sprite = cobj:get_front();
			g_sprite_cache[cobj.card] = nil; -- don't put sprite in g_sprite_cache

			local is_target = false;
			for i = 1, #self.slist do
				--local index = cindex(card);
				local sindex = self.slist[i];
				if index == sindex then
					local items = {};
					local item;
					local size = cc.size(172, 52);

					pos = ccp(self.cwidth/2, 0);
					item = add_item_1(items, '目标', nil, 20, self.callback_target, ANCHOR_CENTER_DOWN, pos, size);
					local offsetx = item:getContentSize().width/2;
					item:setTag(index);

					util.add_menu(cell, items);
					break;
				end
			end
			return cell;
		end
	end, -- tableview_handler end }

} -- layer_grave end

layer_pay = { -- start
	name = 'layer_pay',
	layer = nil,
	pay_type = nil,
	time = nil,
	list = nil,
	tableview = nil,
	cwidth = nil,
	cheight = nil,
	theight = nil,
	rect = nil,
	data_cell = nil,

	cleanup = function(self)
		self.layer = nil;
		self.time = nil;
		self.pay_type = nil;
		self.list = nil;
		self.tableview = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.theight = nil;
		self.rect = nil;
		self.data_cell = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_PAY, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));
		self.pay_type = 0;
		self.list = {};
		local data;
		local offsetheight, sprite, rect = init_bg_for_view(self.layer, GUI_PAY, '充值', self.back);
		self.rect = rect;

		gui_add_sprite(self.layer, 'bg_ad', GUI_PAY,ANCHOR_UP);

		data = gui_get_data('cell', GUI_PAY, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height + 10;
		data = gui_get_data('table', GUI_PAY, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		self.theight = size.height;
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos,cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		local items = {};
		local item;

		item, data = gui_add_item(items, 'rw_1', GUI_PAY, self.cb_rw_1,ANCHOR_UP);
		item, data = gui_add_item(items, 'rw_2', GUI_PAY, self.cb_rw_2,ANCHOR_UP);

		util.add_menu(self.layer, items, data.zorder);

		return self.layer, self.name;
	end, 

	rw_show = function(self, cid)
		local card = clone(g_card_list[cid]);
		if nil == card then card = clone(hero_list[cid]); end
		if nil == card then return; end
		g_scene:add_layer(ZORDER_LAYER_MISPOP, layer_mispop:create(card));
	end,

	cb_rw_1 = function()
		play_tap_1();
		local self = layer_pay;
		self:rw_show(5);
	end,

	cb_rw_2 = function()
		play_tap_1();
		local self = layer_pay;
		self:rw_show(71);
	end,

	reload = function(self)
		self.tableview:reloadData();
	end,

	add_list = function(self, pay_type, list)
		self.pay_type = pay_type;
		self.list = list or {};
		self:reload();
	end,

	handler = function(event, x, y)
		self = layer_pay;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		local r = self.rect;
		if nil == r then
			return;
		end
		if x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2 then
			self.back();
		end
	end,

	back = function()
		play_tap_1();
		local self = layer_pay;
		self:remove();
		if is_ver(VER_ANYSDK) or is_ver(VER_ANYSDK_NO_LOGIN) then
			ProtocolIAP:resetPayState();
		end
		if nil ~= layer_lottery.layer then
			layer_lottery:remove();
		end
		util.trigger_tutor(TUTOR_DECK);
	end,

	request_ucsdk = function(self, index)
		local info = self.list[index];
		if nil == info then
			return;
		end
		local payCode = info.pay_code .. '';
		local serverId = util.get_server_id(util.load_server(), IP_ADDR) .. '';
		print('ip, payCode, serverId: ', IP_ADDR, payCode, serverId);
		local payPrice = math.floor(tonumber(info.pay_price or '0') / 100) .. '';
		local eid = g_euser.eid .. '';
		local alias = g_euser.alias .. '';
		local crystal = g_euser.crystal .. '';
		local level = g_euser.level .. '';
		--local money = info.money or 0;

		serverId = 1;
		show_netloading();
		local xhr = cc.XMLHttpRequest:new();
		xhr.responseType = cc.XMLHTTPREQUEST_RESPONSE_STRING;
		local r = string.format("http://%s:8899/pay_server/order?playerId=%d&serverId=%s&payCode=%s", IP_ADDR, tonumber(g_euser.eid), serverId, payCode);
		print('iap get order_no address=', r);
		xhr:open("GET", r);
		local function callback_xhr()
			hide_netloading();
			local status = "Http Status Code:" .. xhr.statusText;
			local order_no = xhr.response;
			order_no = string.gsub(order_no, "\n", "");
			if (tonumber(order_no) or -1) < 0 then
				local tip = string.format("获取订单失败 %s", order_no);
				g_scene:add_layer(ZORDER_LAYER_MSG, layer_msg:create(tip));
				return;
			end
			print('iap ----- status: ', status);
			print('iap ----- order_no: ', order_no);
			local allowContinuousPay = true;
			local amount = payPrice;
			local serverId = 0;
			local pszRoleId = eid;
			local pszRoleName = alias;
			local pszGrade = level;
			local pszCustomInfo = order_no;
			local pszNotifyUrl = string.format("http://%s:8899/pay_server/ucpay?", IP_ADDR);
			local pszTransactionNum = "0";
			
			UCSdkHandler:pay(allowContinuousPay, amount, serverId, pszRoleId, pszRoleName, pszGrade, pszCustomInfo, pszNotifyUrl, pszTransactionNum);
			return;
		end
		xhr:registerScriptHandler(callback_xhr);
		xhr:send();
	end,

	request_anysdk = function(self, index)
		local info = self.list[index];
		if nil == info or nil == g_anysdk_plugin then
			return;
		end
		local payCode = info.pay_code .. '';
		local serverId = util.get_server_id(util.load_server(), IP_ADDR) .. '';
		print('ip, payCode, serverId: ', IP_ADDR, payCode, serverId);
		local payPrice = math.floor(tonumber(info.pay_price or '0') / 100) .. '';
		local eid = g_euser.eid .. '';
		local crystal = g_euser.crystal .. '';
		local level = g_euser.level .. '';
		--local money = info.money or 0;

		serverId = 1; -- hardcode serverId to 1;
		show_netloading();
		local xhr = cc.XMLHttpRequest:new();
		xhr.responseType = cc.XMLHTTPREQUEST_RESPONSE_STRING;
		local r = string.format("http://%s:8899/pay_server/order?playerId=%d&serverId=%s&payCode=%s", IP_ADDR, tonumber(g_euser.eid), serverId, payCode);
		print('iap get order_no address=', r);
		xhr:open("GET", r);
		local function callback_xhr()
			hide_netloading();
			local status = "Http Status Code:" .. xhr.statusText;
			local order_no = xhr.response;
			order_no = string.gsub(order_no, "\n", "");
			if (tonumber(order_no) or -1) < 0 then
				local tip = string.format("获取订单失败 %s", order_no);
				g_scene:add_layer(ZORDER_LAYER_MSG, layer_msg:create(tip));
				return;
			end
			print('iap ----- status: ', status);
			print('iap ----- order_no: ', order_no);
			local agent = AgentManager:getInstance();
			local iap_plugin_maps = agent:getIAPPlugin();
			local info = {
				Product_Price = payPrice,
				Product_Id = payCode,
				Product_Name = info.title,
				Server_Id = serverId,
				Product_Count = "1",  
				Role_Id = eid,
				Role_Grade = level,
				Role_Balance = crystal,
				Role_Name = g_euser.alias,
				EXT = order_no
			};
			local cid = tonumber(agent:getChannelId() or "0");
			if cid == 20 then
				info.Product_Name = "个(" .. info.Product_Name .. ")";
			end
			g_anysdk_plugin:payForProduct(info);
			return;
		end
		xhr:registerScriptHandler(callback_xhr);
		xhr:send();
	end,

	request_ljsdk = function(self, index)
		local info = self.list[index];
		if nil == info then
			return;
		end
		local payCode = info.pay_code or '';
		local serverId = util.get_server_id(util.load_server(), IP_ADDR) .. '';
		print('ip, payCode, serverId: ', IP_ADDR, payCode, serverId);
		local payPrice = math.floor(tonumber(info.pay_price or '0')) .. '';
		local unitName = info.title or '';
		local count = info.money;
		local eid = g_euser.eid .. '';
		local crystal = g_euser.crystal .. '';
		local level = g_euser.level .. '';

		serverId = 1; -- hardcode serverId to 1;
		show_netloading();
		local xhr = cc.XMLHttpRequest:new();
		xhr.responseType = cc.XMLHTTPREQUEST_RESPONSE_STRING;
		local r = string.format("http://%s:8899/pay_server/order?playerId=%d&serverId=%s&payCode=%s", IP_ADDR, tonumber(g_euser.eid), serverId, payCode);
		print('iap get order_no address=', r);
		xhr:open("GET", r);
		local function callback_xhr()
			hide_netloading();
			local status = "Http Status Code:" .. xhr.statusText;
			local order_no = xhr.response;
			order_no = string.gsub(order_no, "\n", "");
			if (tonumber(order_no) or -1) < 0 then
				local tip = string.format("获取订单失败 %s", order_no);
				g_scene:add_layer(ZORDER_LAYER_MSG, layer_msg:create(tip));
				return;
			end
			print('iap ----- status: ', status);
			print('iap ----- order_no: ', order_no);
			local callbackUrl = string.format("http://%s:8899/pay_server/ljsdkpay", IP_ADDR);
			-- TODO: pay
			LJSdkImpl:pay(payPrice, '水晶', count, order_no, callbackUrl, layer_net.layer);
			return;
		end
		xhr:registerScriptHandler(callback_xhr);
		xhr:send();
	end,

	request_appstore = function(self, index)
		local info = self.list[index];
		if nil == info then
			return;
		end
		local payCode = info.pay_code;
		local serverId = util.get_server_id(util.load_server(), IP_ADDR);
		print('ip, payCode, serverId: ', IP_ADDR, payCode, serverId);
		-- exmaple: "http://211.149.186.201:8899/pay_server/order?playerId=1074&serverId=1&payCode=41"
		serverId = 1; -- hardcode serverId to 1;
		show_netloading();
		local xhr = cc.XMLHttpRequest:new();
		xhr.responseType = cc.XMLHTTPREQUEST_RESPONSE_STRING;
		local r = string.format("http://%s:8899/pay_server/order?playerId=%d&serverId=%s&payCode=%s", IP_ADDR, tonumber(g_euser.eid), serverId, payCode);
		print('iap get order_no address=', r);
		xhr:open("GET", r);
		local function callback_xhr()
			hide_netloading();
			local status = "Http Status Code:" .. xhr.statusText;
			local order_no = xhr.response;
			order_no = string.gsub(order_no, "\n", "");
			if (tonumber(order_no) or -1) < 0 then
				local tip = string.format("获取订单失败 %s", order_no);
				g_scene:add_layer(ZORDER_LAYER_MSG, layer_msg:create(tip));
				return;
			end
			print('iap ----- status: ', status);
			print('iap ----- order_no: ', order_no);
			local platform = cc.Application:getInstance():getTargetPlatform();
			if platform ~= cc.PLATFORM_OS_IPHONE and platform ~= cc.PLATFORM_OS_IPAD then
				return;
			end
			local url = string.format("http://%s:8899/pay_server/apple?", IP_ADDR);
			--local url = string.format("http://192.168.1.33:8899/pay_server/apple?", IP_ADDR);
			--local url = string.format("http://%s:8080/pay_server/apple?", "192.168.1.22");
			local mode = '1'; -- mode 0->test 1->official
			if true == DEBUG_MODE then
				mode = '0';
			end
			local product_id = string.format("%d", payCode);
			g_scene:add_layer(ZORDER_LAYER_APPSTOREPAY, layer_appstorepay:create());
			local args = { 
				product_id = product_id, handler = layer_appstorepay.callback,
				url = url, mode = mode, order_no = order_no,
			};
			local luaoc = require "luaoc";
			local class_name = "IAPView";
			local ok, ret = luaoc.callStaticMethod(class_name, "requestAppStorePay",args);
			return;
		end
		xhr:registerScriptHandler(callback_xhr);
		xhr:send();
	end,

	request_apay = function(self, index)
		local info = self.list[index];
		if nil == info then
			return;
		end
		local payCode = info.pay_code;
		local serverId = util.get_server_id(util.load_server(), IP_ADDR);
		print('ip, payCode, serverId: ', IP_ADDR, payCode, serverId);
		-- exmaple: "http://211.149.186.201:8899/pay_server/order?playerId=1074&serverId=1&payCode=41"
		serverId = 1; -- hardcode serverId to 1;
		show_netloading();
		local xhr = cc.XMLHttpRequest:new();
		xhr.responseType = cc.XMLHTTPREQUEST_RESPONSE_STRING;
		local r = string.format("http://%s:8899/pay_server/order?playerId=%d&serverId=%s&payCode=%s", IP_ADDR, tonumber(g_euser.eid), serverId, payCode);
		xhr:open("GET", r);
		local function callback_xhr()
			hide_netloading();
			local status = "Http Status Code:" .. xhr.statusText;
			local order_no = xhr.response;
			order_no = string.gsub(order_no, "\n", "");
			if (tonumber(order_no) or -1) < 0 then
				local tip = string.format("获取订单失败 %s", order_no);
				g_scene:add_layer(ZORDER_LAYER_MSG, layer_msg:create(tip));
				return;
			end
			print('----- status: ', status);
			print('----- order_no: ', order_no);
			local mflag = 2; -- 1 test, 2 product
			if true == DEBUG_MODE then
				mflag = 1;
			end
			local mode = nil; -- "01" is testing, "00" is product
			local servlet = nil;
			if 1 == mflag then
				mode = "01";
				servlet = "allinpaydebug";
			else
				mode = "00";
				servlet = "allinpay";
			end
			local merchantId = "109020201409007";
			local platform = cc.Application:getInstance():getTargetPlatform();
			if platform == cc.PLATFORM_OS_IPHONE or platform == cc.PLATFORM_OS_IPAD then
				g_scene:add_layer(ZORDER_LAYER_APPSTOREPAY, layer_appstorepay:create());
				local args = { 
					merchantId = merchantId,
					orderNo = order_no, 
					receiveUrl = string.format("http://%s:8899/pay_server/%s", IP_ADDR, servlet),
					productName = info.description,
					price = info.pay_price,
					handler = layer_appstorepay.callback,
					mode = mode,
				};
				local luaoc = require "luaoc";
				local class_name = "APayView";
				local ok, ret;
				ok, ret = luaoc.callStaticMethod(class_name,"requestAPay",args);
			elseif platform == cc.PLATFORM_OS_ANDROID then
				g_scene:add_layer(ZORDER_LAYER_APPSTOREPAY, layer_appstorepay:create());
				local args = { 
					merchantId, order_no, string.format("http://%s:8899/pay_server/%s", IP_ADDR, servlet), info.description, info.pay_price, mode, layer_appstorepay.callback,
				};
				local sigs = "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;I)V";
				local luaj = require "luaj";
				local class_name = "org/cocos2dx/lua/AppActivity";
				local ok, ret = luaj.callStaticMethod(class_name, "requestAPay", args, sigs);
			end
			return;
		end
		xhr:registerScriptHandler(callback_xhr);
		xhr:send();
	end,

	request_pay = function(self, index)
		local info = self.list[index];
		if nil == info then
			return;
		end
		local time = os.date("%y%m%d%H%M%S", os.time());
		if time == self.time then
			-- prevent create same order cos tap too fast
			return;
		end
		self.time = time;
		local pay_type = self.pay_type;
		local pay_code = info.pay_code;
		local pay_price = info.pay_price;
		local money_type = info.money_type;
		local money = info.money;
		local server_id = 1; -- hard code
		local player_id = g_euser.eid;
		local trade_no = time .. '_' .. pay_type .. '_' .. pay_code .. '_';
		trade_no = trade_no .. pay_price .. '_' .. money_type .. '_' .. money;
		trade_no = trade_no .. '_' .. server_id .. '_' .. player_id;
		--print('trade_no: ', trade_no);

		local desc = info.description or '';
		local platform = cc.Application:getInstance():getTargetPlatform();
		if platform == cc.PLATFORM_OS_IPHONE or platform==cc.PLATFORM_OS_IPAD then
			local args = { 
				trade_no = trade_no, title = "玛莎还没弄", desc = desc, 
				price = pay_price,
			};
			local luaoc = require "luaoc";
			local class_name = "SysTool";
			local ok, ret = luaoc.callStaticMethod(class_name, "requestPay",args);
		elseif platform == cc.PLATFORM_OS_ANDROID then
			--[[
			local args = { 
				trade_no, "玛莎还没弄", desc, pay_price,
			};
			local sigs = "(Ljava/lang/String;I)V";
			local luaj = require "luaj";
			local class_name = "org/cocos2dx/lua/AppActivity";
			local ok, ret = luaj.callStaticMethod(class_name, "openURL", args, sigs);
			]]--
		end
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_pay;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			--self:request_pay(idx + 1);
			if is_ver(VER_ANYSDK) or is_ver(VER_ANYSDK_NO_LOGIN) then
				self:request_anysdk(idx + 1);
			elseif is_ver(VER_APPSTORE) then
				self:request_appstore(idx + 1);
			elseif is_ver(VER_APAY) then
				self:request_apay(idx + 1);
			elseif is_ver(VER_UCSDK) then
				self:request_ucsdk(idx + 1);
			elseif is_ver(VER_LJSDK) then
				self:request_ljsdk(idx + 1);
			else
				show_msg("充值尚未开放");
			end
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight ,self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local info = self.list[idx + 1];
			local money_type = info.money_type;
			local sprite, data2, str, fsize, path, scale;
			gui_add_sprite_on_cell(cell, data, 'bg_c_title', GUI_PAY,ANCHOR_DOWN);
			gui_add_sprite_on_cell(cell, data, 'bg_icon', GUI_PAY, ANCHOR_DOWN);
			str = info.title or '';
			gui_add_label_on_cell(cell,data,str,28,'c_title',GUI_PAY,ANCHOR_DOWN);
			str = info.description or '';
			if string.len(str) > 11 then
				fsize = 17;
			else
				fsize = 20;
			end
			gui_add_label_on_cell(cell,data,str,fsize,'desc',GUI_PAY,ANCHOR_DOWN);
			path = util.get_path(FNT_1);
			str = math.floor(tonumber(info.pay_price or '0') / 100);
			gui_add_labelbmf_on_cell(cell,data,str,path,'price',GUI_PAY,ANCHOR_DOWN);
			if 1 == money_type then
				-- icon has 10, 14, 15, 16, 17
				data2, scale = gui_get_data('icon', GUI_PAY, ANCHOR_DOWN);
				local fname = nil;
				if nil ~= string.find(info.title, '月卡') then
					fname = 'icon_vip1.png';
				elseif info.money < 100 then
					fname = 'icon_29.png';
				elseif info.money < 500 then
					fname = 'icon_30.png';
				elseif info.money < 1000 then
					fname = 'icon_31.png';
				elseif info.money < 5000 then
					fname = 'icon_32.png';
				else --if info.money >= 5000 then
					fname = 'icon_33.png';
				end
				pos = cc.p(data2.x-data.x, data2.y-data.y);
				path = util.get_path(fname);
				sprite = util.add_sprite(cell, path, pos, ANCHOR_LEFT_DOWN, data2.zorder);
				sprite:setScale(scale);
			end
			str = '元';
			gui_add_label_on_cell(cell,data,str,28,'yuan',GUI_PAY,ANCHOR_DOWN);
			
			return cell;
		end
	end, -- tableview_handler end }

} -- layer_pay end


layer_pay_ad = { -- start
	name = 'layer_pay_ad',
	layer = nil,

	cleanup = function(self)
		self.layer = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_PAY_AD, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));
		local data;
		local sprite;
		sprite, data = gui_add_sprite(self.layer, 'bg', GUI_PAY_AD,ANCHOR_UP);
		
		local offsety = HALF_HEIGHT - (data.y + data.height / 2);
		sprite:setPositionY(data.y + offsety);

		local item;
		local items = {};
		item,data =gui_add_item(items,'btn_charge',GUI_PAY_AD,self.charge,ANCHOR_UP);
		item:setPositionY(data.y + offsety);
		item,data =gui_add_item(items,'btn_back',GUI_PAY_AD,self.back,ANCHOR_UP);
		item:setPositionY(data.y + offsety);

		util.add_menu(self.layer, items, data.zorder);

		return self.layer, self.name;
	end, 

	back = function()
		play_tap_1();
		local self = layer_pay_ad;
		self:remove();
		if nil ~= layer_lottery.layer then
			layer_lottery:remove();
		end
		util.set_tutor(TUTOR_PAY_AD, true, true);
		util.trigger_tutor(TUTOR_DECK);
	end,

	charge = function()
		play_tap_1();
		local self = layer_pay_ad;
		self:remove();
		go_pay();
		util.set_tutor(TUTOR_PAY_AD, true, true);
	end,

	handler = function(event, x, y)
		self = layer_pay_ad;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
	end,

} -- layer_pay_ad end

layer_lguild = {
	name = 'layer_lguild',
	PAGE_SIZE = 15,
	layer = nil,
	list = nil,
	editbox = nil,
	tableview = nil,
	bar = nil,
	tap = nil,
	cwidth = nil,
	cheight = nil,
	data_cell = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.editbox = nil;
		self.tableview = nil;
		self.bar = nil;
		self.tap = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.data_cell = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();
		
		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_LGUILD, self.handler, true);

		self.list = {};
		-- btn back set in g_scene.lguild
		init_bg_for_full_view(self.layer, GUI_LGUILD, '公会列表');
		gui_add_sprite(self.layer, 'bg_search', GUI_LGUILD, ANCHOR_UP);
		gui_add_sprite(self.layer, 'bg2_search', GUI_LGUILD, ANCHOR_UP);
		local data;
		self.editbox, data = gui_add_editbox(self.layer, 'tip_search', GUI_LGUILD, ANCHOR_UP, 22, self.editbox_handler, 10, '请输入公会名称...');

		local has_guild = g_euser:has_guild();

		local items = {};
		local item;

		item, data = gui_add_item(items, 'btn_search', GUI_LGUILD, self.search, ANCHOR_UP);
		gui_add_text_on_sprite(item, "查找", 't_search', GUI_LGUILD,ANCHOR_UP,30);

		if true ~= has_guild then
			item, data = gui_add_item(items, 'btn_create', GUI_LGUILD, self.create_guild, ANCHOR_DOWN);
			gui_add_text_on_sprite(item, "创建公会", 't_create', GUI_LGUILD, ANCHOR_DOWN, 30);
		end

		util.add_menu(self.layer, items, data.zorder);

		local d1 = gui_get_data('table', GUI_LGUILD, ANCHOR_UP);
		local d2 = gui_get_data('table', GUI_LGUILD, ANCHOR_DOWN);
		local offsety = d1.y - d2.y;
		data = gui_get_data('cell', GUI_LGUILD, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height+10;
		data = gui_get_data('table', GUI_LGUILD, ANCHOR_DOWN);
		size = cc.size(data.width, data.height+offsety);
		pos = cc.p(data.x, data.y);
		if true == has_guild then
			local d = gui_get_data('btn_create', GUI_LGUILD, ANCHOR_DOWN);
			size.height = size.height + (pos.y - d.y);
			pos.y = d.y;
		end
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, ccp(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+10);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		return self.layer, self.name;
	end,

	back = function()
		play_tap_1();
		if true == g_euser:has_guild() and nil ~= g_euser.guild_data then
			g_scene:guild();
		else
			g_scene:map();
		end
	end,

	search = function()
		play_tap_1();
		local self = layer_lguild;
		local key = self.editbox:getText();
		local cmd = string.format("lguild %d %d %s", 0, self.PAGE_SIZE, key);
		net_send(cmd);
	end,

	get_more = function()
		play_tap_1();
		local self = layer_lguild;
		local key = self.editbox:getText();
		local len = #(self.list or {});
		if self.list[len].flag_more_cell == true then
			len = len - 1;
		end
		if len < 0 then len = 0; end
		local cmd = string.format("lguild %d %d %s", len, self.PAGE_SIZE, key);
		net_send(cmd);
	end,

	create_guild = function()
		play_tap_1();
		local gold = tonumber(g_constant.create_guild_gold);
		local crystal = tonumber(g_constant.create_guild_crystal);
		if nil == gold or nil == crystal then
			local cmd = 'cguild';
			net_send(cmd);
			return;
		end
		g_scene:add_layer(ZORDER_LAYER_CGUILD, layer_cguild:create(gold,crystal));
	end,

	apply = function(...)
		play_tap_1();
		local self = layer_lguild;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		local gid = info.gid;
		local cmd = 'gapply ' .. gid;
		net_send(cmd);
	end,

	cancel_apply = function()
		play_tap_1();
		local self = layer_lguild;
		local cmd = 'gquit';
		net_send(cmd);
	end,

	editbox_handler = function(eventname, psender)
		local self = layer_lguild;
		local edit = tolua.cast(psender, "cc.EditBox");
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
			local str = edit:getText();
			str = util.space_(str);
			edit:setText(str);
		elseif eventname == "changed" then
		end
	end,
	
	reload_data = function(self)
		self.tableview:reloadData();
	end,

	add_list = function(self, list, start_pos)
		list = list or {};
		local more_cell = { flag_more_cell = true };
		self.list = self.list or {};
		if 0 == start_pos then
			self.list = {};
		end
		if 0 < #self.list then
			local m = self.list[#self.list];
			if true == m.flag_more_cell then
				table.remove(self.list, #self.list);
			end
		end
		for i = 1, #list do
			table.insert(self.list, list[i]);
		end
		if self.PAGE_SIZE == #list then
			table.insert(self.list, more_cell);
		end

		self:reload_data();
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_lguild;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			play_tap_3();
			local cell = args[3];
			local idx = cell:getIdx();
			local info = self.list[idx + 1];
			local cmd = 'guild ' .. info.gid;
			net_send(cmd);
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local info = self.list[idx + 1];
			if true == info.flag_more_cell then
				local items = {};
				local pos = cc.p(width/2, height/2);
				local size = cc.size(172, 52);
				local item = add_item_1(items, '更多', nil, 20, self.get_more, ANCHOR_CENTER_CENTER, pos, size);
				item:setTag(idx + 1);

				util.add_menu(cell, items, 1);
				return cell;
			end
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local level = info.glevel or 0;
			local gid = info.gid;
			local gname = info.gname or '';
			local sprite, path, pos, size, str;
			str = gname;
			gui_add_label_on_cell(cell,data,str,25,'name',GUI_LGUILD,ANCHOR_DOWN);
			path = util.get_path('font_lv.fnt');
			str = 'LV.' .. level;
			gui_add_labelbmf_on_cell(cell,data,str,path,'lv',GUI_LGUILD,ANCHOR_DOWN);

			local items = {};
			local item, cb;

			local mygid = g_euser.gid or 0;
			local mygpos = g_euser.gpos or GUILD_POS_NONE;
			if mygid == 0 then
				cb = self.apply;
				str = '申请';
			elseif gid == mygid and mygpos == GUILD_POS_APPLY then
				cb = self.cancel_apply;
				str = '取消';
			else
				return cell;
			end
			item, data2 = gui_add_item_on_cell(items, data, 'btn_action', GUI_LGUILD, cb, ANCHOR_DOWN);
			gui_add_text_on_sprite(item,str,'t_action',GUI_LGUILD,ANCHOR_DOWN,30);
			item:setTag(idx + 1);

			util.add_menu(cell, items, data2.zorder);
			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_lguild;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.back();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
} -- layer_lguild end

layer_cguild = {
	name = 'layer_cguild',
	layer = nil,
	rect = nil,
	editbox = nil,
	gold = 0,
	crystal = 0,

	cleanup = function(self)
		self.layer = nil;
		self.rect = nil;
		self.editbox = nil;
		self.gold = 0;
		self.crystal = 0;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, gold, crystal)
		self:remove();

		self.gold = gold;
		self.crystal = crystal;
		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_CGUILD, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 200));
		local bgsize = cc.size(wfix(400), hfix(400));
		local bg,rect=init_bg_for_popview(self.layer,'创建公会',bgsize,self.back);
		self.rect = rect;

		local size = cc.size(wfix(300), hfix(71));
		local pos = cc.p(wfix(50), hfix(200));
		local tip = '请输入公会名称';
		self.editbox = add_editbox_1(bg, pos, size, tip, 20,self.editbox_handler);

		pos = cc.p(wfix(50), hfix(150));
		size = cc.size(wfix(120), hfix(70));
		tip = '所需费用:';
		util.add_labelttf(bg, tip, nil, 25, pos, util.c4b_white, ANCHOR_LEFT_DOWN, 20, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		pos = cc.p(wfix(170), hfix(150));
		add_icon_gold(bg, pos, ANCHOR_LEFT_DOWN, 20, wfix(1));

		pos = cc.p(wfix(230), hfix(150));
		gold = gold or 0;
		add_font_1(bg, gold, pos, ANCHOR_LEFT_DOWN, 20, wfix(1));

		local items = {};

		add_item_1(items, '创建', nil, 30, self.confirm_create, ANCHOR_CENTER_DOWN, cc.p(bgsize.width/2, hfix(30)));
		
		util.add_menu(bg, items, 50);

		return self.layer, self.name;
	end,

	editbox_handler = function(eventname, psender)
		local self = layer_cguild;
		local edit = tolua.cast(psender, "cc.EditBox");
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
		elseif eventname == "changed" then
		end

	end,

	confirm_create = function()
		local self = layer_cguild;
		local str = self.editbox:getText();
		str = util.space_(str);
		if 0 == string.len(str) then
			show_msg('起个名字先吧');
			return;
		end
		self:back();
		local cmd = 'cguild ' .. str;
		net_send(cmd);
	end,

	back = function()
		local self = layer_cguild;
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_cguild;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		local r = self.rect;
		if nil == r then
			return;
		end
		if x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2 then
			self.back();
		end
	end,

} -- layer_cguild end

layer_guild = {
	name = 'layer_guild',
	layer = nil,
	guild = nil,
	edit_rect = nil,
	editbox = nil,
	label_notice = nil,
	levelup_guild_gold = nil,
	guild_gold = nil,

	cleanup = function(self)
		self.layer = nil;
		self.guild = nil;
		self.edit_rect = nil;
		self.editbox = nil;
		self.label_notice = nil;
		self.levelup_guild_gold = nil;
		self.guild_gold = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, info)
		self:remove();
		
		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_GUILD, self.handler, true);

		local note = info.notice;
		self.guild = info;
		-- btn back set in g_scene.deck
		init_bg_for_full_view(self.layer, GUI_GUILD, '公会');
		local d1 = gui_get_data('bg_note', GUI_GUILD, ANCHOR_UP);
		local d2 = gui_get_data('bg_note', GUI_GUILD, ANCHOR_DOWN);
		local offsety = d1.y - d2.y;
		gui_add_sprite(self.layer, 'bg_note', GUI_GUILD, ANCHOR_DOWN, 0, offsety);
		gui_add_sprite(self.layer, 'bg_title_note', GUI_GUILD, ANCHOR_UP);
		local sprite, path, pos, data, str;
		str = info.gname;
		gui_add_label_ali(self.layer, str, 25, 'title_note', GUI_GUILD, ANCHOR_UP, cc.TEXT_ALIGNMENT_CENTER);
		path = util.get_path('font_lv.fnt');
		str = string.format("LV.%d", info.glevel);
		gui_add_labelbmf(self.layer, str, path, 'lv', GUI_GUILD, ANCHOR_UP);

		self.label_notice, data = gui_add_label_ali(self.layer, note, 30, 't_note', GUI_GUILD, ANCHOR_DOWN, cc.TEXT_ALIGNMENT_CENTER, nil, 0, offsety);
		self.label_notice:setVerticalAlignment(cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
		if info.gid == g_euser.gid then
			if info.gid == g_euser.eid then
				self.edit_rect = { x1 = data.x, x2 = data.x + data.width,
								   y1 = data.y,  y2 = data.y + data.height }; 
				self.editbox = util.add_editbox_blank(self.layer, 
					cc.size(data.width, data.height), ANCHOR_LEFT_DOWN, 
					cc.p(data.x, data.y), util.f_default, 22, util.c_white, 
					cc.EDITBOX_INPUT_MODE_SINGLELINE, cc.KEYBOARD_RETURNTYPE_DONE,
					nil,self.editbox_handler, 100, '', util.c_white, data.zorder);
				self.editbox:setText(note);
				self.editbox:setVisible(false);
			end
		end

		gui_add_sprite(self.layer, 'bg_detail', GUI_GUILD, ANCHOR_DOWN);
		gui_add_sprite(self.layer, 'bg_master', GUI_GUILD, ANCHOR_DOWN);
		gui_add_sprite(self.layer, 'bg_num', GUI_GUILD, ANCHOR_DOWN);
		gui_add_sprite(self.layer, 'bg_fund', GUI_GUILD, ANCHOR_DOWN);
		gui_add_sprite(self.layer, 'gold', GUI_GUILD, ANCHOR_DOWN);
		gui_add_sprite(self.layer, 'crystal', GUI_GUILD, ANCHOR_DOWN);
		str = '会长';
		gui_add_label(self.layer, str, 25, 't_master', GUI_GUILD, ANCHOR_DOWN);
		str = '人数';
		gui_add_label(self.layer, str, 25, 't_num', GUI_GUILD, ANCHOR_DOWN);
		str = '资金';
		gui_add_label(self.layer, str, 25, 't_fund', GUI_GUILD, ANCHOR_DOWN);
		str = info.master_alias or '';
		gui_add_label(self.layer, str, 22, 'master', GUI_GUILD, ANCHOR_DOWN);
		path = util.get_path(FNT_1);
		str = info.total_member or 0;
		str = str .. '/' .. (info.max_member or 0);
		gui_add_labelbmf(self.layer, str, path, 'num', GUI_GUILD, ANCHOR_DOWN);
		self.guild_gold = info.gold or 0;
		str = self.guild_gold;
		gui_add_labelbmf(self.layer, str, path, 'n_gold', GUI_GUILD, ANCHOR_DOWN);

		str = info.crystal or 0;
		gui_add_labelbmf(self.layer, str, path,'n_crystal',GUI_GUILD,ANCHOR_DOWN);


		if info.gid == g_euser.gid and g_euser.gpos ~= GUILD_POS_APPLY then
			local items = {};
			local item;

			item, data = gui_add_item(items, 'btn_list', GUI_GUILD, self.to_lguild, ANCHOR_DOWN);
			gui_add_text_on_sprite(item, "公会列表", 't_list', GUI_GUILD, ANCHOR_DOWN, 30);

			item, data = gui_add_item(items, 'btn_member', GUI_GUILD, self.action_guild, ANCHOR_DOWN);
			gui_add_text_on_sprite(item, "成员", 't_member', GUI_GUILD, ANCHOR_DOWN, 30);
			item:setTag(1);

			item, data = gui_add_item(items, 'btn_stock', GUI_GUILD, self.action_guild, ANCHOR_DOWN);
			gui_add_text_on_sprite(item, "股东", 't_stock', GUI_GUILD, ANCHOR_DOWN, 30);
			item:setTag(3);

			item, data = gui_add_item(items, 'btn_invest', GUI_GUILD, self.action_guild, ANCHOR_DOWN);
			gui_add_text_on_sprite(item, "投资", 't_invest', GUI_GUILD, ANCHOR_DOWN, 30);
			item:setTag(4);

			--item, data = gui_add_item(items, 'btn_welfare', GUI_GUILD, self.action_guild, ANCHOR_DOWN);
			--gui_add_text_on_sprite(item, "福利", 't_welfare', GUI_GUILD, ANCHOR_DOWN, 30);
			--item:setTag(5);

			if info.gid == g_euser.eid then
				item, data = gui_add_item(items, 'btn_dismiss', GUI_GUILD, self.action_guild, ANCHOR_DOWN);
				gui_add_text_on_sprite(item, "解散", 't_dismiss', GUI_GUILD, ANCHOR_DOWN, 30);
				item:setTag(6);

				item, data = gui_add_item(items, 'btn_apply', GUI_GUILD, self.action_guild, ANCHOR_DOWN);
				gui_add_text_on_sprite(item, "审批", 't_apply', GUI_GUILD, ANCHOR_DOWN, 30);
				item:setTag(2);

				item, data = gui_add_item(items, 'btn_upgrade', GUI_GUILD, self.action_guild, ANCHOR_DOWN);
				gui_add_text_on_sprite(item, "公会升级", 't_upgrade', GUI_GUILD, ANCHOR_DOWN, 30);
				item:setTag(7);
			
			elseif g_euser.gpos == GUILD_POS_SENIOR then
				item, data = gui_add_item(items, 'btn_apply', GUI_GUILD, self.action_guild, ANCHOR_DOWN);
				gui_add_text_on_sprite(item, "审批", 't_apply', GUI_GUILD, ANCHOR_DOWN, 30);
				item:setTag(2);

			else
				item, data = gui_add_item(items, 'btn_quit', GUI_GUILD, self.action_guild, ANCHOR_DOWN);
				gui_add_text_on_sprite(item, "退出", 't_quit', GUI_GUILD, ANCHOR_DOWN, 30);
				item:setTag(6);
			end

			util.add_menu(self.layer, items, data.zorder);
		end


		return self.layer, self.name;
	end,

	back = function()
		play_tap_1();
		local self = layer_guild;
		if self.guild.gid ~= g_euser.gid or g_euser.gpos == GUILD_POS_APPLY then
			g_scene:lguild();
			return;
		end
		g_scene:map();
	end,

	editbox_handler = function(eventname, psender)
		local self = layer_guild;
		local edit = tolua.cast(psender, "cc.EditBox");
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
			local str = edit:getText();
			str = util.space_(str);
			edit:setText(str);
			edit:setVisible(false);
			self.label_notice:setString(str);
			self.label_notice:setVisible(true);
			local cmd = 'guild ' .. g_euser.eid .. ' ' .. str;
			net_send(cmd);
		elseif eventname == "changed" then
		end
	end,

	action_guild = function(...)
		play_tap_1();
		local self = layer_guild;
		local args = {...};
		local index = args[2]:getTag();
		if 1 == index then -- member
			g_scene:lmember();
			return;
		elseif 2 == index then -- approve
			g_scene:lapply();
			return;
		elseif 3 == index then -- stock
			g_scene:lstock();
			return;
		elseif 4 == index then -- invest
			g_scene:invest();
			return;
		elseif 5 == index then -- welfare
			g_scene:welfare();
			return;
		elseif 6 == index then -- quit/dismiss
			local gid = tonumber(self.guild.gid);
			local eid = tonumber(g_euser.eid);
			local tip, cb;
			if gid == eid then
				tip = "是否解散公会？";
				cb = self.dismiss;
			else
				tip = "是否退出公会？";
				cb = self.leave_guild;
			end
			g_scene:add_layer(ZORDER_LAYER_TIP,layer_tip:create(tip, cb));
			return;
		elseif 7 == index then
			self.levelup_guild_gold = 0;
			local gid = tonumber(self.guild.gid);
			local cmd = 'glv ' .. gid;
			net_send(cmd);
		--local tip = string.format("确定要用%s购买第%d个卡槽吗？", money, sid);
		--g_scene:add_layer(ZORDER_LAYER_TIP,layer_tip:create(tip, cb));
			return;
		end
	end,

	ask_levelup_guild = function(self, tip, gold)
		self.levelup_guild_gold = gold;
		g_scene:add_layer(ZORDER_LAYER_TIP,layer_tip:create(tip, self.cb_levelup_guild));
	end,

	cb_levelup_guild = function()
		local self = layer_guild;
		if nil == self.guild_gold or nil == self.levelup_guild_gold then
			return;
		end
		if self.guild_gold < self.levelup_guild_gold then
			show_err(t_lang("TIP_NOT_ENOUGH_GOLD"));
			return;
		end
		net_send('glevelup');
	end,

	to_lguild = function()
		play_tap_1();
		g_scene:lguild();
	end,

	-- tag 1->confirm 0->cancel
	dismiss = function(tag)
		if 0 == tag then
			return;
		end
		local self = layer_guild;
		local gid = self.guild.gid;
		if nil == gid then
			return;
		end
		local cmd = 'dguild ' .. gid;
		net_send(cmd);
	end,

	leave_guild = function(tag)
		if 0 == tag then
			return;
		end
		local cmd = 'gquit';
		net_send(cmd);
	end,

	handler = function(event, x, y)
		local self = layer_guild;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			g_scene:map();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		local t = self.edit_rect;
		if nil ~= t and x > t.x1 and x < t.x2 and y > t.y1 and y < t.y2 then
			self.label_notice:setVisible(false);
			self.editbox:setVisible(true);
			local str = self.editbox:getText();
			self.editbox:sendActionsForControlEvents(cc.CONTROL_EVENTTYPE_TOUCH_UP_INSIDE);
			return;
		end
	end,

} -- layer_guild end

layer_welfare = {
	name = 'layer_welfare',
	layer = nil,
	l_fund = nil,
	l_point = nil,
	l_gold = nil,
	btn_get = nil,

	cleanup = function(self)
		self.layer = nil;
		self.label_guild = nil;
		self.label_my = nil;
		self.label_bonus = nil;
		self.btn_get = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();
		
		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_WELFARE, self.handler, true);

		local sprite, fullpath, pos, size, data;
		local tvh = suit_scale_big_frame(self.layer, GUI_WELFARE, self.back);
		add_big_frame_title(self.layer, '福利', GUI_WELFARE, ANCHOR_CENTER);

		gui_add_sprite_tip(self.layer,'title_reward',GUI_WELFARE,ANCHOR_CENTER);
		sprite = gui_add_sprite(self.layer,'bg_reward',GUI_WELFARE,ANCHOR_CENTER);
		sprite=gui_add_sprite_tip(self.layer,'t_fund',GUI_WELFARE,ANCHOR_CENTER);
		sprite=gui_add_sprite_tip(self.layer,'t_point',GUI_WELFARE,ANCHOR_CENTER);
		sprite=gui_add_sprite_tip(self.layer,'t_gold',GUI_WELFARE,ANCHOR_CENTER);
		sprite = gui_add_sprite(self.layer,'bg_btn',GUI_WELFARE,ANCHOR_CENTER);
		sprite = gui_add_sprite(self.layer,'tip',GUI_WELFARE,ANCHOR_CENTER);

		fullpath = util.get_fullpath(F_FONT, FNT_1);
		data = gui_get_data('num_fund', GUI_WELFARE, ANCHOR_CENTER);
		pos = cc.p(data.x + data.width/2, data.y);
		self.l_fund = util.add_labelbmf(self.layer, str, fullpath, pos, ANCHOR_CENTER_DOWN, data.zorder);

		data = gui_get_data('num_point', GUI_WELFARE, ANCHOR_CENTER);
		pos = cc.p(data.x + data.width/2, data.y);
		self.l_point = util.add_labelbmf(self.layer, str, fullpath, pos, ANCHOR_CENTER_DOWN, data.zorder);

		data = gui_get_data('num_gold', GUI_WELFARE, ANCHOR_CENTER);
		pos = cc.p(data.x + data.width/2, data.y);
		self.l_gold = util.add_labelbmf(self.layer, str, fullpath, pos, ANCHOR_CENTER_DOWN, data.zorder);

		data = gui_get_data('tip_area', GUI_WELFARE, ANCHOR_CENTER);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height);
		util.add_labelttf(self.layer, t_lang("TIP_WELFARE"), nil, 20, pos, util.c_black, ANCHOR_LEFT_DOWN, data.zorder, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_TOP);

		local items = {};
		local item;

		item, data = gui_add_item(items, 'btn', GUI_WELFARE, self.get_bonus, ANCHOR_CENTER);
		item:setVisible(false);
		self.btn_get = item;

		util.add_menu(self.layer, items, data.zorder);

		return self.layer, self.name;
	end,

	set_data = function(self, info)
		local guild_gold = info.guild_gold or 0;
		local gshare = (info.gshare or 0) * 100;
		local bonus_gold = info.bonus_gold or 0;
		local ltime = info.last_bonus_time or os.time();
		local t_offset = get_hour_offset(os.time(), ltime);

		self.l_fund:setString(guild_gold);
		self.l_point:setString(string.format("%d%%", gshare));
		self.l_gold:setString(bonus_gold);
		if 24 < t_offset then
			self.btn_get:setVisible(true);
		else
			self.btn_get:setVisible(false);
		end
	end,

	get_bonus = function()
		play_tap_1();
		local self = layer_welfare;
		local cmd = 'gbonus 1';
		net_send(cmd);
	end,

	back = function()
		play_tap_1();
		g_scene:guild();
	end,

	handler = function(event, x, y)
		local self = layer_welfare;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			g_scene:guild();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
} -- layer_welfare end

layer_lmember = {
	name = 'layer_lmember',
	PAGE_SIZE = 15,
	layer = nil,
	list = nil,
	editbox = nil,
	tableview = nil,
	bar = nil,
	tap = nil,
	cwidth = nil,
	cheight = nil,
	data_cell = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.editbox = nil;
		self.tableview = nil;
		self.bar = nil;
		self.tap = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.data_cell = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();
		
		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_LMEMBER, self.handler, true);

		self.list = {};
		-- btn back set in g_scene.lmember
		init_bg_for_full_view(self.layer, GUI_MEMBER, '成员');

		data = gui_get_data('cell', GUI_MEMBER, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height+10;
		local d2 = gui_get_data('table', GUI_MEMBER, ANCHOR_UP);
		data = gui_get_data('table', GUI_MEMBER, ANCHOR_DOWN);
		size = cc.size(data.width, d2.y+d2.height-data.y);
		pos = cc.p(data.x, data.y);
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		return self.layer, self.name;
	end,

	add_list = function(self, list, start_pos)
		list = list or {};
		local more_cell = { flag_more_cell = true };
		self.list = self.list or {};
		if 0 < #self.list then
			local m = self.list[#self.list];
			if true == m.flag_more_cell then
				table.remove(self.list, #self.list);
			end
		end
		for i = 1, #list do
			table.insert(self.list, list[i]);
		end
		if self.PAGE_SIZE == #list then
			table.insert(self.list, more_cell);
		end

		self:reload_data();
	end,

	reload_data = function(self)
		self.tableview:reloadData();
	end,

	get_more = function()
		local self = layer_lmember;
		local len = #(self.list or {});
		if self.list[len].flag_more_cell == true then
			len = len - 1;
		end
		if len < 0 then len = 0; end
		local cmd = string.format("glist 1 %d %d", len, self.PAGE_SIZE);
		net_send(cmd);
	end,

	back = function()
		play_tap_1();
		g_scene:guild();
	end,

	remove_member = function(self, eid)
		self.list = self.list or {};
		local index = 0;
		for i = 1, #self.list do
			local info = self.list[i];
			local id = info.eid;
			if id == eid then
				index = i;
				break;
			end
		end
		if 0 < index then
			table.remove(self.list, index);
		end
		self:reload_data();
	end,

	update_pos = function(self, eid, npos)
		local index = 0;
		local tindex = 1;
		if 1 < #self.list then
			tindex = 2;
		end
		local data = nil;
		for i = 1, #self.list do
			local info = self.list[i];
			if info.eid == eid then
				index = i;
				data = info;
				data.gpos = npos;
				break;
			end
		end
		if 0 ~= index then
			table.remove(self.list, index);
			tindex = index;
		end
		if nil ~= data then
			table.insert(self.list, tindex, data);
		end
		self:reload_data();
	end,

	action = function(...)
		play_tap_1();
		local self = layer_lmember;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		if nil == info then
			return;
		end
		g_scene:add_layer(ZORDER_LAYER_AGUILD, layer_aguild:create(info));
	end,

	detail = function(...)
		play_tap_1();
		local self = layer_lmember;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		if nil == info then
			return;
		end
		local eid = info.eid;
		local cmd = 'fsta ' .. eid;
		net_send(cmd);
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_lmember;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			--local cell = args[3];
			--local idx = cell:getIdx();
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local info = self.list[idx + 1];
			if true == info.flag_more_cell then
				local items = {};
				local pos = cc.p(width/2, height/2);
				local size = cc.size(172, 52);
				local item = add_item_1(items, '更多', nil, 20, self.get_more, ANCHOR_CENTER_CENTER, pos, size);
				item:setTag(idx + 1);

				util.add_menu(cell, items, 1);
				return cell;
			end
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local icon = info.icon;
			local alias = info.alias;
			local gpos = info.gpos;
			local last_login = info.last_login or 0;
			local level = info.level;
			local data2, sprite, path, pos, size, str;

			sprite, data2 = gui_add_sprite_on_cell(cell, data, 'icon', GUI_MEMBER, ANCHOR_DOWN);
			path = get_icon_path(icon);
			sprite = util.add_sprite(sprite, path,cc.p(0,0),ANCHOR_LEFT_DOWN,-1);
			sprite:setScale(data2.width/sprite:getContentSize().width);

			gui_add_sprite_on_cell(cell, data, 'bg_alias',GUI_MEMBER,ANCHOR_DOWN);
			gui_add_label_on_cell(cell,data,alias,28,'alias',GUI_MEMBER,ANCHOR_DOWN);

			gui_add_sprite_on_cell(cell, data, 'bg_lv', GUI_MEMBER, ANCHOR_DOWN);
			path = util.get_path('font_lv.fnt');
			str = 'LV.' .. level;
			gui_add_labelbmf_on_cell(cell,data,str,path,'lv',GUI_MEMBER,ANCHOR_DOWN);

			str = get_guild_title(gpos);
			gui_add_stroke_on_cell(cell,data,str,24,'t_pos',GUI_MEMBER,ANCHOR_DOWN);

			if info.eid == g_euser.eid then
				return cell;
			end
			local items = {};
			local item;

			local cb;
			if g_euser.gpos == GUILD_POS_MASTER then
				str = '操作';
				cb = self.action;
			else
				str = '详细';
				cb = self.detail;
			end
			item, data2 = gui_add_item_on_cell(items, data, 'btn_act', GUI_MEMBER, cb, ANCHOR_DOWN);
			gui_add_text_on_sprite(item,str,'t_act',GUI_MEMBER,ANCHOR_DOWN,30);
			item:setTag(idx + 1);

			util.add_menu(cell, items, data2.zorder);
			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_lmember;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			g_scene:guild();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
} -- layer_lmember end

layer_aguild = { 
	name = 'layer_aguild',
	layer = nil,
	info = nil,
	rect = nil,
	kick_eid = nil,

	cleanup = function(self)
		self.layer = nil;
		self.info = nil;
		self.rect = nil;
		self.kick_eid = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, info)
		self:remove();

		self.info = info;
		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_AGUILD, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 200));
		local btn_height = 70;
		local item_list = {};
		table.insert(item_list, { title = '资料', cb = self.detail });
		if g_euser.gpos == GUILD_POS_MASTER then
			table.insert(item_list, { title = '职位变更', cb = self.cpos });
			table.insert(item_list, { title = '开除', cb = self.kick });
		end
		local path = util.get_path('pop_up.png');
		local frect = cc.rect(0, 0, 64, 64); -- fullrect
		local irect = cc.rect(30, 30, 4, 4); -- insetrect
		local height = 110 + (#item_list * (btn_height + 10));
		local bgsize = cc.size(wfix(400), height);--realsize
		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		local bg = util.add_scale9sprite(self.layer, path, pos, ANCHOR_CENTER_CENTER, frect, irect, bgsize, 10); 
		self.rect = {
			x1 = pos.x-bgsize.width/2,  x2 = pos.x+bgsize.width/2,
			y1 = pos.y-bgsize.height/2, y2 = pos.y+bgsize.height/2,
		};

		path = util.get_path('popup_title.png');
		frect = cc.rect(0, 0, 64, 55); -- fullrect
		irect = cc.rect(30, 25, 4, 5); -- insetrect
		local barsize = cc.size(bgsize.width-50, 60); -- realsize
		pos = cc.p(bgsize.width/2, bgsize.height - 50);
		local bar = util.add_scale9sprite(bg, path, pos, ANCHOR_CENTER_CENTER, frect, irect, barsize, 10); 

		path = get_icon_path(info.icon);
		pos = cc.p(10, barsize.height/2);
		local icon = util.add_sprite(bar, path, pos, ANCHOR_LEFT_CENTER, 10);
		icon:setScale((barsize.height-10)/icon:getContentSize().height);

		local str = info.alias or '';
		local iwidth = icon:getContentSize().width * icon:getScaleX();
		pos = cc.p(pos.x + iwidth + 20, barsize.height/2);
		local label = util.add_labeloutline(bar, str, nil, 30, pos, util.c4b_black, util.c4b_white, 2, ANCHOR_LEFT_CENTER, 10);

		local items = {};

		local gap = btn_height + 5;
		for i = 1, #item_list do
			local l = item_list[i];
			local p = cc.p(bgsize.width/2, bgsize.height-150-gap*(i-1));
			local s = cc.size(bgsize.width - 70, btn_height);
			add_item_1(items, l.title, nil, 30, l.cb, ANCHOR_CENTER_CENTER, p, s);
		end

		pos = cc.p(bgsize.width-20, bgsize.height-20);
		add_item_close(items, pos, ANCHOR_CENTER_CENTER, self.back);

		util.add_menu(bg, items, 20);

		return self.layer, self.name;
	end,

	back = function()
		play_tap_1();
		local self = layer_aguild;
		self:remove();
	end,

	detail = function()
		play_tap_1();
		local self = layer_aguild;
		local info = self.info;
		if nil == info then
			return;
		end
		local eid = info.eid;
		local cmd = 'fsta ' .. eid;
		net_send(cmd);
		self:remove();
	end,

	cpos = function()
		play_tap_1();
		local self = layer_aguild;
		local info = self.info;
		g_scene:add_layer(ZORDER_LAYER_CPOS, layer_cpos:create(info, self.cb_change_pos));
	end,

	cb_change_pos = function(info, index)
		local self = layer_aguild;
		local eid = info.eid;
		local pos = index;
		local cmd = string.format("gpos %d %d", eid, pos);
		net_send(cmd);
		self:remove();
	end,

	kick = function()
		play_tap_1();
		local self = layer_aguild;
		local info = self.info;
		if nil == info then
			return;
		end
		self.kick_eid = info.eid;
		local s = '是否要开除' .. info.alias .. '?';
		g_scene:add_layer(ZORDER_LAYER_TIP,layer_tip:create(s,self.cb_kick));
	end,

	-- tag 1->confirm 0->cancel
	cb_kick = function(tag)
		if 1 ~= tag then return; end
		local self = layer_aguild;
		local cmd = 'gquit ' .. self.kick_eid;
		net_send(cmd);
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_aguild;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		local r = self.rect;
		if nil == r then
			return;
		end
		if x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2 then
			self.back();
		end
	end,
} -- layer_aguild end

layer_cpos = { 
	name = 'layer_cpos',
	layer = nil,
	info = nil,
	cb = nil,
	t_member = nil,
	t_senior = nil,

	cleanup = function(self)
		self.layer = nil;
		self.info = nil;
		self.cb = nil;
		self.t_member = nil;
		self.t_senior = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, info, cb)
		self:remove();

		self.info = info;
		self.cb = cb;
		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_CPOS, self.handler, true);

		--util.add_layer_color(self.layer, ccc4(0, 0, 0, 200));
		--[[
		local sprite, fullpath, pos, data, size, str;
		data = gui_get_data('c_bg', GUI_MEMBER, ANCHOR_CENTER);
		pos = cc.p(data.x, data.y);
		fullpath = util.get_fullpath(F_IMAGE, data.fname1);
		local fullrect = cc.rect(0, 0, 173, 231);
		local insetrect = cc.rect(80, 120, 13, 10);
		size = cc.size(data.width, data.height);
		sprite = util.add_scale9sprite(self.layer, fullpath, pos, ANCHOR_LEFT_DOWN, fullrect, insetrect, size, data.zorder); 
		self.rect = {
			x1 = data.x, x2 = data.x + data.width,
			y1 = data.y, y2 = data.y + data.height,
		};
		sprite=gui_add_sprite_tip(self.layer,'c_title',GUI_MEMBER,ANCHOR_CENTER);

		local items = {};
		local item;

		item, data = gui_add_item(items, 'c_return', GUI_MEMBER, self.back, ANCHOR_CENTER);

		gui_add_sprite(self.layer,'c_bg_btn',GUI_MEMBER,ANCHOR_CENTER);
		item, data = gui_add_item(items, 'c_btn', GUI_MEMBER, self.confirm, ANCHOR_CENTER);

		gui_add_sprite(self.layer,'c_bg_member',GUI_MEMBER,ANCHOR_CENTER);
		gui_add_sprite_tip(self.layer,'c_tip_member',GUI_MEMBER,ANCHOR_CENTER);
		item, data = gui_add_item(items, 'c_toggle_member', GUI_MEMBER, self.change_pos, ANCHOR_CENTER);
		item:setTag(GUILD_POS_MEMBER);
		self.t_member = item;
		if info.gpos == GUILD_POS_MEMBER then
			item:setSelectedIndex(1);
		end

		gui_add_sprite(self.layer,'c_bg_senior',GUI_MEMBER,ANCHOR_CENTER);
		gui_add_sprite_tip(self.layer,'c_tip_senior',GUI_MEMBER,ANCHOR_CENTER);
		item, data = gui_add_item(items, 'c_toggle_senior', GUI_MEMBER, self.change_pos, ANCHOR_CENTER);
		item:setTag(GUILD_POS_SENIOR);
		self.t_senior = item;
		if info.gpos == GUILD_POS_SENIOR then
			item:setSelectedIndex(1);
		end

		util.add_menu(self.layer, items, data.zorder);
		]]--

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 200));
		local btn_height = 70;
		local item_list = {};
		table.insert(item_list, { pos = GUILD_POS_MEMBER, title = '成员', cb = self.do_change });
		table.insert(item_list, { pos = GUILD_POS_SENIOR, title = '副会长', cb = self.do_change });
		for i = 1, #item_list do
			if info.gpos == item_list[i].pos then
				table.remove(item_list, i);
				break;
			end
		end
		local path = util.get_path('pop_up.png');
		local frect = cc.rect(0, 0, 64, 64); -- fullrect
		local irect = cc.rect(30, 30, 4, 4); -- insetrect
		local height = 110 + (#item_list * (btn_height + 10));
		local bgsize = cc.size(wfix(400), height);--realsize
		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		local bg = util.add_scale9sprite(self.layer, path, pos, ANCHOR_CENTER_CENTER, frect, irect, bgsize, 10); 
		self.rect = {
			x1 = pos.x-bgsize.width/2,  x2 = pos.x+bgsize.width/2,
			y1 = pos.y-bgsize.height/2, y2 = pos.y+bgsize.height/2,
		};

		path = util.get_path('popup_title.png');
		frect = cc.rect(0, 0, 64, 55); -- fullrect
		irect = cc.rect(30, 25, 4, 5); -- insetrect
		local barsize = cc.size(bgsize.width-50, 60); -- realsize
		pos = cc.p(bgsize.width/2, bgsize.height - 50);
		local bar = util.add_scale9sprite(bg, path, pos, ANCHOR_CENTER_CENTER, frect, irect, barsize, 10); 

		path = get_icon_path(info.icon);
		pos = cc.p(10, barsize.height/2);
		local icon = util.add_sprite(bar, path, pos, ANCHOR_LEFT_CENTER, 10);
		icon:setScale((barsize.height-10)/icon:getContentSize().height);

		local str = info.alias or '';
		local iwidth = icon:getContentSize().width * icon:getScaleX();
		pos = cc.p(pos.x + iwidth + 20, barsize.height/2);
		local label = util.add_labeloutline(bar, str, nil, 30, pos, util.c4b_black, util.c4b_white, 2, ANCHOR_LEFT_CENTER, 10);

		local items = {};

		local gap = btn_height + 5;
		for i = 1, #item_list do
			local l = item_list[i];
			local p = cc.p(bgsize.width/2, bgsize.height-150-gap*(i-1));
			local s = cc.size(bgsize.width - 70, btn_height);
			local item = add_item_1(items, l.title, nil, 30, l.cb, ANCHOR_CENTER_CENTER, p, s);
			item:setTag(l.pos);
		end

		pos = cc.p(bgsize.width-20, bgsize.height-20);
		add_item_close(items, pos, ANCHOR_CENTER_CENTER, self.back);

		util.add_menu(bg, items, 20);

		return self.layer, self.name;
	end,

	back = function()
		play_tap_1();
		local self = layer_cpos;
		self:remove();
	end,

	change_pos = function(...)
		play_tap_3();
		local self = layer_cpos;
		local args = {...};
		local item = args[2];
		-- toggle:getSelectedIndex()  0 : off     1 : on
		local t1, t2;
		if item == self.t_member then
			t1 = self.t_member;
			t2 = self.t_senior;
		else
			t1 = self.t_senior;
			t2 = self.t_member;
		end
		local index = t1:getSelectedIndex();
		if 1 == index then
			t2:setSelectedIndex(0);
		else
			t1:setSelectedIndex(1);
			t2:setSelectedIndex(0);
		end
	end,

	confirm = function()
		play_tap_1();
		local self = layer_cpos;
		local item = nil;
		local list = { self.t_member, self.t_senior };
		for i = 1, #list do
			local t = list[i];
			local index = t:getSelectedIndex();
			if 1 == index then
				item = t;
				break;
			end
		end
		if nil == item then
			return;
		end
		local opos = self.info.gpos;
		local pos = item:getTag();
		local info = self.info;
		local cb = self.cb;
		self.back();
		if opos == pos or nil == cb then
			return;
		end
		cb(info, pos);
	end,

	do_change = function(...)
		play_tap_1();
		local self = layer_cpos;
		local args = {...};
		local pos = args[2]:getTag();
		local opos = self.info.gpos;
		local info = self.info;
		local cb = self.cb;
		self.back();
		if opos == pos or nil == cb then
			return;
		end
		cb(info, pos);
	end,

	handler = function(event, x, y)
		local self = layer_cpos;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		local r = self.rect;
		if nil == r then
			return;
		end
		if x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2 then
			self.back();
		end
	end,
} -- layer_cpos end

layer_lapply = {
	name = 'layer_lapply',
	PAGE_SIZE = 15,
	layer = nil,
	list = nil,
	editbox = nil,
	tableview = nil,
	bar = nil,
	tap = nil,
	cwidth = nil,
	cheight = nil,
	data_cell = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.editbox = nil;
		self.tableview = nil;
		self.bar = nil;
		self.tap = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.data_cell = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();
		
		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_LAPPLY, self.handler, true);

		self.list = {};
		-- btn back set in g_scene.lapply
		init_bg_for_full_view(self.layer, GUI_APPROVE, '审批');

		data = gui_get_data('cell', GUI_APPROVE, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height+10;
		local d2 = gui_get_data('table', GUI_APPROVE, ANCHOR_UP);
		data = gui_get_data('table', GUI_APPROVE, ANCHOR_DOWN);
		size = cc.size(data.width, d2.y+d2.height-data.y);
		pos = cc.p(data.x, data.y);
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		return self.layer, self.name;
	end,

	add_list = function(self, list, start_pos)
		list = list or {};
		local more_cell = { flag_more_cell = true };
		self.list = self.list or {};
		if 0 < #self.list then
			local m = self.list[#self.list];
			if true == m.flag_more_cell then
				table.remove(self.list, #self.list);
			end
		end
		for i = 1, #list do
			table.insert(self.list, list[i]);
		end
		if self.PAGE_SIZE == #list then
			table.insert(self.list, more_cell);
		end

		self:reload_data();
	end,

	reload_data = function(self)
		self.tableview:reloadData();
	end,

	get_more = function()
		local self = layer_lapply;
		local len = #(self.list or {});
		if self.list[len].flag_more_cell == true then
			len = len - 1;
		end
		if len < 0 then len = 0; end
		local cmd = string.format("glist 9 %d %d", len, self.PAGE_SIZE);
		net_send(cmd);
	end,

	back = function()
		play_tap_1();
		g_scene:guild();
	end,

	search = function()
	end,
	
	editbox_handler = function(eventname, psender)
		local self = layer_lapply;
		local edit = tolua.cast(psender, "cc.EditBox");
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
		elseif eventname == "changed" then
		end
	end,

	action = function(...)
		play_tap_1();
		local self = layer_lapply;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		if nil == info then
			return;
		end
		g_scene:add_layer(ZORDER_LAYER_APPROVE, layer_approve:create(info));
	end,

	remove_apply = function(self, eid)
		self.list = self.list or {};
		local index = 0;
		for i = 1, #self.list do
			local info = self.list[i];
			local id = info.eid;
			if id == eid then
				index = i;
				break;
			end
		end
		if 0 < index then
			table.remove(self.list, index);
		end
		self:reload_data();
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_lapply;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			--local cell = args[3];
			--local idx = cell:getIdx();
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local info = self.list[idx + 1];
			if true == info.flag_more_cell then
				local items = {};
				local pos = cc.p(width/2, height/2);
				local size = cc.size(172, 52);
				local item = add_item_1(items, '更多', nil, 20, self.get_more, ANCHOR_CENTER_CENTER, pos, size);
				item:setTag(idx + 1);

				util.add_menu(cell, items, 1);
				return cell;
			end
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local icon = info.icon;
			local alias = info.alias;
			local gpos = info.gpos;
			local last_login = info.last_login or 0;
			local level = info.level;
			local data2, sprite, path, pos, size, str;

			sprite, data2 = gui_add_sprite_on_cell(cell, data, 'icon', GUI_APPROVE, ANCHOR_DOWN);
			path = get_icon_path(icon);
			sprite = util.add_sprite(sprite, path,cc.p(0,0),ANCHOR_LEFT_DOWN,-1);
			sprite:setScale(data2.width/sprite:getContentSize().width);

			gui_add_sprite_on_cell(cell, data, 'bg_alias', GUI_APPROVE, ANCHOR_DOWN);
			gui_add_label_on_cell(cell,data,alias,28,'c_alias',GUI_APPROVE,ANCHOR_DOWN);

			gui_add_sprite_on_cell(cell, data, 'bg_lv', GUI_APPROVE, ANCHOR_DOWN);

			path = util.get_path('font_lv.fnt');
			str = 'LV.' .. level;
			gui_add_labelbmf_on_cell(cell,data,str,path,'lv',GUI_APPROVE,ANCHOR_DOWN);

			if info.eid == g_euser.eid then
				return cell;
			end
			local items = {};
			local item;

			item, data2 = gui_add_item_on_cell(items, data, 'btn_act', GUI_APPROVE, self.action, ANCHOR_DOWN);
			gui_add_text_on_sprite(item,'操作','t_act',GUI_APPROVE,ANCHOR_DOWN,30);
			item:setTag(idx + 1);

			util.add_menu(cell, items, data2.zorder);
			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_lapply;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			g_scene:guild();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
} -- layer_lapply end

layer_approve = { 
	name = 'layer_approve',
	layer = nil,
	info = nil,

	cleanup = function(self)
		self.layer = nil;
		self.info = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, info)
		self:remove();

		self.info = info;
		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_APPROVE, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 200));
		local btn_height = 70;
		local item_list = {};
		if g_euser.eid ~= info.eid then
			table.insert(item_list, { title = '资料', cb = self.detail });
		end
		if (g_euser.gpos == GUILD_POS_MASTER or g_euser.gpos == GUILD_POS_SENIOR) and info.gpos == GUILD_POS_APPLY then
			table.insert(item_list, { title = '同意', cb = self.agree });
			table.insert(item_list, { title = '拒绝', cb = self.reject });
		end
		local path = util.get_path('pop_up.png');
		local frect = cc.rect(0, 0, 64, 64); -- fullrect
		local irect = cc.rect(30, 30, 4, 4); -- insetrect
		local height = 110 + (#item_list * (btn_height + 10));
		local bgsize = cc.size(wfix(400), height);--realsize
		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		local bg = util.add_scale9sprite(self.layer, path, pos, ANCHOR_CENTER_CENTER, frect, irect, bgsize, 10); 
		self.rect = {
			x1 = pos.x-bgsize.width/2,  x2 = pos.x+bgsize.width/2,
			y1 = pos.y-bgsize.height/2, y2 = pos.y+bgsize.height/2,
		};

		path = util.get_path('popup_title.png');
		frect = cc.rect(0, 0, 64, 55); -- fullrect
		irect = cc.rect(30, 25, 4, 5); -- insetrect
		local barsize = cc.size(bgsize.width-50, 60); -- realsize
		pos = cc.p(bgsize.width/2, bgsize.height - 50);
		local bar = util.add_scale9sprite(bg, path, pos, ANCHOR_CENTER_CENTER, frect, irect, barsize, 10); 

		path = get_icon_path(info.icon);
		pos = cc.p(10, barsize.height/2);
		local icon = util.add_sprite(bar, path, pos, ANCHOR_LEFT_CENTER, 10);
		icon:setScale((barsize.height-10)/icon:getContentSize().height);

		local str = info.alias or '';
		local iwidth = icon:getContentSize().width * icon:getScaleX();
		pos = cc.p(pos.x + iwidth + 20, barsize.height/2);
		local label = util.add_labeloutline(bar, str, nil, 30, pos, util.c4b_black, util.c4b_white, 2, ANCHOR_LEFT_CENTER, 10);

		local items = {};

		local gap = btn_height + 5;
		for i = 1, #item_list do
			local l = item_list[i];
			local p = cc.p(bgsize.width/2, bgsize.height-150-gap*(i-1));
			local s = cc.size(bgsize.width - 70, btn_height);
			add_item_1(items, l.title, nil, 30, l.cb, ANCHOR_CENTER_CENTER, p, s);
		end

		pos = cc.p(bgsize.width-20, bgsize.height-20);
		add_item_close(items, pos, ANCHOR_CENTER_CENTER, self.back);

		util.add_menu(bg, items, 20);

		return self.layer, self.name;
	end,

	back = function()
		play_tap_1();
		local self = layer_approve;
		self:remove();
	end,

	detail = function()
		play_tap_1();
		local self = layer_approve;
		local info = self.info;
		if nil == info then
			return;
		end
		local eid = info.eid;
		local cmd = 'fsta ' .. eid;
		net_send(cmd);
		self:remove();
	end,

	agree = function()
		play_tap_1();
		local self = layer_approve;
		local info = self.info;
		if nil == info then
			return;
		end
		local eid = info.eid;
		self.back();
		local cmd = 'gpos ' .. eid .. ' ' .. GUILD_POS_MEMBER;
		net_send(cmd);
	end,

	reject = function()
		play_tap_1();
		local self = layer_approve;
		local info = self.info;
		if nil == info then
			return;
		end
		local eid = info.eid;
		self.back();
		local cmd = 'gquit ' .. eid;
		net_send(cmd);
	end,

	handler = function(event, x, y)
		local self = layer_approve;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		local r = self.rect;
		if nil == r then
			return;
		end
		if x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2 then
			self.back();
		end
	end,
} -- layer_approve end

layer_lstock = {
	name = 'layer_lstock',
	PAGE_SIZE = 15,
	layer = nil,
	list = nil,
	editbox = nil,
	tableview = nil,
	bar = nil,
	tap = nil,
	cwidth = nil,
	cheight = nil,
	data_cell = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.editbox = nil;
		self.tableview = nil;
		self.bar = nil;
		self.tap = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.data_cell = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();
		
		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_LSTOCK, self.handler, true);

		self.list = {};
		-- btn back set in g_scene.lmember
		init_bg_for_full_view(self.layer, GUI_STOCK, '股份');

		data = gui_get_data('cell', GUI_STOCK, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height+10;
		local d2 = gui_get_data('table', GUI_STOCK, ANCHOR_UP);
		data = gui_get_data('table', GUI_STOCK, ANCHOR_DOWN);
		size = cc.size(data.width, d2.y+d2.height-data.y);
		pos = cc.p(data.x, data.y);
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		return self.layer, self.name;
	end,

	add_list = function(self, list, start_pos)
		list = list or {};
		local more_cell = { flag_more_cell = true };
		self.list = self.list or {};
		if 0 < #self.list then
			local m = self.list[#self.list];
			if true == m.flag_more_cell then
				table.remove(self.list, #self.list);
			end
		end
		for i = 1, #list do
			table.insert(self.list, list[i]);
		end
		if self.PAGE_SIZE == #list then
			table.insert(self.list, more_cell);
		end

		self:reload_data();
	end,

	reload_data = function(self)
		self.tableview:reloadData();
	end,

	get_more = function()
		local self = layer_lstock;
		local len = #(self.list or {});
		if self.list[len].flag_more_cell == true then
			len = len - 1;
		end
		if len < 0 then len = 0; end
		local cmd = string.format("glist 1 %d %d", len, self.PAGE_SIZE);
		net_send(cmd);
	end,

	back = function()
		play_tap_1();
		g_scene:guild();
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_lstock;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			--local cell = args[3];
			--local idx = cell:getIdx();
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local info = self.list[idx + 1];
			if true == info.flag_more_cell then
				local items = {};
				local pos = cc.p(width/2, height/2);
				local size = cc.size(172, 52);
				local item = add_item_1(items, '更多', nil, 20, self.get_more, ANCHOR_CENTER_CENTER, pos, size);
				item:setTag(idx + 1);

				util.add_menu(cell, items, 1);
				return cell;
			end
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local icon = info.icon;
			local alias = info.alias;
			local gshare = info.gshare or 0;
			local level = info.level;
			--gshare = string.format("%.2f%%", gshare*100);
			gshare = string.format("%.0f%%", gshare*100);
			local gpos = info.gpos;
			local last_login = info.last_login or 0;
			local level = info.level;
			local data2, sprite, path, pos, size, str;
			sprite, data2 = gui_add_sprite_on_cell(cell, data, 'icon', GUI_STOCK, ANCHOR_DOWN);
			path = get_icon_path(icon);
			sprite = util.add_sprite(sprite, path,cc.p(0,0),ANCHOR_LEFT_DOWN,-1);
			sprite:setScale(data2.width/sprite:getContentSize().width);

			gui_add_sprite_on_cell(cell, data, 'bg_alias', GUI_STOCK,ANCHOR_DOWN);
			gui_add_label_on_cell(cell,data,alias,28,'alias',GUI_STOCK,ANCHOR_DOWN);

			gui_add_sprite_on_cell(cell, data, 'bg_lv', GUI_STOCK, ANCHOR_DOWN);
			path = util.get_path('font_lv.fnt');
			str = 'LV.' .. level;
			gui_add_labelbmf_on_cell(cell,data,str,path,'lv',GUI_STOCK,ANCHOR_DOWN);

			str = get_guild_title(gpos);
			gui_add_stroke_on_cell(cell,data,str,24,'t_pos',GUI_MEMBER,ANCHOR_DOWN);

			gui_add_sprite_on_cell(cell, data, 'icon_stock', GUI_STOCK,ANCHOR_DOWN);
			path = util.get_path(FNT_1);
			str = gshare;
			gui_add_labelbmf_on_cell(cell,data,str,path,'num_stock',GUI_STOCK,ANCHOR_DOWN);

			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_lstock;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			g_scene:guild();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
} -- layer_lstock end

layer_invest = {
	name = 'layer_invest',
	layer = nil,
	info = nil,
	l_fund = nil,
	l_my = nil,
	l_stock = nil,

	cleanup = function(self)
		self.layer = nil;
		self.info = nil;
		self.l_fund = nil;
		self.l_my = nil;
		self.l_stock = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();
		
		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_INVEST, self.handler, true);

		-- btn back set in g_scene.lmember
		init_bg_for_full_view(self.layer, GUI_INVEST, '投资');
		gui_add_sprite(self.layer,'bg_invest',GUI_INVEST,ANCHOR_UP);
		gui_add_sprite(self.layer,'bg_title_invest',GUI_INVEST,ANCHOR_UP);
		gui_add_sprite(self.layer,'bg_fund',GUI_INVEST,ANCHOR_UP);
		gui_add_sprite(self.layer,'bg_myinvest',GUI_INVEST,ANCHOR_UP);
		gui_add_sprite(self.layer,'bg_mystock',GUI_INVEST,ANCHOR_UP);
		gui_add_sprite(self.layer,'gold_fund',GUI_INVEST,ANCHOR_UP);
		gui_add_sprite(self.layer,'gold_myinvest',GUI_INVEST,ANCHOR_UP);
		gui_add_sprite(self.layer,'icon_mystock',GUI_INVEST,ANCHOR_UP);
		gui_add_label(self.layer, '公会投资', 20, 't_invest', GUI_INVEST, ANCHOR_UP);
		gui_add_label(self.layer, t_lang("GUILD_FUND"), 20, 't_fund', GUI_INVEST, ANCHOR_UP);
		gui_add_label(self.layer, t_lang("MY_INVEST"), 20, 't_myinvest', GUI_INVEST, ANCHOR_UP);
		gui_add_label(self.layer, t_lang("MY_STOCK"), 20, 't_mystock', GUI_INVEST, ANCHOR_UP);

		local path, data;
		path = util.get_path(FNT_1);
		self.l_fund = gui_add_labelbmf(self.layer, '', path, 'num_fund', GUI_INVEST, ANCHOR_UP);
		self.l_my = gui_add_labelbmf(self.layer, '', path, 'num_myinvest', GUI_INVEST, ANCHOR_UP);
		self.l_stock = gui_add_labelbmf(self.layer, '', path, 'num_mystock', GUI_INVEST, ANCHOR_UP);

		local items = {};
		local item;

		item, data = gui_add_item(items, 'btn_investment', GUI_INVEST, self.go_invest, ANCHOR_UP);
		gui_add_text_on_sprite(item, "金币投资", 't_investment', GUI_INVEST, ANCHOR_UP, 30);

		item, data = gui_add_item(items, 'btn_record', GUI_INVEST, self.go_record, ANCHOR_UP);
		gui_add_text_on_sprite(item, "投资记录", 't_record', GUI_INVEST, ANCHOR_UP, 30);

		util.add_menu(self.layer, items, data.zorder);

		return self.layer, self.name;
	end,

	set_data = function(self, info)
		self.info = info;
		local guild_gold = info.guild_gold or 0;
		--local guild_crystal = info.guild_crystal or 0;
		local my_gold = info.my_gold or 0;
		local gshare = (info.gshare or 0) * 100;
		self.l_fund:setString(guild_gold);
		self.l_my:setString(my_gold);
		self.l_stock:setString(string.format("%d%%", gshare));
	end,

	go_invest = function()
		play_tap_1();
		local self = layer_invest;
		local m = self.info.guild_gold or 0;
		local s = (self.info.gshare or 0) * 100;
		s = string.format("%d%%", s);
		g_scene:add_layer(ZORDER_LAYER_AINVEST, layer_ainvest:create(1, m, s));
	end,

	go_record = function()
		play_tap_1();
		g_scene:ldeposit();
	end,

	back = function()
		play_tap_1();
		g_scene:guild();
	end,

	handler = function(event, x, y)
		local self = layer_invest;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			g_scene:guild();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
} -- layer_invest end

layer_ainvest = {
	name = 'layer_ainvest',
	layer = nil,
	rect = nil,
	editbox = nil,

	cleanup = function(self)
		self.layer = nil;
		self.rect = nil;
		self.editbox = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, mtype, gfund, gshare)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_AINVEST, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 200));
		local bgsize = cc.size(wfix(560), hfix(550));
		local bg,rect=init_bg_for_popview(self.layer,'金币投资',bgsize,self.back);
		self.rect = rect;

		local pos, size, str;
		pos = cc.p(bgsize.width/2, bgsize.height-hfix(100));
		add_line_2(bg, pos, ANCHOR_CENTER_CENTER, 20, bgsize.width-wfix(50));

		pos = cc.p(wfix(50), bgsize.height-hfix(170));
		size = cc.size(wfix(200), hfix(70));
		str = '公会资金:';
		util.add_labeloutline(bg, str, nil, 30, pos, util.c4b_white, util.c4b_black, 2, ANCHOR_LEFT_DOWN, 20, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		pos = cc.p(wfix(250), bgsize.height-hfix(170));
		add_icon_gold(bg, pos, ANCHOR_LEFT_DOWN, 20, wfix(1));
		pos = cc.p(wfix(300), bgsize.height-hfix(170));
		str = gfund or 0;
		add_font_1(bg, str, pos, ANCHOR_LEFT_DOWN, 20, wfix(1));

		pos = cc.p(bgsize.width/2, bgsize.height-hfix(180));
		add_line_2(bg, pos, ANCHOR_CENTER_CENTER, 20, bgsize.width-wfix(50));

		pos = cc.p(wfix(50), bgsize.height-hfix(250));
		size = cc.size(wfix(200), hfix(70));
		str = '我的股份:';
		util.add_labeloutline(bg, str, nil, 30, pos, util.c4b_white, util.c4b_black, 2, ANCHOR_LEFT_DOWN, 20, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		pos = cc.p(wfix(250), bgsize.height-hfix(250));
		str = gshare or '0%';
		add_font_1(bg, str, pos, ANCHOR_LEFT_DOWN, 20, wfix(1));

		pos = cc.p(bgsize.width/2, bgsize.height-hfix(260));
		add_line_2(bg, pos, ANCHOR_CENTER_CENTER, 20, bgsize.width-wfix(50));

		pos = cc.p(wfix(50), bgsize.height-hfix(370));
		size = cc.size(wfix(200), hfix(70));
		str = '本次投资:';
		util.add_labeloutline(bg, str, nil, 30, pos, util.c4b_white, util.c4b_black, 2, ANCHOR_LEFT_DOWN, 20, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		pos = cc.p(wfix(250), bgsize.height-hfix(370));
		add_icon_gold(bg, pos, ANCHOR_LEFT_DOWN, 20, wfix(1));
		pos = cc.p(wfix(300), bgsize.height-hfix(370));
		size = cc.size(wfix(230), hfix(70));
		str = '请输入投资金额';
		self.editbox = add_editbox_1(bg, pos, size, str, 20,self.editbox_handler);

		pos = cc.p(bgsize.width/2, bgsize.height-hfix(390));
		add_line_2(bg, pos, ANCHOR_CENTER_CENTER, 20, bgsize.width-wfix(50));

		local items = {};

		add_item_1(items, '确定', nil, 30, self.do_invest, ANCHOR_CENTER_DOWN, cc.p(bgsize.width/2, hfix(30)));
		
		util.add_menu(bg, items, 50);

		return self.layer, self.name;
	end,

	editbox_handler = function(eventname, psender)
		local self = layer_ainvest;
		local edit = tolua.cast(psender, "cc.EditBox");
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
		elseif eventname == "changed" then
		end

	end,

	do_invest = function()
		play_tap_1();
		local self = layer_ainvest;
		local str = self.editbox:getText();
		--local mtype = self.mtype;
		local num = tonumber(self.editbox:getText());
		if nil == num then
			show_msg('请输入有效数字');
			return;
		end
		if 1 > num then
			show_msg('请输入数量');
			return;
		end
		local cmd = 'gdeposit ' .. num;
		net_send(cmd);
	end,

	back = function()
		play_tap_1();
		local self = layer_ainvest;
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_ainvest;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		local r = self.rect;
		if nil == r then
			return;
		end
		if x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2 then
			self.back();
		end
	end,

} -- layer_ainvest end

layer_ldeposit = {
	name = 'layer_ldeposit',
	PAGE_SIZE = 15,
	layer = nil,
	list = nil,
	editbox = nil,
	tableview = nil,
	bar = nil,
	tap = nil,
	cwidth = nil,
	cheight = nil,
	data_cell = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.editbox = nil;
		self.tableview = nil;
		self.bar = nil;
		self.tap = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.data_cell = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();
		
		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_LDEPOSIT, self.handler, true);

		self.list = {};
		-- btn back set in g_scene.lguild
		init_bg_for_full_view(self.layer, GUI_RECORD, '投资记录');

		local d1 = gui_get_data('table', GUI_RECORD, ANCHOR_UP);
		local d2 = gui_get_data('table', GUI_RECORD, ANCHOR_DOWN);
		local offsety = d1.y - d2.y;
		data = gui_get_data('cell', GUI_RECORD, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height+10;
		data = gui_get_data('table', GUI_RECORD, ANCHOR_DOWN);
		size = cc.size(data.width, data.height+offsety);
		pos = cc.p(data.x, data.y);
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, ccp(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+10);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		return self.layer, self.name;
	end,

	add_list = function(self, list, start_pos)
		list = list or {};
		local more_cell = { flag_more_cell = true };
		self.list = self.list or {};
		if 0 < #self.list then
			local m = self.list[#self.list];
			if true == m.flag_more_cell then
				table.remove(self.list, #self.list);
			end
		end
		for i = 1, #list do
			table.insert(self.list, list[i]);
		end
		if self.PAGE_SIZE == #list then
			table.insert(self.list, more_cell);
		end

		self:reload_data();
	end,

	reload_data = function(self)
		self.tableview:reloadData();
	end,

	get_more = function()
		local self = layer_ldeposit;
		local len = #(self.list or {});
		if self.list[len].flag_more_cell == true then
			len = len - 1;
		end
		if len < 0 then len = 0; end
		local cmd = string.format("ldeposit %d %d", len, self.PAGE_SIZE);
		net_send(cmd);
	end,

	back = function()
		play_tap_1();
		g_scene:invest();
	end,

	search = function()
	end,
	
	editbox_handler = function(eventname, psender)
		local self = layer_ldeposit;
		local edit = tolua.cast(psender, "cc.EditBox");
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
		elseif eventname == "changed" then
		end
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_ldeposit;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			--local cell = args[3];
			--local idx = cell:getIdx();
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local info = self.list[idx + 1];
			if true == info.flag_more_cell then
				local items = {};
				local pos = cc.p(width/2, height/2);
				local size = cc.size(172, 52);
				local item = add_item_1(items, '更多', nil, 20, self.get_more, ANCHOR_CENTER_CENTER, pos, size);
				item:setTag(idx + 1);

				util.add_menu(cell, items, 1);
				return cell;
			end
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local alias = info.alias;
			local deposit_date = info.deposit_date;
			local gold = info.gold;
			local crystal = info.crystal;
			local sprite, path, pos, size, str;

			str = alias;
			gui_add_label_on_cell(cell,data,str,25,'name',GUI_RECORD,ANCHOR_DOWN);

			path = util.get_path(FNT_1);
			local t = os.date("*t", deposit_date);
			str = string.format("%d/%d", t.month, t.day);
			gui_add_labelbmf_on_cell(cell,data,str,path,'date',GUI_RECORD,ANCHOR_DOWN);

			gui_add_sprite_on_cell(cell, data, 'gold', GUI_RECORD, ANCHOR_DOWN);
			str = gold;
			gui_add_labelbmf_on_cell(cell,data,str,path,'num',GUI_RECORD,ANCHOR_DOWN);
			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_ldeposit;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			g_scene:guild();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
} -- layer_ldeposit end

layer_chatpop = { 
	name = 'layer_chatpop',
	layer = nil,
	info = nil,
	rect = nil,

	cleanup = function(self)
		self.layer = nil;
		self.info = nil;
		self.rect = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, info)
		self:remove();

		self.info = info;
		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_CHATPOP, self.handler, true);

		util.add_layer_color(self.layer, cc.c4b(0, 0, 0, 200));

		local btn_height = 70;
		local item_list = {};
		if g_euser.eid ~= info.eid then
			table.insert(item_list, { title = '加好友', cb = self.addfrd });

			if not g_scene:is_battle() and not g_scene:is_stage(STAGE_REPLAY) then
				table.insert(item_list, { title = '资料', cb = self.detail });

				if g_scene:is_stage(STAGE_MAP) then
					table.insert(item_list, { title = '挑战', cb = self.fight });
				end
			end

			if nil ~= layer_chat.layer then
				table.insert(item_list, { title = '私聊', cb=self.private_chat });
			end
		end

		local path = util.get_path('pop_up.png');
		local frect = cc.rect(0, 0, 64, 64); -- fullrect
		local irect = cc.rect(30, 30, 4, 4); -- insetrect
		local height = 110 + (#item_list * (btn_height + 10));
		local bgsize = cc.size(wfix(400), height);--realsize
		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		local bg = util.add_scale9sprite(self.layer, path, pos, ANCHOR_CENTER_CENTER, frect, irect, bgsize, 10); 
		self.rect = {
			x1 = pos.x-bgsize.width/2,  x2 = pos.x+bgsize.width/2,
			y1 = pos.y-bgsize.height/2, y2 = pos.y+bgsize.height/2,
		};

		path = util.get_path('popup_title.png');
		frect = cc.rect(0, 0, 64, 55); -- fullrect
		irect = cc.rect(30, 25, 4, 5); -- insetrect
		local barsize = cc.size(bgsize.width-50, 60); -- realsize
		pos = cc.p(bgsize.width/2, bgsize.height - 50);
		local bar = util.add_scale9sprite(bg, path, pos, ANCHOR_CENTER_CENTER, frect, irect, barsize, 10); 

		path = get_icon_path(info.icon);
		pos = cc.p(10, barsize.height/2);
		local icon = util.add_sprite(bar, path, pos, ANCHOR_LEFT_CENTER, 10);
		icon:setScale((barsize.height-10)/icon:getContentSize().height);

		local str = info.alias or '';
		local iwidth = icon:getContentSize().width * icon:getScaleX();
		pos = cc.p(pos.x + iwidth + 20, barsize.height/2);
		local label = util.add_labelttf(bar, str, nil, 30, pos, cc.c4b(68, 37, 16, 255), ANCHOR_LEFT_CENTER, 10);

		local items = {};

		local gap = btn_height + 5;
		for i = 1, #item_list do
			local l = item_list[i];
			local p = cc.p(bgsize.width/2, bgsize.height-150-gap*(i-1));
			local s = cc.size(bgsize.width - 70, btn_height);
			add_item_1(items, l.title, nil, 30, l.cb, ANCHOR_CENTER_CENTER, p, s);
		end

		pos = cc.p(bgsize.width-20, bgsize.height-20);
		add_item_close(items, pos, ANCHOR_CENTER_CENTER, self.back);

		util.add_menu(bg, items, 20);

		return self.layer, self.name;
	end,

	back = function()
		local self = layer_chatpop;
		self:remove();
	end,

	detail = function()
		local self = layer_chatpop;
		local info = self.info;
		if nil == info then
			return;
		end
		local eid = info.eid;
		local cmd = 'fsta ' .. eid;
		net_send(cmd);
		self:remove();
	end,

	addfrd = function()
		local self = layer_chatpop;
		local info = self.info;
		if nil == info then
			return;
		end
		local eid = info.eid;
		local cmd = string.format("fadd %d", eid);
		net_send(cmd);
	end,

	fight = function()
		local self = layer_chatpop;
		local info = self.info;
		if nil == info then
			return;
		end
		local eid = info.eid;
		pop_invite_fight(eid);
	end,

	private_chat = function()
		local self = layer_chatpop;
		local info = self.info;
		if nil == info then
			return;
		end
		local eid = info.eid;
		local alias = info.alias;
		if nil == layer_chat.layer then
			if g_scene:is_stage(STAGE_PVP) then
				g_scene:add_layer(ZORDER_LAYER_CHAT, layer_chat:create(true));
			else
				return;
			end
		end
		self.back();
		layer_chat.chat_target = { eid = eid, alias = alias };
		layer_chat:handle_channel_btn(C_PRIVATE);
	end,

	handler = function(event, x, y)
		local self = layer_chatpop;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		local r = self.rect;
		if nil == r then
			return;
		end
		if x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2 then
			self.back();
		end
	end,
} -- layer_chatpop end

layer_fight = {
	name = 'layer_fight',
	layer = nil,
	data = nil,
	TIP_TYPE_INVITE_FIGHT = 1,
	TIP_TYPE_ANSWER_FIGHT = 2,

	cleanup = function(self)
		self.layer = nil;
		self.callback = nil;
		self.data = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, msg, tip_type, data)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_FIGHT, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));

		local path = util.get_path('pop_up.png');
		local frect = cc.rect(0, 0, 64, 64); -- fullrect
		local irect = cc.rect(30, 30, 4, 4); -- insetrect
		local size = cc.size(wfix(505), hfix(302));--realsize
		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		local bg = util.add_scale9sprite(self.layer, path, pos, ANCHOR_CENTER_CENTER, frect, irect, size, 10); 

    	if nil ~= msg then
			pos = cc.p(size.width/2, size.height-50);
			local lsize = cc.size(size.width-40, 70);
			util.add_labeloutline(bg, msg, nil, 25, pos, util.c4b_white, util.c4b_black, 1, ANCHOR_CENTER_UP, 1, lsize, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_TOP);
    	end

		if tip_type == self.TIP_TYPE_INVITE_FIGHT then
			self:init_btn_for_invite_fight(bg, size, data);
			return self.layer, self.name;
		end
		if tip_type == self.TIP_TYPE_ANSWER_FIGHT then
			self:init_btn_for_answer_fight(bg, size, data);
			return self.layer, self.name;
		end

		local items = {};

		pos = cc.p(size.width/2, 28);
		add_item_1(items, '取消',nil,30,self.remove,ANCHOR_CENTER_DOWN,pos);
		
		util.add_menu(bg, items, 1);

		return self.layer, self.name;
	end,

	cancel_invite_fight = function()
		local self = layer_fight;
		local data = self.data;
		self:remove();
		local cmd = string.format("challenge 1 %d", data.eid);
		net_send(cmd);
	end,

	init_btn_for_invite_fight = function(self, bg, size, data)
		self.data = data;
		local items = {};
		local item, p1, p2, pos;

		pos = cc.p(size.width/2, 28);
		add_item_1(items, '取消',nil,30,self.cancel_invite_fight,ANCHOR_CENTER_DOWN,pos);
		
		util.add_menu(bg, items, 1);
	end,

	accept_fight = function()
		local self = layer_fight;
		local data = self.data;
		self:remove();
		local cmd = string.format("challenge 2 %d", data.eid);
		net_send(cmd);
	end,

	refuse_fight = function()
		local self = layer_fight;
		local data = self.data;
		self:remove();
		local cmd = string.format("challenge 3 %d", data.eid);
		net_send(cmd);
	end,

	init_btn_for_answer_fight = function(self, bg, size, data)
		self.data = data;
		local items = {};

		pos = cc.p(size.width/4*3, 28);
		add_item_1(items, '接受',nil,30,self.accept_fight,ANCHOR_CENTER_DOWN,pos);

		pos = cc.p(size.width/4, 28);
		add_item_1(items, '拒绝',nil,30,self.refuse_fight,ANCHOR_CENTER_DOWN,pos);
		
		util.add_menu(bg, items, 1);
	end,

	handler = function(event, x, y)
		local self = layer_fight;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
	end,

} -- layer_fight end

layer_pick = { -- start
	name = 'layer_pick',
	layer = nil,
	list = nil,
	cwidth = nil,
	cheight = nil,
	bar = nil,
	tap = nil,
	rect = nil,
	callback = nil,
	to_close = nil,
	special = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.bar = nil;
		self.tap = nil;
		self.rect = nil;
		self.callback = nil;
		self.to_close = nil;
		self.spcial = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, list, cb, special)
		self:remove();
		self.special = special;
		self.list = list or {};
		self.callback = cb;
		self.layer = cc.Layer:create();

		local layer_color = cc.LayerColor:create(ccc4(0, 0, 0, 128));
		self.layer:addChild(layer_color);

		util.reg_handler(self.layer, -ZORDER_LAYER_PICK, self.handler, true);

		local sprite, fullpath, pos, size, width, height;

		self.cwidth = FULL_WIDTH - wfix(200);
		self.cheight = hfix(100);
		local width = self.cwidth+wfix(60);
		local height = self.cheight * #self.list+hfix(60);
		if height > FULL_HEIGHT - hfix(200) then
			height = FULL_HEIGHT - hfix(200);
		end

		local size = cc.size(width, 110+height);--realsize
		local bg, bg_rect = init_bg_for_popview(self.layer, '请选择', size, self.close);
		self.rect = bg_rect;

		pos = cc.p(self.rect.x1+30, self.rect.y1+30);
		local tsize = cc.size(size.width-60, size.height-40-110);
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+tsize.width, pos.y), tsize, ANCHOR_LEFT_DOWN, 24);
		util.add_tableview(self.layer, tsize, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, 20);

		return self.layer, self.name;
	end,

	close = function()
		local self = layer_pick;
		play_tap_1();
		self:remove();
	end,

	save_to_slot = function(...)
		local self = layer_pick;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		if nil ~= layer_deck.layer and nil ~= info then
			layer_deck:save_to_slot(info.tag, info.title);
		end
		self:close();
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_pick;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			if nil ~= self.callback then
				local info = self.list[idx + 1];
				local tag = info.tag;
				self.callback(tag);
			end
			self:close();
			return 0;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local info = self.list[idx + 1];
			local path = util.get_path('line_2.png');
			pos = ccp(self.cwidth/2, 0);
			local line = util.add_sprite(cell, path, pos, ANCHOR_CENTER_DOWN);
			line:setScaleX(self.cwidth/line:getContentSize().width);

			util.add_labelttf(cell, info.title, nil, 30, cc.p(0, self.cheight/2), util.c4b_white, ANCHOR_LEFT_CENTER);

			if 'is_deck' == self.special then
				local items = {};
				local item, p1, p2;

				pos = cc.p(self.cwidth, self.cheight/2);
				local size = cc.size(172, 52);
				local item = add_item_1(items, '保存到卡槽', nil, 20, self.save_to_slot, ANCHOR_RIGHT_CENTER, pos, size);
				item:setTag(idx + 1);

				util.add_menu(cell, items, 1);
			end
			return cell;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_pick;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.close();
		end
	end,

	onTouchBegan = function(self, x, y)
		self.to_close = nil;
		local rect = self.rect;
		if nil == rect or x<rect.x1 or x>rect.x2 or y<rect.y1 or y>rect.y2 then
			self.to_close = true;
		end
		return true;
	end,

	onTouchMoved = function(self, x, y)		

	end,

	onTouchEnded = function(self, x, y)	
		local rect = self.rect;
		if true == self.to_close or x<rect.x1 or x>rect.x2 or y<rect.y1 or y>rect.y2 then
			self:close();
		end
	end,
} -- layer_pick end

layer_mission = {
	name = 'layer_mission',
	layer = nil,
	list = nil,
	tableview = nil,
	rect = nil,
	cwidth = nil,
	cheight = nil,
	theight = nil,
	bar = nil,
	tap = nil,
	mission_count = nil,
	data_cell = nil,
	data_detail = nil,
	icon_up = nil,
	icon_down = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.tableview = nil;
		self.rect = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.theight = nil;
		self.bar = nil;
		self.tap = nil;
		self.mission_count = nil;
		self.data_cell = nil;
		self.data_detail = nil;
		self.icon_up = nil;
		self.icon_down = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_MISSION, self.handler, true);

		self.mission_count = 0;
		g_mission_tip = nil;
		if nil ~= layer_map.layer then
			layer_chat:tip_btn_mission();
		end
		layer_chat:tip_btn_mission();
		self.list = {};
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));
		local sprite, data;
		local offsetheight, bg, rect = init_bg_for_view(self.layer, GUI_MISSION, '奖励', self.back);
		self.rect = rect;

		data = gui_get_data('detail', GUI_MISSION, ANCHOR_DOWN);
		self.data_detail = data;
		data = gui_get_data('cell', GUI_MISSION, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height + 10;
		data = gui_get_data('table', GUI_MISSION, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		self.theight = size.height;
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos,cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		pos = cc.p(data.x+data.width, data.y+size.height);
		self.icon_up = add_scroll_icons(self.layer, pos, true);
		self.icon_up:setVisible(false);
		pos = cc.p(data.x+data.width, data.y);
		self.icon_down = add_scroll_icons(self.layer, pos, false);
		self.icon_down:setVisible(false);


		return self.layer, self.name;
	end,

	back = function()
		play_tap_1();
		local self = layer_mission;
		self:remove();
	end,

	reload = function(self, offset)
		self.tableview:reloadData();
		if nil ~= offset then
			self.tableview:setContentOffset(offset, false);
		end
	end,

	add_list = function(self, list, has_more)
		list = list or {};
		self.list = self.list or {};
		if 0 == #self.list then
			self.mission_count = 0;
		end
		if 0 < #self.list then
			local info = self.list[#self.list];
			if true == info.flag_more_cell then
				table.remove(self.list, #self.list);
			end
		end
		for i = 1, #list do
			table.insert(self.list, list[i]);
			self.mission_count = self.mission_count + 1;
		end
		if true == has_more then
			local more_cell = { flag_more_cell = true };
			table.insert(self.list, more_cell);
		end
		self:reload();
	end,

	get_more = function()
		local self = layer_mission;
		local index = self.mission_count or 0;
		local cmd = 'mlist ' .. index;
		net_send(cmd);
	end,

	get_reward = function(...)
		local args = {...};
		local tag = args[2]:getTag();
		local self = layer_mission;
		local info = self.list[tag];
		local mid = info.mid;
		net_send('mreward ' .. mid);
	end,

	go_action = function(...)
		local args = {...};
		local tag = args[2]:getTag();
		local self = layer_mission;
		local info = self.list[tag];
		self:do_gate(info.p2);
	end,

	do_gate = function(self, gate_id)
		local gate_id = tonumber(gate_id) or 0;
		if 0 == gate_id then
			show_gate();
			return;
		end
		net_send('gate ' .. gate_id);
	end,

	show_card = function(...)
		local args = {...};
		local tag = args[2]:getTag();
		local self = layer_mission;
		local info = self.list[tag];
		if nil == info then return; end
		local card = info.card;
		if nil == card then return; end
		g_scene:add_layer(ZORDER_LAYER_MISPOP, layer_mispop:create(card));
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_mission;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			update_scroll_icon(self.icon_up, self.icon_down, view, self.theight);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			play_tap_3();
			local cell = args[3];
			local idx = cell:getIdx();
			local info, index;
			index = idx + 1;
			info = self.list[index];
			if true == info.flag_more_cell then return; end
			if true == info.is_detail_cell then return; end
			local detail = info.detail;

			index = idx + 2;
			info = self.list[index]; -- check the next cell
			local offset = view:getContentOffset();
			local gh = 0;
			if nil == info or true ~= info.is_detail_cell then
				local l = { is_detail_cell = true, detail = detail };
				table.insert(self.list, index, l);
				offset.y = offset.y - self.cheight;
				gh = self.cheight * 2;
			else
				table.remove(self.list, index);
				offset.y = offset.y + self.cheight*2;
				gh = -self.cheight * 2;
			end
			index = idx+1;
			local cy = 0;
			local limit = index-1;
			if limit > #self.list then limit = #self.list; end
			for i = 1, limit do
				local is_detail = self.list[i].is_detail_cell;
				cy = cy + self.cheight;
				if true == is_detail then
					cy = cy + self.cheight;
				end
			end
			offset.y = self.theight-(view:getContentSize().height+gh)+cy;
			self:reload(offset);
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			local info = self.list[idx + 1];
			if true == info.is_detail_cell then
				return self.cheight*2, self.cwidth;
			end
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local info = self.list[idx + 1];
			local width = self.cwidth;
			local height = self.cheight;
			if true == info.flag_more_cell then
				local items = {};

				pos = cc.p(width/2, height/2);
				size = cc.size(172, 52);
				local item = add_item_1(items, '更多任务', nil, 20, self.get_more, ANCHOR_CENTER_CENTER, pos, size);
				item:setTag(idx + 1);

				util.add_menu(cell, items, 1);
				return cell;
			end
			local cid = info.reward_card;
			local data2, sprite, path, pos, size, str;
			if true == info.is_detail_cell then
				local data = self.data_detail;
				sprite = gui_add_cell_bg(cell, data);
				height = height*2;
				sprite:setContentSize(cc.size(width, height));

				local gap = 30;
				str = info.detail;
				pos = cc.p(gap, gap);
				size = cc.size(width-gap*2, height-gap*2);
				util.add_labelttf(cell, str, nil, 23, pos, util.c4b_white, ANCHOR_LEFT_DOWN, data.zorder+10, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_TOP);
				return cell;
			end
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local offsetx = 0;
			data2 = gui_get_data('card', GUI_MISSION, ANCHOR_DOWN);
			if 0 < cid then
				pos = ccp(data2.x-data.x,data2.y-data.y);
				local card = clone(g_card_list[cid]);
				if nil == card then card = clone(hero_list[cid]); end
				if nil ~= card then
					info.card = card;
					local cobj = object_card:new(cell, card, nil, nil, pos, 0, data2.height/CARD_SIZE_2.height, STYPE_VER_2);
					sprite = cobj:get_front();
					sprite:retain();
					sprite:removeFromParentAndCleanup(true);
					local items = {};
					local item;
					item=util.create_item_sprite(sprite,sprite,pos,ANCHOR_LEFT_DOWN,self.show_card);
					item:setTag(idx + 1);
					table.insert(items, item);

					util.add_menu(cell, items, data2.zorder);
				else
					offsetx = -data2.width;
				end
			else
				offsetx = -data2.width;
			end
			str = info.title;
			data2 = gui_get_data('mtitle', GUI_MISSION, ANCHOR_DOWN);
			pos = cc.p(data2.x-data.x+offsetx, data2.y-data.y);
			size = cc.size(width-pos.x, height-pos.y);
			sprite = util.add_labelttf(cell, str, nil, 23, pos, util.c4b_black, ANCHOR_LEFT_DOWN, data2.zorder, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

			sprite, data2 = gui_add_sprite_on_cell(cell, data, 'gold', GUI_MISSION, ANCHOR_DOWN);
			if info.crystal > 0 then
				local path = util.get_path('crystal.png');
				local tc = cc.Director:getInstance():getTextureCache();
				local texture = tc:addImage(path);
				if nil ~= texture then 
					sprite:setTexture(texture);
				end
			end
			sprite:setPositionX(data2.x + offsetx);

			str = '经验:';
			sprite, data2 = gui_add_label_on_cell(cell,data,str,23,'exp',GUI_MISSION,ANCHOR_DOWN);
			sprite:setPositionX(data2.x + offsetx);

			path = util.get_path(FNT_1);
			str = info.gold;
			if info.crystal > 0 then
				str = info.crystal;
			end
			sprite, data2 = gui_add_labelbmf_on_cell(cell,data,str,path,'gold_num',GUI_MISSION,ANCHOR_DOWN);
			sprite:setPositionX(data2.x + offsetx);

			str = info.exp;
			sprite, data2 = gui_add_labelbmf_on_cell(cell,data,str,path,'exp_num',GUI_MISSION,ANCHOR_DOWN);
			sprite:setPositionX(data2.x + offsetx);

			if 2 == info.status then
				local items = {};
				local item;

				item, data2 = gui_add_item_on_cell(items, data, 'btn_get', GUI_MISSION, self.get_reward, ANCHOR_DOWN);
				str = '领取';
				gui_add_text_on_sprite(item,str,'t_get',GUI_MISSION,ANCHOR_DOWN,30);
				item:setTag(idx + 1);

				util.add_menu(cell, items, data2.zorder);
			elseif 1 == info.mtype or 16 == info.mtype then
				local items = {};
				local item;

				item, data2 = gui_add_item_on_cell(items, data, 'btn_get', GUI_MISSION, self.go_action, ANCHOR_DOWN);
				str = 1 == info.mtype and '闯关' or '挑战';
				gui_add_text_on_sprite(item,str,'t_get',GUI_MISSION,ANCHOR_DOWN,30);
				item:setTag(idx + 1);

				util.add_menu(cell, items, data2.zorder);
			elseif 17 == info.mtype or 18 == info.mtype or 19 == info.mtype then
				local items = {};
				local item;

				item, data2 = gui_add_item_on_cell(items, data, 'btn_get', GUI_MISSION, show_service, ANCHOR_DOWN);
				str = '对战';
				gui_add_text_on_sprite(item,str,'t_get',GUI_MISSION,ANCHOR_DOWN,30);
				item:setTag(idx + 1);

				util.add_menu(cell, items, data2.zorder);
			elseif 20 == info.mtype then
				local items = {};
				local item;

				item, data2 = gui_add_item_on_cell(items, data, 'btn_get', GUI_MISSION, go_pay, ANCHOR_DOWN);
				str = '充值';
				gui_add_text_on_sprite(item,str,'t_get',GUI_MISSION,ANCHOR_DOWN,30);
				item:setTag(idx + 1);

				util.add_menu(cell, items, data2.zorder);
			elseif 21 == info.mtype then
				local items = {};
				local item;

				item, data2 = gui_add_item_on_cell(items, data, 'btn_get', GUI_MISSION, show_prank, ANCHOR_DOWN);
				str = '竞技';
				gui_add_text_on_sprite(item,str,'t_get',GUI_MISSION,ANCHOR_DOWN,30);
				item:setTag(idx + 1);

				util.add_menu(cell, items, data2.zorder);
			end
			--[[
			elseif 1 ~= info.status then
				data2 = gui_get_data('btn_get', GUI_MISSION, ANCHOR_DOWN);
				pos = cc.p(data2.x-data.x, data2.y-data.y);
				size = cc.size(data2.width, data2.height);
				sprite = util.add_labelttf(cell, 'X', nil, 23, pos, util.c4b_white, ANCHOR_LEFT_DOWN, data2.zorder, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);
			]]--
			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_mission;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.back();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		local r = self.rect;
		if nil == r then
			return;
		end
		if x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2 then
			self.back();
		end
	end,
} -- layer_mission end

layer_mispop = { -- start
	name = 'layer_mispop',
	layer = nil, 
	sprite = nil,

	cleanup = function(self)
		self.layer = nil;
		self.sprite = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, _card)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_MISPOP, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));

		local card = clone(_card);
		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT - hfix(50));
		local cwidth = FULL_WIDTH - wfix(70);
		local cheight = FULL_HEIGHT - hfix(340);
		local scale = get_card_scale(cwidth, cheight, CARD_SIZE);
		local cinfo = object_card:new(self.layer, card, nil, nil, pos, 0, scale, STYPE_VER_1);
		local sprite = cinfo:get_front();
		self.sprite = sprite;

		pos.y = HALF_HEIGHT;
		local farray = {};
		local action;
		table.insert(farray, cc.CallFunc:create(disable_touch));
		action = cc.EaseIn:create(cc.MoveTo:create(0.2, pos), 0.2);
		table.insert(farray, action);
		table.insert(farray, cc.CallFunc:create(enable_touch));

		sprite:runAction( cc.Sequence:create(farray));
		
		return self.layer, self.name;
	end, 

	show_eff1 = function(self)
		local sprite = self.sprite;
		if nil == sprite then
			return;
		end
		local scale = sprite:getScale();
		sprite:setScale(0.1);
		local farray = {};
		local action;
		action = cc.ScaleTo:create(0.5, scale);
		table.insert(farray, action);
		action = cc.RotateBy:create(0.5, 720);
		table.insert(farray, action);

		action = cc.Spawn:create(farray);
		sprite:runAction(action);
	end,

	handler = function(event, x, y)
		local self = layer_mispop;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)
		self:remove();
	end,

} -- layer_mispop end

layer_popclist = { -- start
	name = 'layer_popclist',
	layer = nil, 
	list = nil,
	last_data = nil,
	can_touch = nil,
	btn_again = nil,
	btn_back = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.last_data = nil;
		self.can_touch = nil;
		self.btn_again = nil;
		self.btn_back = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, clist, is_lottery)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_POPCLIST, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));

		self.can_touch = false;
		self.btn_again = nil;
		self.list = {};

		local t_again = nil;
		if #clist > 1 then
			self:init_for_more(clist);
			t_again = '再抽10次';
		else
			self:init_for_one(clist);
			t_again = '再抽1次';
		end

		local items = {};
		local label, item, pos;

		if true == is_lottery then
			pos = cc.p(HALF_WIDTH/2, hfix(30));
			item = add_item_1(items, t_again, nil, 20, self.do_again, ANCHOR_CENTER_DOWN, pos);
			self.btn_again = item;

			pos = cc.p(HALF_WIDTH/2*3, hfix(30));
		else
			pos = cc.p(HALF_WIDTH, hfix(30));
		end

		item = add_item_1(items, '返回', nil, 20, self.back, ANCHOR_CENTER_DOWN, pos);
		self.btn_back = item;

		util.add_menu(self.layer, items, 80);
		enable_btn(self.btn_again, false);
		enable_btn(self.btn_back, false);
		
		return self.layer, self.name;
	end, 

	back = function()
		layer_popclist:remove();
	end,

	init_for_more = function(self, clist)
		--[[
		local path = util.get_path('l_eff_2.plist');
		local p = util.add_particle(self.layer, path, cc.p(HALF_WIDTH, HALF_HEIGHT), 1);
		]]--
		local speed = 1000;
		local delay = 0;
		local function flip(...)
			local args = {...};
			local tag = args[1]:getTag();
			local info = self.list[tag].info;
			if nil == info then return; end
			local sprite = info.sprite;
			info:flip_to_front();
			--[[
			local x, y = sprite:getPosition();
			local zorder = sprite:getLocalZOrder()-10;
			local scale = sprite:getScale();
			local path = util.get_path('l_eff_1.plist');
			local p = util.add_particle(self.layer, path, cc.p(x, y), zorder);
			p.batch:setScale(scale);
			]]--
		end
		local move_h = hfix(100);
		for i = 1, #clist do
			local card = clist[i];
			local pos = cc.p(HALF_WIDTH, HALF_HEIGHT+move_h/2);
			local cwidth = HALF_WIDTH;
			local cheight = HALF_HEIGHT;
			local scale = get_card_scale(cwidth, cheight, CARD_SIZE);
			local cinfo = object_card:new(self.layer, card, nil, nil, pos, 0, scale, STYPE_VER_1);
			local sprite = cinfo:get_cover();
			self.layer:reorderChild(sprite, 50-i);
			sprite:setTag(i);

			local index = i;
			if i > 5 then
				index = index + 2;
			end

			local offsetx = FULL_WIDTH / 4;
			local x = offsetx/2 + (index-1) % 4 * offsetx;
			local y = FULL_HEIGHT/4*3 - math.floor((index-1)/4) * FULL_HEIGHT/4;
			if i < 5 then
				y = FULL_HEIGHT - cheight/3*2*0.3;
			elseif i > 6 then
				y = cheight/3*2*0.3+move_h;
			else
				y = HALF_HEIGHT+move_h;
			end
			local tpos = cc.p(x, y);
			local tscale = 0.3;
			local offset = math.sqrt(math.pow((x-pos.x),2)+math.pow((y-pos.y),2));
			local array = {};
			local sa = {};
			local t = offset / speed;
			table.insert(array, cc.DelayTime:create(delay));
			table.insert(sa, cc.MoveTo:create(t, tpos));
			table.insert(sa, cc.ScaleTo:create(t, tscale));
			table.insert(array, cc.Spawn:create(sa));
			local orbit_time = 0.3;
			local orbit1 = cc.OrbitCamera:create(orbit_time, 1, 0, 0, -90, 0, 0);
			local orbit2 = cc.OrbitCamera:create(orbit_time, 1, 0, 90, -90, 0, 0);
			table.insert(array, orbit1);
			table.insert(array, cc.CallFunc:create(flip));
			table.insert(array, orbit2);
			table.insert(array, cc.CallFunc:create(self.show_eff));
			if i == #clist then
				table.insert(array, cc.CallFunc:create(self.after_eff));
			end

			local data = { info = cinfo, scale = scale, pos = pos, tpos = tpos, tscale = tscale };
			table.insert(self.list, data);
			sprite:runAction(cc.Sequence:create(array));
			delay = delay + t/2;
		end
	end,

	init_for_one = function(self, clist)
		local card = clist[1];
		if nil == card then 
			self.after_eff(); 
			return;
		end
		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT - hfix(50));
		local cwidth = FULL_WIDTH - wfix(70);
		local cheight = FULL_HEIGHT - hfix(340);
		local scale = get_card_scale(cwidth, cheight, CARD_SIZE);
		local cinfo = object_card:new(self.layer, card, nil, nil, pos, 0, scale, STYPE_VER_1);
		local sprite = cinfo:get_front();
		sprite:setTag(1);
		sprite:setScale(scale*0.5);

		pos.y = HALF_HEIGHT;
		local array = {};
		local sa = {};
		local action;
		table.insert(sa, cc.ScaleTo:create(0.5, scale));
		table.insert(sa, cc.RotateBy:create(0.5, 720));
		table.insert(array, cc.Spawn:create(sa));
		table.insert(array, cc.CallFunc:create(self.show_eff));
		table.insert(array, cc.CallFunc:create(self.after_eff));

		local data = { info = cinfo, scale = scale, pos = pos };
		table.insert(self.list, data);

		sprite:runAction(cc.Sequence:create(array));
	end,

	show_eff = function(...)
		local self = layer_popclist;
		local args = {...};
		local tag = args[1]:getTag();
		local info = self.list[tag].info;
		if nil == info then return; end
		local sprite = info.sprite;
		local num_star = info.card.star or 0;
		if num_star < 4 then return; end
		if nil == sprite then return; end
		local x, y = sprite:getPosition();
		local scale = sprite:getScale();
		local size = sprite:getContentSize();
		local width = size.width*scale;
		local height = size.height*scale;
		local hw = width/2;
		local hh = height/2;
		local x1 = x - hw;
		local x2 = x + hw;
		local y1 = y - hh;
		local y2 = y + hh;
		local path = util.get_path('tutor_star.png');
		local pos = cc.p(x1, y1);
		sprite = util.add_sprite(self.layer, path, pos, ANCHOR_CENTER_CENTER, 60);

		local speed = 250;
		local tx = (x2 - x1) / speed;
		local ty = (y2 - y1) / speed;

		local array = {};
		table.insert(array, cc.MoveTo:create(ty, cc.p(x1, y2)));
		table.insert(array, cc.MoveTo:create(tx, cc.p(x2, y2)));
		table.insert(array, cc.MoveTo:create(ty, cc.p(x2, y1)));
		table.insert(array, cc.MoveTo:create(tx, cc.p(x1, y1)));
		sprite:runAction(cc.RepeatForever:create(cc.Sequence:create(array)));
		sprite:runAction(cc.RepeatForever:create(cc.RotateBy:create(1, 360)));

		path = util.get_path('tutor_tail.plist');
		pos = cc.p(x1, y1);
		local p = util.add_particle(self.layer, path, pos, 55);
		sprite = p.batch;
		sprite:setTag(320);

		array = {};
		table.insert(array, cc.MoveTo:create(ty, cc.p(x1, y2)));
		table.insert(array, cc.MoveTo:create(tx, cc.p(x2, y2)));
		table.insert(array, cc.MoveTo:create(ty, cc.p(x2, y1)));
		table.insert(array, cc.MoveTo:create(tx, cc.p(x1, y1)));

		sprite:runAction(cc.RepeatForever:create(cc.Sequence:create(array)));
	end,

	do_again = function()
		local self = layer_popclist;
		if nil ~= layer_lottery.layer then
			layer_lottery:do_again();
		end
	end,

	after_eff = function()
		local self = layer_popclist;
		self.can_touch = true;
		if #self.list > 1 then
			self:show_card(self.list[1]);
		end
		enable_btn(self.btn_again, true);
		enable_btn(self.btn_back, true);
		if g_tutor_wait_net == tutor_pay_ad_3 then
			g_tutor_wait_net();
		end
	end,

	check_touch = function(self, x, y)
		if 1 == #self.list then return nil; end
		for i = 1, #self.list do
			local data = self.list[i];
			local info = data.info;
			local sprite = info.sprite;
			local ox, oy = sprite:getPosition();
			local size = sprite:getContentSize();
			local scale = sprite:getScale();
			local hw = size.width*scale/2;
			local hh = size.height*scale/2;
			if data ~= self.last_data and x > ox-hw and x < ox+hw and y > oy-hh and y < oy+hh then
				return data;
			end
		end
		return nil;
	end,

	show_card = function(self, data)
		local speed = 1500;
		local move_tag = 333;
		if nil ~= self.last_data then
			local ld = self.last_data;
			local sprite = ld.info.sprite;
			sprite:stopActionByTag(move_tag);
			local p1 = ld.pos;
			local p2 = ld.tpos;
			local offset = math.sqrt(math.pow((p1.x-p2.x),2)+math.pow((p1.y-p2.y),2));
			local array = {};
			local t = offset / (speed*1.5);
			table.insert(array, cc.MoveTo:create(t, p2));
			table.insert(array, cc.ScaleTo:create(t, ld.tscale));
			local action = cc.Spawn:create(array);
			action:setTag(move_tag);
			sprite:runAction(action);
		end
		self.last_data = data;
		local ld = data;
		local p1 = ld.pos;
		local p2 = ld.tpos;
		local sprite = ld.info.sprite;
		local offset = math.sqrt(math.pow((p1.x-p2.x),2)+math.pow((p1.y-p2.y),2));
		local array = {};
		local t = offset / speed;
		table.insert(array, cc.MoveTo:create(t, p1));
		table.insert(array, cc.ScaleTo:create(t, ld.scale));
		local action = cc.Spawn:create(array);
		action:setTag(move_tag);
		sprite:runAction(action);
	end,

	handler = function(event, x, y)
		local self = layer_popclist;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)
		if true ~= self.can_touch then return; end
		local data = self:check_touch(x, y);
		if nil == data then return; end
		self:show_card(data);
	end,

} -- layer_popclist end

layer_control = { -- start
	name = 'layer_control',
	layer = nil,
	is_stop = nil,
	speed = nil,

	cleanup = function(self)
		self.layer = nil;
		self.is_stop = nil;
		self.speed = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_CONTROL, self.handler, false);

		self.is_stop = false;
		self.speed = 1;
		
		local items = {};
		local label, item, pos;
		local size = cc.size(160, 52);

		pos = cc.p(HALF_WIDTH-wfix(30), HALF_HEIGHT);
		item = add_item_1(items, '暂停', nil, 20, self.cb_stop, ANCHOR_RIGHT_CENTER, pos, size);

		pos = cc.p(HALF_WIDTH+wfix(30), HALF_HEIGHT);
		item = add_item_1(items, '速度x1', nil, 20, self.cb_speed, ANCHOR_LEFT_CENTER, pos, size);

		util.add_menu(self.layer, items, 10);

		return self.layer, self.name;
	end,

	cb_stop = function(...)
		local args = {...};
		local item = args[2];
		local label = item:getChildByTag(TAG_SPRITE_LABEL);
		local str = nil;
		local self = layer_control;
		self.is_stop = not self.is_stop;
		local director = cc.Director:getInstance();
		if true == self.is_stop then
			director:pause();
			str = '继续';
		else
			director:resume();
			str = '暂停';
		end
		if nil ~= label then
			label:setString(str);
		end
	end,

	cb_speed = function(...)
		local args = {...};
		local item = args[2];
		local label = item:getChildByTag(TAG_SPRITE_LABEL);
		local str = nil;
		local self = layer_control;
		self.speed = self.speed + 1;
		if self.speed > 2 then
			self.speed = 1;
		end
		local director = cc.Director:getInstance();
		local scheduler = director:getScheduler();
		if 2 == self.speed then
			scheduler:setTimeScale(2);
			str = '速度x2';
		else -- 1 == self.speed
			scheduler:setTimeScale(1);
			str = '速度x1';
		end
		if nil ~= label then
			label:setString(str);
		end
	end,

	handler = function(event, x, y)
		local self = layer_control;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
	end,

	onTouchEnded = function(self, x, y)
	end,
} -- layer_control end
-- /////////////////////// LAYER END   ///////////////////////////

-- /////////////////////// TESTLUA START ///////////////////////////
function show_test1(layer) -- show_test1 start {
	local label = nil;
	local text = "1234567890'labelttf'abcdefghijklmnopgrstuvwxyz不是吧!!";
	local path = util.get_fullpath(F_FONT, "zpixel2_ex.ttf");
	local pos = ccp(0, FULL_HEIGHT-80);
	label = util.add_labeloutline(layer, text, path, 40, pos, util.c4b_white, util.c4b_black, 1, ANCHOR_LEFT_UP, 10, cc.size(FULL_WIDTH, 200), cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_TOP);

	pos.y = pos.y - 200;
	label = util.add_labelglow(layer, text, path, 40, pos, util.c4b_white, util.c4b_red, ANCHOR_LEFT_UP, 10, cc.size(FULL_WIDTH, 200), cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

	pos.y = pos.y - 200;
	pos.y = 0;
	label = util.add_labelshadow(layer, text, path, 40, pos, util.c4b_white, util.c4b_red, ANCHOR_LEFT_UP, 10, cc.size(FULL_WIDTH, 200), cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

	--show_loading('加载中');

	local function onTouch(event, x, y)
		if event == "began" then   
			return true;
		elseif event == "moved" then
			return 
		else
			return 
		end
	end
	util.layer_register(layer, -(ZORDER_LAYER_TESTLUA+20), onTouch, false, true);
end -- show_test1 end }

function show_test2(layer) -- show_test2 start {

	local card = clone(g_card_list[22]);	
	local pos = cc.p(CARD_SIZE.width/2+50, FULL_HEIGHT-100-CARD_SIZE.height/2);
	local rotation = 0;
	local scale = 1;
	--local info = object_card:sample(layer, pos, rotation, scale);
	local info = object_card:new(layer, card, nil, nil, pos, rotation, scale);
	local sprite = info:get_front();

	card = clone(g_card_list[22]);	
	pos.x = pos.x + CARD_SIZE.width/2 + CARD_SIZE_2.width/2 + 50;
	info = object_card:new(layer, card, nil, nil, pos,rotation,scale,STYPE_VER_2);
	sprite = info:get_front();

	local function onTouch(event, x, y)
		if event == "began" then   
			return true;
		elseif event == "moved" then
			return 
		else
			return 
		end
	end
	util.layer_register(layer, -(ZORDER_LAYER_TESTLUA+20), onTouch, false, true);
end -- show_test2 end }

function show_test3(layer) -- show_test3 start {

	g_euser.exp_next = 200;
	g_euser.exp_this = 100;
	g_euser.exp = 150;
	g_euser.level = 2;

	local function win()
		local data = {};
		data.rating = 1000;
		data.gold = 9999;
		data.exp = 200;
		data.level = 4;
		data.exp_next = 400;
		data.exp_this = 300;
		data.card_id = 1;
		local tag = layer_result.TAG_WIN;
		g_scene:add_layer(ZORDER_LAYER_RESULT, layer_result:create(tag, data));
	end

	local function lose()
		local data = {};
		data.rating = -222;
		data.gold = 0;
		data.exp = 0;
		data.level = 0;
		data.exp_next = 0;
		local tag = layer_result.TAG_LOSE;
		g_scene:add_layer(ZORDER_LAYER_RESULT, layer_result:create(tag, data));
	end

	local function draw()
		local data = {};
		data.rating = 0;
		data.gold = 0;
		data.exp = 0;
		data.level = 0;
		data.exp_next = 0;
		local tag = layer_result.TAG_DRAW;
		g_scene:add_layer(ZORDER_LAYER_RESULT, layer_result:create(tag, data));
	end

	local function guest()
		local data = {};
		data.winnername = 'kelton';
		local tag = layer_result.TAG_GUEST;
		g_scene:add_layer(ZORDER_LAYER_RESULT, layer_result:create(tag, data));
	end

	local items = {};
	local item;
	local size = cc.size(172, 52);

	pos = cc.p(HALF_WIDTH/2, HALF_HEIGHT/2-hfix(50));
	item = add_item_1(items, 'win', nil, 20, win, ANCHOR_CENTER_CENTER, pos,size);

	pos = cc.p(FULL_WIDTH/3*2, HALF_HEIGHT/2-hfix(50));
	item = add_item_1(items, 'lose', nil, 20, lose,ANCHOR_CENTER_CENTER,pos,size);

	pos = cc.p(FULL_WIDTH/3*2, HALF_HEIGHT);
	item = add_item_1(items, 'draw', nil, 20, draw,ANCHOR_CENTER_CENTER,pos,size);

	pos = cc.p(HALF_WIDTH/2, HALF_HEIGHT);
	item = add_item_1(items, 'guest', nil,20,guest,ANCHOR_CENTER_CENTER,pos,size);

	util.add_menu(layer, items);
	local function onTouch(event, x, y)
		if event == "began" then   
			return true;
		elseif event == "moved" then
			return 
		else
			return 
		end
	end
	util.layer_register(layer, -(ZORDER_LAYER_TESTLUA+20), onTouch, false, true);
end -- show_test3 end }

function show_test4(layer) -- show_test4 start {

	local card = clone(g_card_list[22]);	
	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT / 4 * 3);
	local rotation = 0;
	local scale = 1;
	local info = object_card:new(layer, card, nil, nil, pos, rotation, scale,STYPE_VER_2);
	local s_up = info:get_front();

	card = clone(g_card_list[22]);	
	pos.y = HALF_HEIGHT / 2;
	info = object_card:new(layer, card, nil, nil, pos,rotation,scale,STYPE_VER_2);
	local s_down = info:get_front();

	local function eff_frames()
		play_eff(layer, 2, s_down, s_up, 0, false);
	end

	local function eff_cocostudio()
		play_animation(layer, 2, s_down, s_up, 0, false);
	end

	local function eff_flash()
		local function cbb()
			print('cbb is call');
		end
		--play_flash(layer, 2, s_down, s_up, 0, false, cbb);
		play_flash(layer, 502, s_down, s_up, 0, false, cbb);
	end

	local items = {};
	local item;

	add_item_1(items, 'flash', nil, 25, eff_flash, ANCHOR_LEFT_DOWN, cc.p(0,200));

	add_item_1(items, 'cocostudio', nil, 25, eff_cocostudio, ANCHOR_LEFT_DOWN, cc.p(0, 100));

	add_item_1(items, 'frames', nil, 25, eff_frames, ANCHOR_LEFT_DOWN, cc.p(0,0));

	util.add_menu(layer, items);
	local function onTouch(event, x, y)
		if event == "began" then   
			return true;
		elseif event == "moved" then
			return 
		else
			return 
		end
	end
	util.layer_register(layer, -(ZORDER_LAYER_TESTLUA+20), onTouch, false, true);
end -- show_test4 end }

function show_test5(layer) -- {

	local fullpath = util.get_fullpath(F_IMAGE, 'bg_8.png');
	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
	local sprite = util.add_sprite(layer, fullpath, pos, ANCHOR_CENTER_CENTER);

	local function cb1()
		show_msg('press btn1');
	end

	local function cb2()
		show_msg('press btn2');
	end

	local items = {};
	local item;
	local size = cc.size(172, 52);

	pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
	item = add_item_1(items, 'btn1', nil, 20, cb1, ANCHOR_CENTER_CENTER, pos, size);
	local tsize = item:getContentSize();
	local tpos = cc.p(pos.x-tsize.width/2, pos.y-tsize.height/2);

	pos = cc.p(HALF_WIDTH, HALF_HEIGHT/2*3);
	item = add_item_1(items, 'btn2', nil, 20, cb2, ANCHOR_CENTER_CENTER, pos, size);

	util.add_menu(layer, items, 1);

	util.add_tutorial(tpos, tsize, TUTOR_TEST);

	local t_mark = 0;
	print('t_mark, TUTOR_RES: ', t_mark, TUTOR_RES);
	local a = util.bit_lshift(1, TUTOR_RES);
	t_mark = util.bit_and(t_mark, a);
	print('and1 t_mark: ', t_mark);
	a = util.bit_lshift(1, TUTOR_RES);
	print('lshift: ', a);
	t_mark = util.bit_or(t_mark, a);
	print('or t_mark: ', t_mark);
	a = util.bit_lshift(1, TUTOR_RES);
	t_mark = util.bit_and(t_mark, a);
	print('and t_mark: ', t_mark);

	local function onTouch(event, x, y)
		if event == "began" then   
			return true;
		elseif event == "moved" then
			return 
		else
			return 
		end
	end
	util.layer_register(layer, -(ZORDER_LAYER_TESTLUA+20), onTouch, false, true);
end -- show_test5 end }

function show_test6(layer) -- {
	
	local function cb1()
		local c = #(layer_horselamp.list or {});
		util.show_horselamp(string.format("test #list[%d]", c), 2);
	end

	local items = {};
	local item;
	local size = cc.size(172, 52);

	pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
	item = add_item_1(items, '走马灯', nil, 20, cb1, ANCHOR_CENTER_CENTER, pos, size);

	util.add_menu(layer, items, 1);

	local function handler(event, x, y)
		print('event: ', event);
		if "began" == event then   
			return true;
		elseif "moved" == event then
		elseif "ended" == event or "cancelled" == event then
		elseif "enter" == event then
		elseif "exit" == event then
			layer_horselamp:remove();
		elseif "backClicked" == event then
		end
	end
	util.reg_handler(layer, -(ZORDER_LAYER_HORSELAMP+20), handler, true);
end -- show_test6 end }

function show_test7(layer) -- {
	local seed = 2613; 
	math.randomseed(seed);
	local a = math.random(1, 50);
	local b = math.random(1, 33);
	local c = math.random(1, 74);
	local d = math.random(1, 101); 
	local e; --  = mathf.random(1, 244);
	e = 0;
	for i=1,9999 do
		math.randomseed(i);
		for j=1,1000 do
			e = (e + math.random(1, 200)) % 1000; 
		end   
	end   

	local jitversion = 'jit is nil';
	if nil ~= jit then
		jitversion = jit.version;
	end

	local str = string.format("luajit version = [%s](LuaJIT 2.0.2)\nrandom seed is %d\na = random(1, 50) => [%d](14)\nb = random(1, 33) => [%d](28)\nc = random(1, 74) => [%d](62)\nd = random(1, 101) => [%d](88)\ne = 9999 * 1000 random => [%d](585)\n", jitversion, seed, a, b, c, d, e);
	util.add_labelttf(layer, str, nil, 35, cc.p(0, HALF_HEIGHT), util.c4b_black, ANCHOR_LEFT_CENTER, 1);

	local function handler(event, x, y)
		print('event: ', event);
		if "began" == event then   
			return true;
		elseif "moved" == event then
		elseif "ended" == event or "cancelled" == event then
		elseif "enter" == event then
		elseif "exit" == event then
			layer_horselamp:remove();
		elseif "backClicked" == event then
		end
	end
	util.reg_handler(layer, -(ZORDER_LAYER_HORSELAMP+20), handler, true);
end -- show_test7 end }

function show_test8(layer) -- {
	--local text = "[color=0FFFFF number=998]这是一条测试数据[/color][color=F0FF00]效果还ok吧[/color][image=wsk1.png]口[/image][color=FF0F00]+物攻[/color][color=F0FF00]*[0.4][/color][image=wsk1.png]口[/image][color=F0FF00]*[0.4][/color][color=0FFFFF]清除自身所有负面状态，并向敌军上/下半场吞吐雷电,造成[/color][color=F0FF00][360][/color][image=wsk1.png]口[/image][color=FF0F00]+物攻[/color][color=F0FF00]*[0.4][/color][image=wsk1.png]口[/image][color=F0FF00]*[0.4][/color]";
	local text = "[color=0FFFFF]这是一条测试数据[/color][color=F0FF00]效果还ok吧[/color][image=star.png][/image]";
	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
	local label = rich_label.new(layer, pos, text, "Arial", 30, 200, 2, 10);

	local function handler(event, x, y)
		print('event: ', event);
		if "began" == event then   
			return true;
		elseif "moved" == event then
		elseif "ended" == event or "cancelled" == event then
		elseif "enter" == event then
		elseif "exit" == event then
			layer_horselamp:remove();
		elseif "backClicked" == event then
		end
	end
	util.reg_handler(layer, -(ZORDER_LAYER_HORSELAMP+20), handler, true);
end -- show_test8 end }

function show_test9(layer) -- {
	local a = 1;
	if a == 1 then
		local url = string.format("http://%s:8899/pay_server/apple?", IP_ADDR);
		local args = {
			handler = layer_appstorepay.callback, url = url
		};        
		local luaoc = require "luaoc";
		local class_name = "IAPView";
		local ok, ret = luaoc.callStaticMethod(class_name, "testSend",args);
		return;
	end  

	local function handler(event, x, y)
		print('event: ', event);
		if "began" == event then   
			return true;
		elseif "moved" == event then
		elseif "ended" == event or "cancelled" == event then
		elseif "enter" == event then
		elseif "exit" == event then
			layer_horselamp:remove();
		elseif "backClicked" == event then
		end
	end
	util.reg_handler(layer, -(ZORDER_LAYER_HORSELAMP+20), handler, true);
end -- show_test9 end }
-- /////////////////////// TESTLUA END   ///////////////////////////

-- /////////////////////// GAME START ///////////////////////////
data_handler = {
	has_init_tables = false,
	show_all_card = false,

	cleanup = function(self)
		-- TODO need cleanup each layer_xxx ??
		--layer_loading:cleanup();

		g_ui_table = {};
		g_all_card_list = {};
		g_sprite_cache = {};
		g_pic_cache = {};
		g_cache_cmd_list = {};
		g_last_phase = 0;
		g_net_win_data = nil;
		g_is_in_tutor = nil;
		self.has_init_tables = false;
		self.show_all_card = false;
		reset_touchable();
		-- TODO
		--reset_touchable();
	end,

	-- clean card info in table list, is for net_game cmd refresh
	clean_ui_table = function(self)
		if nil == g_ui_table or 0 == #g_ui_table then
			return;
		end
		local sss = { SIDE_UP, SIDE_DOWN };
		local ttt = { T_HERO, T_HAND, T_ALLY, T_SUPPORT, T_GRAVE, T_DECK };
		for i = 1, #sss do
			local ss = g_ui_table[sss[i]];
			for j = 1, #ttt do
				local tt = ss[ttt[j]];
				local len = #tt;
				for i = 1, len do
					table.remove(tt, 1);
				end
			end
		end
		for k, v in pairs(g_sprite_cache) do
			v:removeFromParentAndCleanup(true);
			g_sprite_cache[k] = nil;
		end
		for k, v in pairs(g_pic_cache) do
			v:removeFromParentAndCleanup(true);
			g_pic_cache[k] = nil;
		end
	end,

	init_tables = function(self)
		self:cleanup();

		g_ui_table = {
			[SIDE_UP] = {
				[T_HERO]    = object_uitable:new(UP_HERO),
				[T_HAND]    = object_uitable:new(UP_HAND),
				[T_ALLY]    = object_uitable:new(UP_ALLY),
				[T_SUPPORT] = object_uitable:new(UP_SUPPORT),
				[T_GRAVE]   = object_uitable:new(UP_GRAVE),
				[T_DECK]    = object_uitable:new(UP_DECK),
				[T_RES]     = object_uitable:new(UP_RES),
			},
			[SIDE_DOWN] = {
				[T_HERO]    = object_uitable:new(DOWN_HERO),
				[T_HAND]    = object_uitable:new(DOWN_HAND),
				[T_ALLY]    = object_uitable:new(DOWN_ALLY),
				[T_SUPPORT] = object_uitable:new(DOWN_SUPPORT),
				[T_GRAVE]   = object_uitable:new(DOWN_GRAVE),
				[T_DECK]    = object_uitable:new(DOWN_DECK),
				[T_RES]     = object_uitable:new(DOWN_RES),
			},
			label_res = {
				[SIDE_DOWN] = nil,
				[SIDE_UP] = nil,
			},
			label_res_max = {
				[SIDE_DOWN] = nil,
				[SIDE_UP] = nil,
			},
		};

		g_all_card_list = {
			g_ui_table[SIDE_DOWN][T_HERO],
			g_ui_table[SIDE_DOWN][T_HAND],
			g_ui_table[SIDE_DOWN][T_ALLY],
			g_ui_table[SIDE_DOWN][T_SUPPORT],
			g_ui_table[SIDE_UP][T_HERO],
			g_ui_table[SIDE_UP][T_HAND],
			g_ui_table[SIDE_UP][T_ALLY],
			g_ui_table[SIDE_UP][T_SUPPORT],
		};

		self.has_init_tables = true;
		self.show_all_card = false;
		if true == LOCAL_TEST and true == SHOW_ALL then
			self.show_all_card = true;
		elseif true == SHOW_ALL and g_scene:is_stage(STAGE_REPLAY) then
			self.show_all_card = true;
		elseif true == SHOW_ALL and nil ~= g_euser.room_data then
			local list = g_euser.room_data.guest_list or {};
			if #list >= 2 then
				for i = 1, 2 do
					local info = list[i];
					if info.eid < 500 then
						self.show_all_card = true;
					end
				end
			end
		end

	end,

	init_game = function(self, seed, deck1_array, deck2_array, side, timeout, solo_data, robot_data)
		anim.reset_data();
		reset_win_data();
		timeout = timeout or 0;
		if false == self.has_init_tables then
			self:init_tables();
		end

		--[[
		local deck1, deck2;
		local hero1, hero2;
		deck1, hero1 = card_array_list(deck1_array);
		deck2, hero2 = card_array_list(deck2_array);
		--local ddata = side .. ' ' .. hero1 .. ' ' .. hero2;
		--ddata = ddata .. ' ' .. deck1_array .. ' ' .. deck2_array;
		--ddata = ddata .. ' ' .. seed .. ' ' .. timeout;
		--push_playcmd_list(ddata);
		logic_init(hero1, hero2, deck1, deck2, seed, timeout);
		]]--
		if nil ~= deck2_array then
			logic_init_array(deck1_array, deck2_array, seed, side);
		elseif nil ~= solo_data then
			solo_init_array(deck1_array, solo_data.deck2_list, solo_data.type_flag, solo_data.max_ally, solo_data.type_list, solo_data.hero, seed);
		else
			robot_init_array(deck1_array, robot_data.deck2_list, robot_data.hero, seed);
		end
	end,

	init_gate = function(self, seed, deck1_array, gate_list, side)
		anim.reset_data();
		reset_win_data();
		timeout = timeout or 0;
		if false == self.has_init_tables then
			self:init_tables();
		end

		gate_init_array(deck1_array, gate_list, seed);
	end,

	init_side = function(self, my_side)
		g_euser.side = my_side;
		-- In logic, side_up is 1, side_down is 2
		-- so in PVP, if my_side is 1, in order to turn my_side to be down side
		-- will exchange up and side marks values
		if 1 == my_side then
			SIDE_UP       = 2;
			SIDE_DOWN     = 1;

			DOWN_HERO     = 1001; 
			DOWN_HAND     = 1002;
			DOWN_ALLY     = 1003;
			DOWN_SUPPORT  = 1004;
			DOWN_GRAVE    = 1005;
			DOWN_DECK     = 1006;
			DOWN_RES      = 1007;
			UP_HERO       = 2001;
			UP_HAND       = 2002;
			UP_ALLY       = 2003;
			UP_SUPPORT    = 2004;
			UP_GRAVE      = 2005;
			UP_DECK       = 2006;
			UP_RES        = 2007;

		else -- 2 == my_side
			SIDE_UP       = 1;
			SIDE_DOWN     = 2;

			DOWN_HERO     = 2001;
			DOWN_HAND     = 2002;
			DOWN_ALLY     = 2003;
			DOWN_SUPPORT  = 2004;
			DOWN_GRAVE    = 2005;
			DOWN_DECK     = 2006;
			DOWN_RES      = 2007;
			UP_HERO       = 1001;
			UP_HAND       = 1002;
			UP_ALLY       = 1003;
			UP_SUPPORT    = 1004;
			UP_GRAVE      = 1005;
			UP_DECK       = 1006;
			UP_RES        = 1007;
		end
	end,

}

object_card = { -- start
	-- stype: size type
	new = function(self, layer, card, sprite, alist, pos, rotation, scale, stype)
		if nil == card then
			kerror("object_card card is nil");
			return nil;
		end
		scale = scale or 1;
		stype = stype or STYPE_VER_1;
		local data = self:get_data(card, sprite);
		local proxy = {
			layer = layer,
			stype = stype,
			card = card,
			card_sprite = sprite,
			attach_list = alist or {},
			frame = {
				x = pos.x,
				y = pos.y,
				width = 0,
				height = 0,
				scale = scale or data.scale,
				rotation = rotation or data.rotation,
				zorder = data.zorder,
			},
			data = {
				left_top = data.left_top,
				left_bottom = data.left_bottom,
				right_bottom = data.right_bottom,
			},
			status = CARD_FRONT,
		};
			
		setmetatable(proxy, self);
		return proxy;
	end,

	sample = function(self, layer, pos, rotation, scale, stype)
		local card = {
			id = 1,
			ctype = HERO,
			name = 'Kel测试ton',
			cost = 10,
			power = 12,
			energy = 31,
			hp = 29,
			skill_desc = 'this is abcd\n这是中文啊',
			is_test = true;
		};
		return self:new(layer, card, nil, nil, pos, rotation, scale, stype);
	end,

	copy = function(self, layer, stype, pos, scale, rotation)
		local card = clone(self.card);
		local frame = self.frame;
		local pos = pos or ccp(frame.x, frame.y);
		local rotation = rotation or frame.rotation;
		local scale = scale or frame.scale;
		local copy = object_card:new(layer,card,nil,nil,pos,rotation,scale,stype);
		return copy;
	end,

	set_data = function(self, lt, lb, rb)
		if nil ~= lt then
			self.data.left_top = lt;
		end
		if nil ~= lb then
			self.data.left_bottom = lb;
		end
		if nil ~= rb then
			self.data.right_bottom = rb;
		end
	end,

	get_data = function(self, card, sprite)
		local data = {};
		local label_lt = nil; -- left_top
		local label_lb = nil; -- left_down
		local label_rb = nil; -- right_down
		if nil ~= sprite then
			local label = sprite:getChildByTag(TAG_COST);
			tolua.cast(label, "cc.Label");
			label_lt = label;
			label = sprite:getChildByTag(TAG_POWER);
			tolua.cast(label, "cc.Label");
			label_lb = label;
			label = sprite:getChildByTag(TAG_HP);
			tolua.cast(label, "cc.Label");
			label_rb = label;

			data.zorder = sprite:getLocalZOrder();
			data.scale = sprite:getScale();
			data.rotation = sprite:getRotation();
		else
			data.zorder = 0;
			data.scale = 1;
			data.rotation = 0;
		end
		if nil ~= label_lt then
			data.left_top = tonumber(label_lt:getString());
		else
			if card.ctype ~= HERO then
				data.left_top = card.cost;
			end
		end
		if ABILITY == card.ctype or ATTACH == card.ctype 
				or SUPPORT == card.ctype or ARTIFACT == card.ctype then
			return data;
		end
		if nil ~= label_lb then
			data.left_bottom = tonumber(label_lb:getString());
		else
			if card.ctype == HERO then
				data.left_bottom = card.energy;
			else
				data.left_bottom = card.power;
			end
		end
		if nil ~= label_rb then
			data.right_bottom = tonumber(label_rb:getString());
		else
			data.right_bottom = card.hp;
		end
		return data;
	end,

	-- deprecated , use local function instead, see in create_sprite
	cb_clean = function(event)
		if "enter" == event then
		elseif "exit" == event then
			--print('DEBUG cb_clean');
		end
	end,

	clean_sprite = function(self)
		local sprite = g_sprite_cache[self.card];
		if nil == sprite then
			return;
		end
		sprite:removeAllChildrenWithCleanup(true);
	end,

	remove_sprite = function(self)
		local sprite = self.card_sprite;
		self.card_sprite = nil;
		g_sprite_cache[self.card] = nil;
		if nil == sprite then
			return;
		end
		sprite:removeFromParentAndCleanup(true);
	end,

	get_ver_str = function(self, stype)
		if STYPE_VER_2 == stype then
			return '_2';
		else
			return '';
		end
	end,

	get_bg = function(self, status, stype)
		stype = stype or self.stype;
		local card = self.card;
		local str = self:get_ver_str(stype);
		local filename = nil;
		if stype == STYPE_VER_2 then
			if CARD_COVER == status then
				filename = 'bg_card_cover.png';
			elseif CARD_GRAVE == status then
				filename = 'frame_pic.png';
			elseif CARD_HERO == status then
				filename = 'bg_25.png';
			elseif CARD_ALLY == status then
				filename = 'bg_card_ally.png';
			--elseif CARD_ATTACH == status then
			--	filename = 'bg_card_magic.png';
			else -- CARD_FRONT == status
				if ARMOR == card.ctype then
					filename = 'bg_card_armor.png';
				elseif HERO == card.ctype then
					filename = 'bg_card_hero.png';
				elseif ALLY == card.ctype then
					filename = 'bg_card_ally.png';
				elseif WEAPON == card.ctype then
					filename = 'bg_card_weapon.png';
				else --if ABILITY == card.ctype or ATTACH == card.ctype or SUPPORT == card.ctype or ARTIFACT == card.ctype then
					filename = 'bg_card_magic.png';
				end
			end
		else
			if CARD_FRONT == status then
				filename = 'c_bg' .. str .. '.png';
			elseif CARD_COVER == status then
				filename = 'cover' .. str .. '.png';
			elseif CARD_GRAVE == status then
				filename = 'frame_pic.png';
			elseif CARD_ALLY == status then
				filename = 'c_bg' .. str .. '.png';
			elseif CARD_SUPPORT == status then
				filename = 'c_bg' .. str .. '.png';
			elseif CARD_HERO == status then
				filename = 'bg_25.png';
			elseif CARD_ATTACH == status then
				filename = 'c_bg' .. str .. '.png';
			end
		end
		return filename;
	end,

	create_sprite = function(self)
		local status = self.status;
		local filename = self:get_bg(status);
		if nil == filename then
			return nil;
		end
		local path = util.get_path(filename);
		--local sprite = self.card_sprite;
		local sprite = g_sprite_cache[self.card];
		if nil == sprite then
			sprite = EvilSprite:create(path);
			local function cb_clean(event)
				local card = self.card;
				if "enter" == event then
					--print('DEBUG cb_enter: ', card.name, cindex(card), card.id);
					--self.card_sprite = sprite;
					--g_sprite_cache[card] = self.card_sprite;
				elseif "exit" == event then
					--[[
					if true ~= card.is_test then
					print('DEBUG cb_clean: ', card.name, cindex(card), card.id);
					end
					]]--
					--self.card_sprite = nil;
					-- don't set g_sprite_cache here, card is no use
					--g_sprite_cache[card] = nil;
				end
			end
			--util.node_register(sprite, self.cb_clean);
			util.node_register(sprite, cb_clean);
			self.layer:addChild(sprite, ZORDER_CARD);

			--
			local frame = self.frame;
			sprite:setPosition(cc.p(frame.x, frame.y));
			sprite:setAnchorPoint(ANCHOR_CENTER_CENTER);
			sprite:setRotation(frame.rotation);
			sprite:setScale(frame.scale);
			self.frame.width = sprite:getContentSize().width * frame.scale;
			self.frame.height = sprite:getContentSize().height * frame.scale;
			--

			-- TODO maybe cache the object will be better
			g_sprite_cache[self.card] = sprite;
		else
			self:clean_sprite();
			local tc = CCTextureCache:sharedTextureCache();
			local texture = tc:addImage(path);
			local size = texture:getContentSize();
			sprite:setTexture(texture);
			--sprite:setContentSize(size);
			sprite:setTextureRect(cc.rect(0, 0, size.width, size.height));
		end

		self.card_sprite = sprite;
		return sprite;
	end,

	init_front_info_ver_1 = function(self, sprite)
		local card = self.card;
		local pos, size;
		local width = sprite:getContentSize().width;
		local height = sprite:getContentSize().height;
		local hwidth = math.floor(width / 2);
		local hheight = math.floor(height / 2);
		local label, str, fsize;

		local filename = 'card' .. card.id .. '.png';
		local path, is_exist = util.get_path(filename, 'card0.png');
		if true ~= is_exist then
			--net_send_dres(filename);
		end
		local zorder = ZORDER_CARD_IMAGE;
		pos = ccp(hwidth, height-20);
		local pic = util.add_sprite(sprite, path,pos,ANCHOR_CENTER_UP,zorder);

		-- description
		fsize = 20;
		str = card.skill_desc;
		pos = cc.p(hwidth, 120);
		size = cc.size(230, 120);
		label = util.add_labelttf(sprite, str, nil, fsize, pos, util.c4b_black, ANCHOR_CENTER_CENTER, nil, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
		label:setTag(TAG_DESC);

		-- card name
		if true == DEBUG_MODE then
			str = card.name .. '(' .. card.id .. ')';
		else
			str = card.name;
		end
		pos = ccp(hwidth, height/2-46);
		label = util.add_labelttf(sprite, str, nil, fsize, pos, util.c4b_white, ANCHOR_CENTER_CENTER, nil, cc.size(width, 26), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
		label:setTag(TAG_NAME); -- use for detect is front or back

		str = '[' .. ctype_to_str(card.ctype) .. ']' .. job_name(card.job);
		if true == card.unique then
			str = str .. '[唯一]';
		end
		pos = ccp(width/2, 20);
		label = util.add_labelttf(sprite, str, nil, fsize, pos, util.c4b_white, ANCHOR_CENTER_DOWN, nil, cc.size(width, 26), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);

		local num_star = card.star or 0;
		path = util.get_path('star.png');
		pos = ccp(width - 25, height - 40);
		for i = 1, num_star do
			local star = util.add_sprite(sprite, path,pos,ANCHOR_RIGHT_UP, 1);
			pos.y = pos.y - star:getContentSize().height;
		end

		local data = self.data;
		local fontpath = util.get_path(FNT_CARD);
		
		str = data.left_top;
		local fname;
		if nil ~= str then
			path = util.get_path('icon_left_up.png');
			pos = ccp(-24, height+12);
			util.add_sprite(sprite, path, pos, ANCHOR_LEFT_UP);
			
			pos = ccp(18, height-26);
			label=util.add_labelbmf(sprite,str,fontpath,pos,ANCHOR_CENTER_CENTER);
			label:setTag(TAG_COST);
		end

		str = data.left_bottom;
		if nil ~= str then
			if ARMOR == card.ctype then
				fname = 'icon_armor.png';
				pos = ccp(-30, -12);
			elseif HERO == card.ctype then
				fname = 'icon_energy.png';
				pos = ccp(-30, -12);
			else
				fname = 'icon_attack.png';
				pos = ccp(-46, -18);
			end
			path = util.get_path(fname);
			util.add_sprite(sprite, path, pos, ANCHOR_LEFT_DOWN);

			if ARMOR == card.ctype then
				pos = ccp(14, 30);
			elseif HERO == card.ctype then
				pos = ccp(14, 30);
			else
				pos = ccp(14, 30);
			end
			label=util.add_labelbmf(sprite,str,fontpath,pos,ANCHOR_CENTER_CENTER);
			label:setTag(TAG_POWER);
		end

		str = data.right_bottom;
		if nil ~= str then
			if ARMOR == card.ctype or WEAPON == card.ctype then
				fname = 'icon_durability.png';
			else
				fname = 'icon_hp.png';
			end
			path = util.get_path(fname);
			pos = ccp(width+21, -18);
			util.add_sprite(sprite, path, pos, ANCHOR_RIGHT_DOWN);

			if ARMOR == card.ctype or WEAPON == card.ctype then
				pos = ccp(width-16, 28);
			else
				pos = ccp(width-16, 28);
			end
			label=util.add_labelbmf(sprite,str,fontpath,pos,ANCHOR_CENTER_CENTER);
			label:setTag(TAG_HP);
		end
	end,

	init_front_info_ver_2 = function(self, sprite)
		local card = self.card;
		local pos, size;
		local width = sprite:getContentSize().width;
		local height = sprite:getContentSize().height;
		local hwidth = math.floor(width / 2);
		local hheight = math.floor(height / 2);
		local label, str, fsize;

		local filename = 'card' .. card.id .. '.png';
		local path, is_exist = util.get_path(filename, 'card0.png');
		local mask_path = util.get_path('bg_card_mask.png');
		if true ~= is_exist then
			--net_send_dres(filename);
		end
		local zorder = ZORDER_CARD_IMAGE;
		pos = ccp(hwidth, height);
		local pic = util.add_mask_sprite(sprite, path, mask_path, pos, ANCHOR_CENTER_UP, zorder);
		pic:setScale(0.4);

		-- card name
		str = card.name;
		pos = ccp(hwidth, hheight-30);
		--label = util.add_labelttf(sprite, str, nil, 20, pos, util.c_white, ANCHOR_CENTER_CENTER, nil, cc.size(width, 20), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
		label = util.add_labelsys(sprite, str, nil, 11, pos, util.c_white, ANCHOR_CENTER_CENTER, nil, cc.size(width, 20), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
		label:setTag(TAG_NAME); -- use for detect is front or back

		local num_star = card.star or 0;
		path = util.get_path('star_2.png');
		pos = ccp(width - 10, height - 20);
		for i = 1, num_star do
			local star = util.add_sprite(sprite, path,pos,ANCHOR_RIGHT_UP, 1);
			pos.y = pos.y - star:getContentSize().height;
		end

		local data = self.data;
		local fontpath = util.get_path(FNT_CARD_2);
		
		str = data.left_top;
		local fname;
		if nil ~= str then
			pos = ccp(9, height-18);
			label=util.add_labelbmf(sprite,str,fontpath,pos,ANCHOR_CENTER_CENTER);
			label:setTag(TAG_COST);
		end

		str = data.left_bottom;
		if nil ~= str then
			if ARMOR == card.ctype then
				pos = ccp(12, 6);
			elseif HERO == card.ctype then
				pos = ccp(12, 6);
			else
				pos = ccp(12, 6);
			end
			label=util.add_labelbmf(sprite,str,fontpath,pos,ANCHOR_CENTER_CENTER);
			label:setTag(TAG_POWER);
		end

		str = data.right_bottom;
		if nil ~= str then
			if ARMOR == card.ctype or WEAPON == card.ctype then
				pos = ccp(width-9, 6);
			else
				pos = ccp(width-9, 6);
			end
			label=util.add_labelbmf(sprite,str,fontpath,pos,ANCHOR_CENTER_CENTER);
			label:setTag(TAG_HP);
		end
	end,

	init_front_info = function(self, sprite, stype)
		stype = stype or self.stype;
		if STYPE_VER_2 == stype then
			self:init_front_info_ver_2(sprite);
		else
			self:init_front_info_ver_1(sprite);
		end
	end,

	init_hero_info = function(self, sprite)
		local card = self.card;
		local path, filename, pos;
		--[[
		filename = 'card' .. card.id .. '.png';
		local is_exist, pic;
		fullpath, is_exist = util.get_fullpath(F_PIC, filename, 'card0.png');
		if true ~= is_exist then
			--net_send_dres(filename);
		end
		]]--
		filename = 'hero_' .. card.id .. '.png';
		path, is_exist = util.get_path(filename, 'hero_0.png');
		--[[ -- TODO download image bug
		if true ~= is_exist then
			net_send_dres(filename);
		end
		]]--
		local zorder = ZORDER_CARD_IMAGE;
		--local scale = sprite:getScale();
		local size = sprite:getContentSize();
		--[[
		pos = ccp(size.width/2, 0);
		print('fullpath: ', fullpath);
		pic = util.add_sprite(sprite,fullpath,pos,ANCHOR_CENTER_DOWN,zorder);
		]]--
		pos = ccp(size.width/2, size.height/2);
		--local mask_path = util.get_fullpath(F_IMAGE, 'hero_mask_1.png');
		local mask_path = util.get_path('bg_34.png');
		pic = util.add_mask_sprite(sprite, path, mask_path, pos, ANCHOR_CENTER_CENTER, zorder);
		--pic:setScale(scale);

		local data = self.data;
		local fontpath = util.get_fullpath(F_FONT, FNT_CARD);
		local str = data.left_bottom;
		local label;
		if nil ~= str then
			pos = ccp(103-23, 30+10+15);
			label=util.add_labelbmf(sprite,str,fontpath,pos,ANCHOR_CENTER_CENTER);
			label:setTag(TAG_POWER);
			--label:setScale(0.5);
		end

		str = data.right_bottom;
		if nil ~= str then
			pos = ccp(size.width-104+23, 30+10+15);
			label=util.add_labelbmf(sprite,str,fontpath,pos,ANCHOR_CENTER_CENTER);
			label:setTag(TAG_HP);
			--label:setScale(0.5);
		end
	end,

	get_front = function(self)
		self.status = CARD_FRONT;
		local sprite = self:create_sprite();
		if nil == sprite then
			return;
		end
		self:init_front_info(sprite);

		-- create attach card
		local attach_list = { cscale = 1 };
		local alist = self.card.attach_list;
		if alist ~= nil and #alist > 0 then
			local a_index = 1;
			local v_index = 1;
			local psize = sprite:getContentSize();
			local size = CARD_SIZE_2;
			for i = 1, #alist do
				-- attach card
				local ac = alist[i]; 
				local pos = ccp(psize.width/2, psize.height/2);
				if ac.id > 1000 then -- virtual card
					local ainfo = add_ui_card(sprite, attach_list, pos, 0, ac);
					ainfo:reset_zorder(v_index);
					v_index = v_index + 1;
				else -- not virtual card
					pos.y = pos.y + a_index * math.floor(size.height / 7);
					local ainfo = add_ui_card(sprite, attach_list, pos, 0, ac);
					ainfo:reset_zorder(ZORDER_CARD_ATTACH-a_index);
					a_index = a_index + 1;
				end
			end
		end
		self.attach_list = attach_list;

		return sprite;
	end,

	get_cover = function(self)
		self.status = CARD_COVER;
		local sprite = self:create_sprite();
		if nil == sprite then
			return;
		end
		return sprite;
	end,

	get_grave = function(self)
		self.status = CARD_GRAVE;
		local sprite = self:create_sprite();
		if nil == sprite then
			return;
		end
		local card = self.card;
		local fullpath, pos;
		local filename = 'card' .. card.id .. '.png';
		local is_exist;
		fullpath, is_exist = util.get_fullpath(F_PIC, filename, 'card0.png');
		if true ~= is_exist then
			--net_send_dres(filename);
		end
		local zorder = ZORDER_CARD_IMAGE;
		pos = ccp(0, 0);
		local pic = util.add_sprite(sprite, fullpath,pos,ANCHOR_LEFT_DOWN,zorder);
		return sprite;
	end,

	get_ally = function(self)
		self.status = CARD_ALLY;
		local sprite = self:create_sprite();
		if nil == sprite then
			return;
		end
		self:init_front_info(sprite);
		return sprite;
	end,

	get_support = function(self)
		self.status = CARD_SUPPORT;
		local sprite = self:create_sprite();
		if nil == sprite then
			return;
		end
		self:init_front_info(sprite);
		return sprite;
	end,

	get_hero = function(self)
		self.status = CARD_HERO;
		local sprite = self:create_sprite();
		if nil == sprite then
			return;
		end
		self:init_hero_info(sprite);

		-- create attach card
		local attach_list = { cscale = 0.2 };
		local alist = self.card.attach_list;
		if alist ~= nil and #alist > 0 then
			local a_index = 1;
			local v_index = 1;
			local size = sprite:getContentSize();
			for i = 1, #alist do
				-- attach card
				local ac = alist[i]; 
				local pos = ccp(size.width/2, size.height/2);
				local csize = CARD_SIZE_2;
				local size = { width = csize.width, height = csize.height };
				if ac.id > 1000 then -- virtual card
					local ainfo = add_ui_card(sprite, attach_list, pos, 0, ac);
					ainfo:reset_zorder(v_index);
					v_index = v_index + 1;
				else -- not virtual card
					pos.y = pos.y + math.floor(size.height / 7);
					----
					pos.x = pos.x + size.width/3 + (a_index-1)*20;
					local rotation = 15 + (a_index-1)*10;
					--[[
					local m_index = #alist / 2 + 1;
					local r_gap = 40 / m_index;
					local rotation = (a_index - m_index) * r_gap;
					]]--
					----
					local ainfo = add_ui_card(sprite,attach_list,pos,rotation,ac);
					ainfo:reset_zorder(ZORDER_CARD_ATTACH-a_index);
					a_index = a_index + 1;
				end
			end
		end
		self.attach_list = attach_list;
		return sprite;
	end,

	get_attach = function(self)
		self.status = CARD_ATTACH;
		local sprite = self:create_sprite();
		if nil == sprite then
			return;
		end
		self:init_front_info(sprite);
		return sprite;
	end,

	get_virtual = function(self)
		self.status = CARD_VIRTUAL;

		local sprite = nil;
		local card = self.card;
		local layer = self.layer;
		if nil == card or nil == layer then
			return sprite;
		end
		------
		local vtype = card.vtype or 0;
		local pos = cc.p(self.frame.x, self.frame.y);
		local eff_pos = cc.p(0, 0);
		local eff_scale = 1;
		local size = (self.stype==STYPE_VER_2) and CARD_SIZE_2 or CARD_SIZE;
		local eff_id = 0;
		if 1 == vtype then -- ablaze
			eff_id = 1;
			eff_pos.x = eff_pos.x + size.width/2-10;
			eff_pos.y = eff_pos.y + size.height/2-10;
			eff_scale = 0.4;
		elseif 2 == vtype or 6 == vtype then -- cobweb
			eff_id = 4;
			eff_pos.x = eff_pos.x + size.width/2-10;
			eff_pos.y = eff_pos.y + size.height/2-10;
			eff_scale = 0.4;
		elseif 3 == vtype then -- frozen
			eff_id = 3;
		elseif 4 == vtype then -- poison
			eff_id = 2;
			eff_pos.x = eff_pos.x + size.width/2-10;
			eff_pos.y = eff_pos.y + size.height/2-10;
			eff_scale = 0.4;
		end
		local sprite;
		sprite = cc.Node:create();
		sprite:setPosition(pos);
		sprite:setRotation(self.frame.rotation);
		layer:addChild(sprite, ZORDER_CARD);
		if 0 ~= eff_id then
			local s = add_status_eff_sprite(sprite,eff_id,eff_pos,ANCHOR_CENTER_CENTER, eff_scale, 1);
			s:setTag(TAG_STATUS_SPRITE);
		end
		self.card_sprite = sprite;
		g_sprite_cache[self.card] = self.card_sprite;
		--create_virtual_particle(sprite, vtype);
		update_attachment_timer(sprite, self.card);
		------------------------
		--[[
		local eff_name = nil;
		if 1 == vtype then
			eff_name = 'ablaze';
		elseif 2 == vtype then
			eff_name = 'cobweb';
		elseif 3 == vtype then
			eff_name = 'frozen';
		elseif 4 == vtype then
			eff_name = 'poison';
		elseif 5 == vtype then
			eff_name = 'stealth';
		end
		local pos = ccp(self.frame.x, self.frame.y);
		local sprite = nil;
		if nil ~= eff_name then
			local filename = 'v_' .. eff_name .. '_1.png';
			local path = util.get_path(filename);
			local cid = cindex(self.card);
			local mask_path;
			local tt = index_table_num(cindex(self.card));
			if tt == T_HERO then
				mask_path = util.get_path('v_mask_hero.png');
			else
				mask_path = util.get_path('v_mask_card.png');
			end
			sprite = util.add_mask_sprite(layer, path, mask_path, pos, ANCHOR_CENTER_CENTER, 1);
		else
			--print('------ cid: ', self.card.id);
			if 6 == vtype then
			--if 1021 == self.card.id then
				local path = util.get_path('status_no_attack.png');
				sprite = util.add_sprite(layer, path, cc.p(pos.x, pos.y), ANCHOR_CENTER_CENTER, 1);
			else
				sprite = cc.Node:create();
				sprite:setPosition(pos);
				layer:addChild(sprite, 1);
			end
		end
		--sprite:setBlendFunc(gl.DST_COLOR, gl.SRC_COLOR);
		--local sprite = util.add_sprite(layer, path, pos, ANCHOR_CENTER_CENTER, 1);
		sprite:setRotation(self.frame.rotation);
		--sprite:setScale(self.frame.scale);

		self.card_sprite = sprite;
		g_sprite_cache[self.card] = self.card_sprite;
		
		create_virtual_particle(sprite, vtype);

		update_attachment_timer(sprite, self.card);
		]]--
		return sprite;
	end,

	get_grave_sprite = function(self, layer, pos, rotation, scale)
		local sprite = nil;
		local stype = STYPE_VER_1;
		local filename = self:get_bg(CARD_FRONT, stype);
		if nil == filename then
			return sprite;
		end
		--local fullpath = util.get_fullpath(F_IMAGE, filename);
		--sprite = EvilSprite:create(fullpath);
		local path = util.get_path(filename);
		sprite = EvilSprite:create(path);
		local function cb_clean(event)
			local card = self.card;
			if "enter" == event then
				--self.card_sprite = sprite;
				--g_sprite_cache[card] = self.card_sprite;
			elseif "exit" == event then
				--[[
				if true ~= card.is_test then
				--print('DEBUG cb_clean: ', card.name, cindex(card), card.id);
				end
				]]--
				--self.card_sprite = nil;
				-- don't set g_sprite_cache here, card is no use
				--g_sprite_cache[card] = nil;
			end
		end
		--util.node_register(sprite, self.cb_clean);
		util.node_register(sprite, cb_clean);
		layer:addChild(sprite, ZORDER_CARD);

		sprite:setPosition(pos);
		sprite:setAnchorPoint(ANCHOR_CENTER_CENTER);
		sprite:setRotation(rotation);
		sprite:setScale(scale);
		self:init_front_info(sprite, stype);

		return sprite;
	end,

	get_show_sprite = function(self, layer, pos, rotation, scale)
		local sprite = nil;
		local stype = STYPE_VER_1;
		local filename = self:get_bg(CARD_FRONT, stype);
		if nil == filename then
			return sprite;
		end
		local fullpath = util.get_fullpath(F_IMAGE, filename);
		sprite = EvilSprite:create(fullpath);
		util.node_register(sprite, self.cb_clean);
		layer:addChild(sprite, ZORDER_CARD);

		sprite:setPosition(pos);
		sprite:setAnchorPoint(ANCHOR_CENTER_CENTER);
		sprite:setRotation(rotation);
		sprite:setScale(scale);
		self:init_front_info(sprite, stype);

		return sprite;
	end,

	get_show_sprite_hero = function(self, layer, pos, rotation, scale)
		local sprite = nil;
		local stype = STYPE_VER_1;
		local filename = self:get_bg(CARD_HERO, stype);
		if nil == filename then
			return sprite;
		end
		local fullpath = util.get_fullpath(F_IMAGE, filename);
		sprite = EvilSprite:create(fullpath);
		local function cb_clean(event)
			local card = self.card;
			if "enter" == event then
			elseif "exit" == event then
			end
		end
		util.node_register(sprite, cb_clean);
		layer:addChild(sprite, ZORDER_CARD);

		sprite:setPosition(pos);
		sprite:setAnchorPoint(ANCHOR_CENTER_CENTER);
		sprite:setRotation(rotation);
		sprite:setScale(scale);
		self:init_hero_info(sprite, stype);

		return sprite;
	end,

	get_action_sprite = function(self, layer, pos, rotation, scale)
		local sprite = nil;
		local stype = STYPE_VER_1;
		local filename = self:get_bg(CARD_FRONT, stype);
		if nil == filename then
			return sprite;
		end
		local fullpath = util.get_fullpath(F_IMAGE, filename);
		sprite = EvilSprite:create(fullpath);
		util.node_register(sprite, self.cb_clean);
		layer:addChild(sprite, ZORDER_CARD);

		sprite:setPosition(pos);
		sprite:setAnchorPoint(ANCHOR_CENTER_CENTER);
		sprite:setRotation(rotation);
		sprite:setScale(scale);
		self:init_front_info(sprite, stype);

		return sprite;
	end,

	change_status = function(self, nstatus)
		local sprite = g_sprite_cache[self.card];
		if nstatus == self.status and nil ~= sprite then
			return self.card_sprite;
		elseif nstatus == CARD_FRONT then
			sprite = self:get_front();
		elseif nstatus == CARD_COVER then
			sprite = self:get_cover();
		elseif nstatus == CARD_GRAVE then
			sprite = self:get_grave();
		elseif nstatus == CARD_ALLY then
			sprite = self:get_ally();
		elseif nstatus == CARD_SUPPORT then
			sprite = self:get_support();
		elseif nstatus == CARD_HERO then
			sprite = self:get_hero();
		elseif nstatus == CARD_ATTACH then
			sprite = self:get_attach();
		elseif nstatus == CARD_VIRTUAL then
			sprite = self:get_virtual();
		end
		return sprite;
	end,

	flip_to_front = function(self)
		--local sprite = self.card_sprite;
		local sprite = self:get_sprite();
		if nil == sprite then
			return;
		end
		--play_turn_card();
		self.status = CARD_FRONT;
		local filename = self:get_bg(self.status);
		local fullpath = util.get_fullpath(F_IMAGE, filename);
		self:clean_sprite();
		local tc = cc.Director:getInstance():getTextureCache();
		local texture = tc:addImage(fullpath);
		local size = texture:getContentSize();
		sprite:setTexture(texture);
		sprite:setTextureRect(cc.rect(0, 0, size.width, size.height));
		self:init_front_info(sprite);
	end,

	flip_to_cover = function(self)
		--local sprite = self.card_sprite;
		local sprite = self:get_sprite();
		if nil == sprite then
			print('DEBUG flip_to_cover sprite is nil');
			return;
		end
		--play_turn_card();
		self.status = CARD_COVER;
		local filename = self:get_bg(self.status);
		local fullpath = util.get_fullpath(F_IMAGE, filename);
		self:clean_sprite();
		local tc = cc.Director:getInstance():getTextureCache();
		local texture = tc:addImage(fullpath);
		local size = texture:getContentSize();
		sprite:setTexture(texture);
		sprite:setTextureRect(cc.rect(0, 0, size.width, size.height));
	end,

	reset_zorder = function(self, nzorder)
		local layer = self.layer;
		local sprite = self.card_sprite;
		if nil == layer or nil == nzorder or nil == sprite then
			return;
		end
		layer:reorderChild(sprite, nzorder);
		self.frame.zorder = nzorder;
	end,

	set_sprite = function(self, status)
		local sprite = self:change_status(status);
		return sprite;
	end,

	get_sprite = function(self, get_sprite_directly)
		if true == get_sprite_directly then
			return self.card_sprite;
		end
		local sprite = self:change_status(self.status);
		--local sprite = self.card_sprite;
		return sprite;
	end,

	get_card_attach_list = function(self)
		local list = {};
		local alist = self.attach_list or {};
		for i = 1, #alist do
			local obj = alist[i];
			if obj.card.id < 1000 then
				table.insert(list, obj);
			end
		end
		return list;
	end,

	get_virtual_attach_list = function(self)
		local list = {};
		local alist = self.attach_list or {};
		for i = 1, #alist do
			local obj = alist[i];
			if obj.card.id >= 1000 then
				table.insert(list, obj);
			end
		end
		return list;
	end,

	change_grave = function(self, pos, scale)
		local sprite = self:change_status(CARD_GRAVE);
		if nil == sprite then
			return sprite;
		end
		sprite:setPosition(pos);
		sprite:setScale(scale);
		return sprite;
	end,

	-- gframe --> grave_frame
	get_grave_pos = function(self, gframe, pindex)
		local height = gframe.pic_height;
		if nil == height then
			kerror("get_grave_pos pic_height is nil");
			return nil;
		end
		local gapy = height + hfix(15);
		local pos = ccp(gframe.x, gframe.y-gapy*(pindex-1));
		return pos;
	end,

	reset = function(self)
		if nil == self then
			return;
		end
		local card = self.card;
		local sprite = self.card_sprite;
		if nil == sprite then
			kdebug("object_card reset sprite[%s][%d] is nil", card.name, cindex(card));
			return;
		end
		local frame = self.frame;
		local pos = ccp(frame.x, frame.y);
		local scale = frame.scale;
		local rotation = frame.rotation;
		sprite:setPosition(pos);
		sprite:setScale(scale);
		sprite:setRotation(rotation);
	end,

	__index = function(t, k)
		if k == 'sprite' then
			return object_card.get_sprite(t);
		end
		if k == 'front' then
			return object_card.get_front(t);
		end
		if k == 'cover' then
			return object_card.get_cover(t);
		end
		if k == 'grave' then
			return object_card.get_grave(t);
		end
		if k == 'ally' then
			return object_card.get_ally(t);
		end
		if k == 'support' then
			return object_card.get_support(t);
		end
		if k == 'hero' then
			return object_card.get_hero(t);
		end
		if k == 'attach' then
			return object_card.get_attach(t);
		end
		if k == 'virutal' then
			return object_card.get_virtual(t);
		end
		if k == 'card_attach_list' then
			return object_card.get_card_attach_list(t);
		end
		if k == 'virtual_attach_list' then
			return object_card.get_virtual_attach_list(t);
		end

		local v = rawget(object_card, k);
		return v;
	end,

	__newindex = function(t, k, v)
		rawset(t, k, v);
	end,
} -- object_card end

object_uitable = {
	new = function(self, ltype)
		local proxy = {
			x = 0, y = 0, 
			width = 0, height = 0, 
			ltype = ltype, cscale = 1
		};
		setmetatable(proxy, self);
		return proxy;
	end,

	__index = function(t, k)
		--[[
		if k == 'xxx' then
			-- do something
		end
		]]--

		local v = rawget(object_uitable, k);
		return v;
	end,
}

g_scene = { -- g_scene start
	layer_list = {},
	is_connected = false,
	this_stage = nil,
	last_stage = nil,
	-- in some case, use getRunningScene will get the old one while changing scene
	-- so set thie_scene
	this_scene = nil,

	connect_to_net = function(self)
		local ret = LayerSocket:initSocket(IP_ADDR);
		if ret <= 0 then
			--local err = string.format("initSocket ret[%d], ip[%s]",ret,IP_ADDR);
			local err = string.format("服务器维护中,请稍后再试...");
			net_show_err(nil, err);
			return ret;
		end
		self.is_connected = true;
		return 1;
	end,

	close_connect = function(self)
		if false == self.is_connected then
			return;
		end
		net_send('q');
		self.is_connected = false;
	end,

	is_online = function(self)
		return self.is_connected;
	end,

	is_stage = function(self, stage)
		if self.this_stage == stage then
			return true;
		end
		return false;
	end,

	is_battle = function(self)
		if g_scene:is_stage(STAGE_PVP) or g_scene:is_stage(STAGE_PVE) then
			return true;
		end
		return false;
	end,

	add_layer_list = function(self, name)
		self.layer_list = self.layer_list or {};
		name = name or '???';
		name = name .. '\n';
		table.insert(self.layer_list, name);
	end,

	delete_layer_list = function(self, name)
		self.layer_list = self.layer_list or {};
		name = name .. '\n';
		local index = 0;
		for i = 1, #self.layer_list do
			if name == self.layer_list[i] then
				index = i;
				break;
			end
		end
		if 0 == index then
			return;
		end
		table.remove(self.layer_list, index);
	end,

	get_layer_list = function(self)
		self.layer_list = self.layer_list or {};
		return self.layer_list;
	end,

	reset_layer_list = function(self)
		self.layer_list = {};	
	end,

	is_in_battle = function(self, stage)
		stage = stage or self.this_stage;
		if stage == STAGE_PVE or stage == STAGE_PVP or stage == STAGE_REPLAY or stage == STAGE_PVG then
			return true;
		end
		return false;
	end,

	change_scene = function(self, new_scene, new_stage, layer_list)
		local director = cc.Director:getInstance();
		if nil ~= director:getRunningScene() then
			director:replaceScene(new_scene);
		else
			director:runWithScene(new_scene);
		end

		util.resume_bgmusic();
		if new_stage == STAGE_LOGIN or self:is_in_battle(self.this_stage) then
			local path = util.get_fullpath(F_MUSIC, 'main.mp3');
			util.preload_music(path);
			util.play_music(path);
		elseif self:is_in_battle(new_stage) then
			local path = util.get_fullpath(F_MUSIC, 'battle.mp3');
			util.preload_music(path);
			util.play_music(path);
		end

		self.last_stage = self.this_stage;
		self.this_stage = new_stage;
		self.this_scene = new_scene;

		self:reset_layer_list();
		for i = 1, #(layer_list or {}) do
			local name = layer_list[i];
			self:add_layer_list(name);
		end
	end,

	add_layer = function(self, zorder, layer, name, is_show_anim)
		local director = cc.Director:getInstance();
		--local scene = director:getRunningScene();
		local scene = self.this_scene or director:getRunningScene();
		if nil == scene then
			kerror("current_scene is nil");
			return;
		end
		scene:addChild(layer, zorder);
		self:add_layer_list(name);
		if true == is_show_anim then
			show_pop_anim(layer);
		end
	end,

	remove_layer = function(self, layer, name)
		if nil ~= layer then
			layer:removeFromParentAndCleanup(true);
			self:delete_layer_list(name);
		end
	end,

	login = function(self)
		local stage = STAGE_LOGIN;
		local scene = cc.Scene:create();
		local layer_list = {};
		local layer, name;

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_login:create();
		scene:addChild(layer, ZORDER_LAYER_LOGIN);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);

		self:close_connect();
	end,

	role = function(self)
		local stage = STAGE_ROLE;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {}

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_role:create();
		scene:addChild(layer, ZORDER_LAYER_ROLE);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);

		local cmd = 'ljob';
		net_send(cmd);
	end,

	map = function(self)
		data_handler:cleanup();
		local stage = STAGE_MAP;
		local scene = cc.Scene:create();
		local layer_list = {};
		local layer, name;

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_map:create();
		scene:addChild(layer, ZORDER_LAYER_MAP);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_bottombar:create();
		scene:addChild(layer, ZORDER_LAYER_BOTTOMBAR);
		table.insert(layer_list, name);

		layer, name = layer_chat:create();
		scene:addChild(layer, ZORDER_LAYER_CHAT);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);

		-- see net_mreward, net_course
		local show_tutor = false;
		if false == show_tutor then
			show_tutor = show_tutor_gate();
		end
		if false == show_tutor then
			show_tutor = show_tutor_mission();
		end
		net_send('course', true);
	end,

	testlua = function(self)
		local stage = STAGE_TESTLUA;
		local scene = cc.Scene:create();
		local layer_list = {};
		local layer, name;

		layer, name = layer_testlua:create();
		scene:addChild(layer, ZORDER_LAYER_TESTLUA);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);
	end,

	pve_do_scene = function(self, side)
		local stage = STAGE_PVE;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_table:create();
		scene:addChild(layer, ZORDER_LAYER_TABLE);
		table.insert(layer_list, name);

		layer, name = layer_card:create();
		scene:addChild(layer, ZORDER_LAYER_CARD);
		table.insert(layer_list, name);

		layer, name = layer_menu:create(stage);
		scene:addChild(layer, ZORDER_LAYER_MENU);
		table.insert(layer_list, name);
		
		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);

	end,

	pve = function(self, side, seed, deck1_array, deck2_array, is_replay)
		--[[
		if true == USE_FRAME then
			add_frame_cache(GUI_MATCH);
		end
		]]--
		SHOW_ALL = false;
		data_handler:cleanup();
		data_handler:init_side(side); 
		if LOCAL_TEST == true then
			if false == data_handler.has_init_tables then
				data_handler:init_tables();
			end
			local info = {
				side_up = {
					hero = { 1 },
					deck = { 78, 188, 27, 30, 36, 63 },
					hand = { 90, 87, 95, 51 },
					ally = { },
					support = { },
					grave = { 27, 30, 63 },
				},
				side_down = {
					hero = { 6 },
					deck = { }, --155, 30, 27, 23, 155 },
					hand = { 87, 102, 95, 22, 23 },
					ally = { },
					support = { },
					--grave = { 189,43, 23, 155, 43, 23, 30, 37, 31, 32, },
					grave = { 25, 25, 43, 30, 42, 22, 93, 93, 93, 181, 93, 37 },
				},
			};
			anim.reset_data();
			logic_init_test(info);
			-- card in deck
			local deck1 = {23, 24, 51};
			card_init_table(g_logic_table[1][T_DECK], deck1, g_logic_table);

			card_init_table(g_logic_table[2][T_DECK], { 40,22,101 }, g_logic_table);
			--[[
			local hp_up = g_logic_table[1][T_HERO][1].hp;
			local hp_down = g_logic_table[2][T_HERO][1].hp;
			g_logic_table[1][T_HERO][1]:change_hp(-(hp_up-9));
			g_logic_table[2][T_HERO][1]:change_hp(-(hp_down-10));
			]]--
			g_logic_table[1].resource = 99;
			g_logic_table[1].resource_max = 99;
			g_logic_table[2].resource = 50;
			g_logic_table[2].resource_max = 50;
		else
			--print('seed, d1, d2, side', seed, deck1_array, deck2_array, side);
			data_handler:init_game(seed,deck1_array, deck2_array, side);
		end

		self:pve_do_scene(side);

		--[[
		if true == is_replay then
			return;
		end
		]]--

		if true == LOCAL_TEST or side == g_current_side then
			layer_card:init_wait_action(g_phase);
			--layer_refresh:grave();
		else
			do_ai();
		end
	end,

	pvp = function(self, side, seed, deck1_array, deck2_array, timeout, solo_data, robot_data)
		--[[
		if true == USE_FRAME then
			add_frame_cache(GUI_MATCH);
		end
		]]--
		data_handler:init_side(side); 
		data_handler:init_game(seed, deck1_array, deck2_array, side, timeout, solo_data, robot_data);

		local stage = STAGE_PVP;
		local scene = cc.Scene:create();
		local layer, name;
		layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_table:create();
		scene:addChild(layer, ZORDER_LAYER_TABLE);
		table.insert(layer_list, name);

		layer, name = layer_card:create();
		scene:addChild(layer, ZORDER_LAYER_CARD);
		table.insert(layer_list, name);

		layer, name = layer_menu:create(stage);
		scene:addChild(layer, ZORDER_LAYER_MENU);
		table.insert(layer_list, name);
		
		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);

		--net_send('room'); -- get player info

		if g_euser.side == g_current_side then
			layer_card:init_wait_action(g_phase);
		end
	end,

	pvg = function(self, side, seed, deck1_array, gate_list, gr, gate_id)
		data_handler:init_side(side); 
		data_handler:init_gate(seed, deck1_array, gate_list, side);

		local stage = STAGE_PVG;
		local scene = cc.Scene:create();
		local layer, name;
		layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_table:create();
		scene:addChild(layer, ZORDER_LAYER_TABLE);
		table.insert(layer_list, name);

		layer, name = layer_card:create();
		scene:addChild(layer, ZORDER_LAYER_CARD);
		table.insert(layer_list, name);

		layer, name = layer_menu:create(stage);
		scene:addChild(layer, ZORDER_LAYER_MENU);
		table.insert(layer_list, name);
		
		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);

		local cmd = string.format("gate_msg %d", gate_id);
		net_send(cmd);
		--net_send('room'); -- get player info

		local label = g_ui_table[SIDE_DOWN][T_HERO][1].sprite:getChildByTag(TAG_HP);
		tolua.cast(label, "cc.Label");
		if nil ~= label then
			label:setVisible(false);
		end

		g_ui_table.label_res[SIDE_UP]:setString("-");
		g_ui_table.label_res_max[SIDE_UP]:setString("-");
		layer_card.label_count_deck[SIDE_UP]:setVisible(false);
		if g_euser.side == SIDE_UP then
			layer_table:hide_name_btn(SIDE_DOWN);
		else
			layer_table:hide_name_btn(SIDE_UP);
		end
		layer_table:add_gate_tip(gr);

		if g_euser.side == g_current_side then
			layer_card:init_wait_action(g_phase);
		end
	end,

	preload = function(self, callback, action, res_stage)
		local stage = STAGE_PRELOAD;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_preload:create(callback, action, res_stage);
		scene:addChild(layer, ZORDER_LAYER_PRELOAD);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);
	end,

	deck = function(self)
		local stage = STAGE_DECK;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_deck:create();
		scene:addChild(layer, ZORDER_LAYER_DECK);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);

		local item = add_item_back_1(layer_infobar.layer, GUI_DECK, layer_deck.callback_ask_return);
		layer_deck.btn_back = item;

		local cmd = 'ldeck ' .. CARD_ARRAY_LIST;
		net_send(cmd);
	end,

	replay = function(self, side, seed, deck1_array, deck2_array)
		data_handler:cleanup();
		data_handler:init_side(side); 
		data_handler:init_game(seed,deck1_array, deck2_array, side);

		local stage = STAGE_REPLAY;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_table:create();
		scene:addChild(layer, ZORDER_LAYER_TABLE);
		table.insert(layer_list, name);

		layer, name = layer_card:create();
		scene:addChild(layer, ZORDER_LAYER_CARD);
		table.insert(layer_list, name);

		layer, name = layer_menu:create(stage);
		scene:addChild(layer, ZORDER_LAYER_MENU);
		table.insert(layer_list, name);

		layer, name = layer_control:create();
		scene:addChild(layer, ZORDER_LAYER_CONTROL);
		table.insert(layer_list, name);
		
		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);
	end,

	shop = function(self)
		local stage = STAGE_SHOP;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_shop:create();
		scene:addChild(layer, ZORDER_LAYER_SHOP);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);

		add_item_back_1(layer_infobar.layer, GUI_SHOP, layer_shop.back);

		g_list_shop = g_list_shop or {};
		if 0 == #g_list_shop then
		    layer_shop:callback_reloadlist();
		else
		    if true ~= SHOP_PAGE then
		        layer_shop:add_to_list(g_list_shop);
		    else
		        layer_shop:add_to_list(g_list_shop,g_list_shop[#g_list_shop].cid);
		    end
		end

	end,

	rank = function(self)
		local stage = STAGE_RANK;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_rank:create();
		scene:addChild(layer, ZORDER_LAYER_RANK);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		add_item_back_1(layer_infobar.layer, GUI_RANK, layer_rank.back);

		self:change_scene(scene, stage, layer_list);
	end,

	prank = function(self)
		local stage = STAGE_PRANK;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_prank:create();
		scene:addChild(layer, ZORDER_LAYER_PRANK);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		add_item_back_1(layer_infobar.layer, GUI_PRANK, layer_prank.back);

		self:change_scene(scene, stage, layer_list);
	end,

	mail = function(self)
		local stage = STAGE_MAIL;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_mail:create();
		scene:addChild(layer, ZORDER_LAYER_MAIL);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		add_item_back_1(layer_infobar.layer, GUI_MAIL, layer_mail.back);

		self:change_scene(scene, stage, layer_list);
	end,

	gm = function(self)
		local stage = STAGE_GM;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_gm:create();
		scene:addChild(layer, ZORDER_LAYER_GM);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		add_item_back_1(layer_infobar.layer, GUI_GM, layer_gm.back);

		self:change_scene(scene, stage, layer_list);
	end,

	option = function(self)
		local stage = STAGE_OPTION;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_option:create();
		scene:addChild(layer, ZORDER_LAYER_OPTION);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		add_item_back_1(layer_infobar.layer, GUI_OPTION, layer_option.back);

		self:change_scene(scene, stage, layer_list);
	end,

	lguild = function(self)
		local stage = STAGE_LGUILD;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_lguild:create();
		scene:addChild(layer, ZORDER_LAYER_LGUILD);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		add_item_back_1(layer_infobar.layer, GUI_LGUILD, layer_lguild.back);

		self:change_scene(scene, stage, layer_list);

		local cmd = 'lguild 0 ' .. layer_lguild.PAGE_SIZE;
		net_send(cmd);
	end,

	guild = function(self, info)
		if nil == info then
			info = g_euser.guild_data;
		elseif info.gid == g_euser.gid then
			g_euser.guild_data = info;
		end
		if nil == info then
			return;
		end
		local stage = STAGE_GUILD;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_guild:create(info);
		scene:addChild(layer, ZORDER_LAYER_GUILD);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		add_item_back_1(layer_infobar.layer, GUI_GUILD, layer_guild.back);

		self:change_scene(scene, stage, layer_list);
	end,

	welfare = function(self)
		local stage = STAGE_WELFARE;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_welfare:create();
		scene:addChild(layer, ZORDER_LAYER_WELFARE);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);

		local cmd = 'gbonus 0';
		net_send(cmd);
	end,

	lmember = function(self)
		local stage = STAGE_LMEMBER;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_lmember:create();
		scene:addChild(layer, ZORDER_LAYER_LMEMBER);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		add_item_back_1(layer_infobar.layer, GUI_MEMBER, layer_lmember.back);

		self:change_scene(scene, stage, layer_list);

		local cmd = 'glist 1 0 ' .. layer_lmember.PAGE_SIZE;
		net_send(cmd);
	end,

	lapply = function(self)
		local stage = STAGE_LAPPLY;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_lapply:create();
		scene:addChild(layer, ZORDER_LAYER_LAPPLY);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		add_item_back_1(layer_infobar.layer, GUI_APPROVE, layer_lapply.back);

		self:change_scene(scene, stage, layer_list);

		local cmd = 'glist 9 0 ' .. layer_lapply.PAGE_SIZE;
		net_send(cmd);
	end,

	lstock = function(self)
		local stage = STAGE_LSTOCK;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_lstock:create();
		scene:addChild(layer, ZORDER_LAYER_LSTOCK);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		add_item_back_1(layer_infobar.layer, GUI_STOCK, layer_lstock.back);

		self:change_scene(scene, stage, layer_list);

		local cmd = 'glist 1 0 ' .. layer_lstock.PAGE_SIZE;
		net_send(cmd);
	end,

	invest = function(self)
		local stage = STAGE_INVEST;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_invest:create();
		scene:addChild(layer, ZORDER_LAYER_INVEST);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		add_item_back_1(layer_infobar.layer, GUI_INVEST, layer_invest.back);

		self:change_scene(scene, stage, layer_list);

		local cmd = 'deposit';
		net_send(cmd);
	end,

	ldeposit = function(self)
		local stage = STAGE_LDEPOSIT;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_ldeposit:create();
		scene:addChild(layer, ZORDER_LAYER_LDEPOSIT);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		add_item_back_1(layer_infobar.layer, GUI_RECORD, layer_ldeposit.back);

		self:change_scene(scene, stage, layer_list);

		local cmd = 'ldeposit 0 ' .. layer_ldeposit.PAGE_SIZE;
		net_send(cmd);
	end,
} -- g_scene end
-- /////////////////////// GAME END   ///////////////////////////

function game_initialize()
	local dic = cc.FileUtils:getInstance():getValueMapFromFile("game_config.plist");
	CPID = dic["CPID"];
	CHANNEL_VER = dic["CHANNEL_VER"];
	--VER_APPSTORE = dic["VER_APPSTORE"];
	--VER_APAY = dic["VER_APAY"]; -- mark as 4, avoid old client's 2
	--VER_ANYSDK = dic["VER_ANYSDK"];
	--VER_ANYSDK_NO_LOGIN = dic["VER_ANYSDK_NO_LOGIN"];
	--VER_LJSDK = dic["VER_LJSDK"];
	--VER_UCSDK = dic["VER_UCSDK"];
	if true ~= v_anysdk_init_flag and false == g_anysdk_init and (is_ver(VER_ANYSDK) or is_ver(VER_ANYSDK_NO_LOGIN)) then
		require ("anysdkConst");
		--[[
		配置SDK信息(此处填写的sdk参数为开发者在渠道申请得到的应用参数。其中登录回调地址>和支付回调地址是游戏服务器端提供的分别用于转发登录验证信息和接收订单支付信息的接口地址，
		如果开发者在服务器端还没有实现相应功能，可使用我们提供的两个测试地址。
		登录验证地址：
		http://oauth.anysdk.com/api/OauthLoginDemo/Login.php
		支付通知地址：
		http://pay.anysdk.com/callbacktest/gameServerNotify.php
		但是在正式产品打包时不能使用这两个地址，要填写游戏服务器提供的接口地址)。
		]]--
		--注意：这里appKey, appSecret, privateKey，要替换成自己打包工具里面的值(登录打包工具，游戏管理界面上显示的那三个参数)。
		--local oauthLoginServer = "http://oauth.anysdk.com/api/OauthLoginDemo/Login.php";
		local agent = AgentManager:getInstance();
		if false == g_anysdk_init then
			local appKey = "3914B2B1-A932-9543-3CA9-31ED2ED19477";
			local appSecret = "04ad2aabbc8e4cac0f8f1aec0e3e2ee3";
			local privateKey = "7D2713641F7809036DB5AB2FC78C8ABE";
			--local oauthLoginServer = "http://t3.17kapai.com:8899/pay_server/anysdklogin";
			local oauthLoginServer = string.format("http://%s:8899/pay_server/anysdklogin", IP_ADDR);
			--init
			agent:init(appKey,appSecret,privateKey,oauthLoginServer);
		end
		--load
		agent:loadALLPlugin();

		g_anysdk_init = true;
	end
	if true == is_ver(VER_APPSTORE) then
		local args = {};        
		local luaoc = require "luaoc";
		local class_name = "IAPView";
		local ok, ret = luaoc.callStaticMethod(class_name, "checkIAPClear", args);
	end
	-- main_init
    local vsize = cc.Director:getInstance():getVisibleSize()	 
	FULL_WIDTH = vsize.width;
	FULL_HEIGHT = vsize.height;
    HALF_WIDTH = FULL_WIDTH / 2;
    HALF_HEIGHT = FULL_HEIGHT / 2;
	util.load_volume();

	local path = util.get_fullpath(F_MUSIC, 'tap_1.mp3');
	util.preload_effect(path);
	path = util.get_fullpath(F_MUSIC, 'tap_2.mp3');
	util.preload_effect(path);
	path = util.get_fullpath(F_MUSIC, 'tap_3.mp3');
	util.preload_effect(path);
	path = util.get_fullpath(F_MUSIC, 'turn_card.mp3');
	util.preload_effect(path);

	--local lang_type = cc.Application:getInstance():getCurrentLanguage();
	--if lang_type == cc.LANGUAGE_CHINESE then
	local lang_type = get_lang();
	if lang_type == 1 then -- chinese
		g_lang = EVIL_LANG_CHINESE;
		F_LANG = 'image_cn/';
	else -- 2 english
		g_lang = EVIL_LANG_ENGLISH;
		F_LANG = 'image_en/';
	end

	-- gui init
	g_scale = {};
	g_scale.x = FULL_WIDTH / SCREEN_SIZE_REF.width;
	g_scale.y = FULL_HEIGHT / SCREEN_SIZE_REF.height;

	set_gui_list_data(F_DOCX);

	if g_scale.x > g_scale.y then
		ANIM_SCALE_CENTER = g_scale.y;
	else
		ANIM_SCALE_CENTER = g_scale.x;
	end

	if true == DEBUG_MODE then
		SHOW_ALL = true;
	end

	util.load_sensitive_data();
end

--var_test_time = os.date("%X", os.time());
function start_game()
	--[[ now do in version.lua
	IP_ADDR = util.load_rms('ip_addr', 'string') or '';
	if '' == IP_ADDR then
		local server_list = util.load_server();
		if 0 < #server_list then
			IP_ADDR = server_list[1].ip;
		end
	end
	]]--
	kdebug(">>>>>>>>>>> game ip [%s] <<<<<<<<<<<<", IP_ADDR);
	util.save_rms('re_update_lua', 'no', 'string');
	--LayerSocket:initSocketRes(IP_ADDR);
	game_initialize();
	g_scene:login();
end

kdebug(' require game ');
